<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>gRPC – Documentation</title>
    <link>https://Joevaen.github.io/docs/</link>
    <description>Recent content in Documentation on gRPC</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    
	  <atom:link href="https://Joevaen.github.io/docs/feed.xml" rel="self" type="application/rss+xml" />
    
    
      
        
      
    
    
    <item>
      <title>Docs: Introduction to gRPC</title>
      <link>https://Joevaen.github.io/docs/what-is-grpc/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/what-is-grpc/introduction/</guid>
      <description>
        
        
        &lt;p&gt;This page introduces you to gRPC and protocol buffers. gRPC can use
protocol buffers as both its Interface Definition Language (&lt;strong&gt;IDL&lt;/strong&gt;) and as its underlying message
interchange format. If you’re new to gRPC and/or protocol buffers, read this!
If you just want to dive in and see gRPC in action first,
&lt;a href=&#34;https://Joevaen.github.io/docs/languages/&#34;&gt;select a language&lt;/a&gt; and try its &lt;strong&gt;Quick start&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;In gRPC, a client application can directly call a method on a server application
on a different machine as if it were a local object, making it easier for you to
create distributed applications and services. As in many RPC systems, gRPC is
based around the idea of defining a service, specifying the methods that can be
called remotely with their parameters and return types. On the server side, the
server implements this interface and runs a gRPC server to handle client calls.
On the client side, the client has a stub (referred to as just a client in some
languages) that provides the same methods as the server.&lt;/p&gt;
&lt;p&gt;

&lt;figure class=&#34;text-center&#34;&gt;
  &lt;img class=&#34;modal-trigger&#34; src=&#34;https://Joevaen.github.io/img/landing-2.svg&#34; alt=&#34;Concept Diagram&#34; id=&#34;landing-2.svg&#34; data-toggle=&#34;modal&#34; data-target=&#34;#modal-landing-2.svg&#34;/&gt;

  &lt;div class=&#34;modal&#34; id=&#34;modal-landing-2.svg&#34;&gt;
    &lt;div class=&#34;modal-dialog modal-lg modal-dialog-centered&#34;&gt;
      &lt;div class=&#34;modal-body&#34;&gt;
        &lt;img src=&#34;https://Joevaen.github.io/img/landing-2.svg&#34; alt=&#34;Concept Diagram&#34;/&gt;
      &lt;/div&gt;
  &lt;/div&gt;
&lt;/figure&gt;
&lt;/p&gt;
&lt;p&gt;gRPC clients and servers can run and talk to each other in a variety of
environments - from servers inside Google to your own desktop - and can be
written in any of gRPC&amp;rsquo;s supported languages. So, for example, you can easily
create a gRPC server in Java with clients in Go, Python, or Ruby. In addition,
the latest Google APIs will have gRPC versions of their interfaces, letting you
easily build Google functionality into your applications.&lt;/p&gt;
&lt;h3 id=&#34;working-with-protocol-buffers&#34;&gt;Working with Protocol Buffers&lt;/h3&gt;
&lt;p&gt;By default, gRPC uses &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Protocol Buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, Google’s
mature open source mechanism for serializing structured data (although it
can be used with other data formats such as JSON). Here&amp;rsquo;s a quick intro to how
it works. If you&amp;rsquo;re already familiar with protocol buffers, feel free to skip
ahead to the next section.&lt;/p&gt;
&lt;p&gt;The first step when working with protocol buffers is to define the structure
for the data you want to serialize in a &lt;em&gt;proto file&lt;/em&gt;: this is an ordinary text
file with a &lt;code&gt;.proto&lt;/code&gt; extension. Protocol buffer data is structured as
&lt;em&gt;messages&lt;/em&gt;, where each message is a small logical record of information
containing a series of name-value pairs called &lt;em&gt;fields&lt;/em&gt;. Here&amp;rsquo;s a simple
example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Person&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; id &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;bool&lt;/span&gt; has_ponycopter &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;3&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then, once you&amp;rsquo;ve specified your data structures, you use the protocol buffer
compiler &lt;code&gt;protoc&lt;/code&gt; to generate data access classes in your preferred language(s)
from your proto definition. These provide simple accessors for each field,
like &lt;code&gt;name()&lt;/code&gt; and &lt;code&gt;set_name()&lt;/code&gt;, as well as methods to serialize/parse
the whole structure to/from raw bytes. So, for instance, if your chosen
language is C++, running the compiler on the example above will generate a
class called &lt;code&gt;Person&lt;/code&gt;. You can then use this class in your application to
populate, serialize, and retrieve &lt;code&gt;Person&lt;/code&gt; protocol buffer messages.&lt;/p&gt;
&lt;p&gt;You define gRPC services
in ordinary proto files, with RPC method parameters and return types specified as
protocol buffer messages:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeter service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;gRPC uses &lt;code&gt;protoc&lt;/code&gt; with a special gRPC plugin to
generate code from your proto file: you get
generated gRPC client and server code, as well as the regular protocol buffer
code for populating, serializing, and retrieving your message types. You&amp;rsquo;ll
see an example of this below.&lt;/p&gt;
&lt;p&gt;To learn more about protocol buffers, including how to install &lt;code&gt;protoc&lt;/code&gt; with the
gRPC plugin in your chosen language, see the &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers documentation&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;protocol-buffer-versions&#34;&gt;Protocol buffer versions&lt;/h2&gt;
&lt;p&gt;While &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; have been available to open source users for some time,
most examples from this site use protocol buffers version 3 (proto3), which has
a slightly simplified syntax, some useful new features, and supports more
languages. Proto3 is currently available in Java, C++, Dart, Python,
Objective-C, C#, a lite-runtime (Android Java), Ruby, and JavaScript from the
&lt;a href=&#34;https://github.com/google/protobuf/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers GitHub repo&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, as well as a Go language generator from the
&lt;a href=&#34;https://github.com/golang/protobuf&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;golang/protobuf GitHub repo&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, with more languages in development. You can
find out more in the &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and the &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;reference
documentation&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; available for each language. The reference documentation also
includes a &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/proto3-spec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;formal specification&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; for the &lt;code&gt;.proto&lt;/code&gt; file format.&lt;/p&gt;
&lt;p&gt;In general, while you can use proto2 (the current default protocol buffers
version), we recommend that you use proto3 with gRPC as it lets you use the
full range of gRPC-supported languages, as well as avoiding compatibility
issues with proto2 clients talking to proto3 servers and vice versa.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/cpp/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/cpp/quickstart/</guid>
      <description>
        
        
        &lt;p&gt;In the C++ world, there&amp;rsquo;s no universally accepted standard for managing project
dependencies. You need to build and install gRPC before building and running
this quick start&amp;rsquo;s Hello World example.&lt;/p&gt;
&lt;h3 id=&#34;install-grpc&#34;&gt;Build and locally install gRPC and Protocol Buffers&lt;/h3&gt;
&lt;p&gt;The steps in the section explain how to build and locally install gRPC and
Protocol Buffers using &lt;code&gt;cmake&lt;/code&gt;. If you&amp;rsquo;d rather use &lt;a href=&#34;https://www.bazel.build&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;bazel&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, see &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/BUILDING.md#build-from-source&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Building
from source&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;setup&#34;&gt;Setup&lt;/h4&gt;
&lt;p&gt;Choose a directory to hold locally installed packages. This page assumes that
the environment variable &lt;code&gt;MY_INSTALL_DIR&lt;/code&gt; holds this directory path. For
example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;MY_INSTALL_DIR&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$HOME&lt;/span&gt;/.local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Ensure that the directory exists:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ mkdir -p &lt;span style=&#34;color:#033&#34;&gt;$MY_INSTALL_DIR&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Add the local &lt;code&gt;bin&lt;/code&gt; folder to your path variable, for example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;PATH&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$MY_INSTALL_DIR&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;/bin:&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$PATH&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;install-cmake&#34;&gt;Install cmake&lt;/h4&gt;
&lt;p&gt;You need version 3.13 or later of &lt;code&gt;cmake&lt;/code&gt;. Install it by
following these instructions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ sudo apt install -y cmake
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;macOS:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ brew install cmake
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;For general &lt;code&gt;cmake&lt;/code&gt; installation instructions, see &lt;a href=&#34;https://cmake.org/install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Installing CMake&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Check the version of &lt;code&gt;cmake&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ cmake --version
cmake version 3.19.6
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Under Linux, the version of the system-wide &lt;code&gt;cmake&lt;/code&gt; can often be too old. You
can install a more recent version into your local installation directory as
follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ wget -q -O cmake-linux.sh https://github.com/Kitware/CMake/releases/download/v3.19.6/cmake-3.19.6-Linux-x86_64.sh
$ sh cmake-linux.sh -- --skip-license --prefix&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$MY_INSTALL_DIR&lt;/span&gt;
$ rm cmake-linux.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;install-other-required-tools&#34;&gt;Install other required tools&lt;/h4&gt;
&lt;p&gt;Install the basic tools required to build gRPC:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Linux&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ sudo apt install -y build-essential autoconf libtool pkg-config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;macOS:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ brew install autoconf automake libtool pkg-config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;clone-the-grpc-repo&#34;&gt;Clone the &lt;code&gt;grpc&lt;/code&gt; repo&lt;/h4&gt;
&lt;p&gt;Clone the &lt;code&gt;grpc&lt;/code&gt; repo and its submodules:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone --recurse-submodules -b v1.37.1 https://github.com/grpc/grpc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;build-and-install-grpc-protocol-buffers-and-abseil&#34;&gt;Build and install gRPC, Protocol Buffers, and Abseil&lt;/h4&gt;
&lt;p&gt;While not mandatory, gRPC applications usually leverage &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Protocol Buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
for service definitions and data serialization, and the example code uses
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;gRPC uses the &lt;a href=&#34;https://github.com/abseil/abseil-cpp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Abseil C++ library&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, so it needs to be installed as well.&lt;/p&gt;
&lt;p&gt;The following commands build and locally install gRPC, Protocol Buffers, and Abseil:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc
$ mkdir -p cmake/build
$ &lt;span style=&#34;color:#366&#34;&gt;pushd&lt;/span&gt; cmake/build
$ cmake -DgRPC_INSTALL&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;ON &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;      -DgRPC_BUILD_TESTS&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;OFF &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;      -DCMAKE_INSTALL_PREFIX&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$MY_INSTALL_DIR&lt;/span&gt; &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;      ../..
$ make -j
$ make install
$ &lt;span style=&#34;color:#366&#34;&gt;popd&lt;/span&gt;
$ mkdir -p third_party/abseil-cpp/cmake/build
$ &lt;span style=&#34;color:#366&#34;&gt;pushd&lt;/span&gt; third_party/abseil-cpp/cmake/build
$ cmake -DCMAKE_INSTALL_PREFIX&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$MY_INSTALL_DIR&lt;/span&gt; &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;      -DCMAKE_POSITION_INDEPENDENT_CODE&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;TRUE &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;      ../..
$ make -j
$ make install
$ &lt;span style=&#34;color:#366&#34;&gt;popd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-warning&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Important&lt;/h4&gt;

    We &lt;strong&gt;strongly&lt;/strong&gt; encourage you to install gRPC &lt;em&gt;locally&lt;/em&gt; — using an
appropriately set &lt;code&gt;CMAKE_INSTALL_PREFIX&lt;/code&gt; — because there is no easy way
to uninstall gRPC after you&amp;rsquo;ve installed it globally.

&lt;/div&gt;

&lt;p&gt;More information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;You can find a complete set of instructions for building gRPC C++ in &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/BUILDING.md#build-from-source&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Building
from source&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;For general instructions on how to add gRPC as a dependency to your C++
project, see &lt;a href=&#34;https://github.com/grpc/grpc/tree/master/src/cpp#to-start-using-grpc-c&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Start using gRPC C++&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;build-the-example&#34;&gt;Build the example&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;code&gt;grpc&lt;/code&gt; repo source, which you cloned as part of
the steps of the previous section.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Change to the example&amp;rsquo;s directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; examples/cpp/helloworld
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Build the example using &lt;code&gt;cmake&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ mkdir -p cmake/build
$ &lt;span style=&#34;color:#366&#34;&gt;pushd&lt;/span&gt; cmake/build
$ cmake -DCMAKE_PREFIX_PATH&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$MY_INSTALL_DIR&lt;/span&gt; ../..
$ make -j
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    &lt;strong&gt;Getting build failures?&lt;/strong&gt; Most issues, at this point, are a result of a
faulty installation. Ensure that the have the right versions of &lt;code&gt;cmake&lt;/code&gt;, and
carefully recheck your installation.

&lt;/div&gt;

&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;try-it&#34;&gt;Try it!&lt;/h3&gt;
&lt;p&gt;Run the example from the example &lt;strong&gt;build&lt;/strong&gt; directory
&lt;code&gt;examples/cpp/helloworld/cmake/build&lt;/code&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./greeter_server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From a different terminal, run the client and see the client output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./greeter_client
Greeter received: Hello world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how to update the application with an extra method on the
server for the client to call. Our gRPC service is defined using protocol
buffers; you can find out lots more about how to define a service in a &lt;code&gt;.proto&lt;/code&gt;
file in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and &lt;a href=&#34;../basics/&#34;&gt;Basics
tutorial&lt;/a&gt;. For now all you need to know is that both the
server and the client stub have a &lt;code&gt;SayHello()&lt;/code&gt; RPC method that takes a
&lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a &lt;code&gt;HelloResponse&lt;/code&gt; from the
server, and that this method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Open &lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/protos/helloworld.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/protos/helloworld.proto&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and add a new &lt;code&gt;SayHelloAgain()&lt;/code&gt; method, with the
same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;regenerate-grpc-code&#34;&gt;Regenerate gRPC code&lt;/h3&gt;
&lt;p&gt;Before you can use the new service method, you need to recompile the updated
proto file.&lt;/p&gt;
&lt;p&gt;From the example &lt;strong&gt;build&lt;/strong&gt; directory &lt;code&gt;examples/cpp/helloworld/cmake/build&lt;/code&gt;, run:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ make -j
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This regenerates &lt;code&gt;helloworld.pb.{h,cc}&lt;/code&gt; and &lt;code&gt;helloworld.grpc.pb.{h,cc}&lt;/code&gt;, which
contains the generated client and server classes, as well as classes for
populating, serializing, and retrieving our request and response types.&lt;/p&gt;
&lt;h3 id=&#34;update-and-run-the-application&#34;&gt;Update and run the application&lt;/h3&gt;
&lt;p&gt;You have new generated server and client code, but you still need to implement
and call the new method in the human-written parts of our example application.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;Open &lt;code&gt;greeter_server.cc&lt;/code&gt; from the example&amp;rsquo;s root directory. Implement the new
method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;GreeterServiceImpl&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; Greeter&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;Service {
  Status &lt;span style=&#34;color:#c0f&#34;&gt;SayHello&lt;/span&gt;(ServerContext&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; context, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; HelloRequest&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; request,
                  HelloReply&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; reply) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; {
     &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  }

  Status &lt;span style=&#34;color:#c0f&#34;&gt;SayHelloAgain&lt;/span&gt;(ServerContext&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; context, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; HelloRequest&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; request,
                       HelloReply&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; reply) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; {
    std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string prefix(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello again &amp;#34;&lt;/span&gt;);
    reply&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;set_message(prefix &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;name());
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; Status&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;OK;
  }
};

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;A new &lt;code&gt;SayHelloAgain()&lt;/code&gt; method is now available in the stub. We&amp;rsquo;ll follow the
same pattern as for the already present &lt;code&gt;SayHello()&lt;/code&gt; and add a new
&lt;code&gt;SayHelloAgain()&lt;/code&gt; method to &lt;code&gt;GreeterClient&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;GreeterClient&lt;/span&gt; {
 &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt;
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string SayHello(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt; user) {
     &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  }

  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string SayHelloAgain(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt; user) {
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Follows the same pattern as SayHello.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    HelloRequest request;
    request.set_name(user);
    HelloReply reply;
    ClientContext context;

    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Here we can use the stub&amp;#39;s newly available method we just added.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    Status status &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub_&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;SayHelloAgain(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;context, request, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;reply);
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (status.ok()) {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; reply.message();
    } &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;else&lt;/span&gt; {
      std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; status.error_code() &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; status.error_message()
                &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;endl;
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;RPC failed&amp;#34;&lt;/span&gt;;
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, invoke this new method in &lt;code&gt;main()&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;char&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;**&lt;/span&gt; argv) {
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string reply &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; greeter.SayHello(user);
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeter received: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; reply &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;endl;

  reply &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; greeter.SayHelloAgain(user);
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeter received: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; reply &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;endl;

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;run&#34;&gt;Run!&lt;/h4&gt;
&lt;p&gt;Run the client and server like you did before. Execute the following commands
from the example &lt;strong&gt;build&lt;/strong&gt; directory &lt;code&gt;examples/cpp/helloworld/cmake/build&lt;/code&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Build the client and server after having made changes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ make -j
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./greeter_server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On a different terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./greeter_client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You&amp;rsquo;ll see the following output:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nocode&#34; data-lang=&#34;nocode&#34;&gt;Greeter received: Hello world
Greeter received: Hello again world
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    Interested in an &lt;strong&gt;asynchronous&lt;/strong&gt; version of the client and server?
You&amp;rsquo;ll find the &lt;code&gt;greeter_async_{client,server}.cc&lt;/code&gt; files in the
&lt;a href=&#34;https://github.com/grpc/grpc/tree/master/examples/cpp/helloworld&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example&amp;rsquo;s source directory&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.

&lt;/div&gt;

&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/csharp/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/csharp/quickstart/</guid>
      <description>
        
        
        

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    This page uses the &lt;a href=&#34;https://github.com/grpc/grpc/tree/master/src/csharp&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC C# core-library&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; implementation. For
documentation covering gRPC for .NET, see &lt;a href=&#34;../dotnet/&#34;&gt;gRPC for .NET&lt;/a&gt;.

&lt;/div&gt;

&lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;p&gt;Whether you&amp;rsquo;re using Windows, OS X, or Linux, you can follow this
example by using either an IDE and its build tools,
or by using the the .NET Core SDK command line tools.&lt;/p&gt;
&lt;p&gt;First, make sure you have installed the
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/src/csharp/README.md#prerequisites&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC C# prerequisites&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
You will also need Git to download the sample code.&lt;/p&gt;
&lt;h3 id=&#34;download-the-example&#34;&gt;Download the example&lt;/h3&gt;
&lt;p&gt;You&amp;rsquo;ll need a local copy of the example code to work through this quick start.
Download the example code from our GitHub repository (the following command
clones the entire repository, but you just need the examples for this quick start
and other tutorials):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# Clone the repository to get the example code:&lt;/span&gt;
$ git clone -b v1.37.1 https://github.com/grpc/grpc
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This document will walk you through the &amp;ldquo;Hello World&amp;rdquo; example.
The projects and source files can be found in the &lt;code&gt;examples/csharp/Helloworld&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;The example in this walkthrough already adds the necessary
dependencies for you (&lt;code&gt;Grpc&lt;/code&gt;, &lt;code&gt;Grpc.Tools&lt;/code&gt; and &lt;code&gt;Google.Protobuf&lt;/code&gt; NuGet packages).&lt;/p&gt;
&lt;h3 id=&#34;build-the-example&#34;&gt;Build the example&lt;/h3&gt;
&lt;h4 id=&#34;using-visual-studio-or-visual-studio-for-mac&#34;&gt;Using Visual Studio (or Visual Studio for Mac)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Open the solution &lt;code&gt;Greeter.sln&lt;/code&gt; with Visual Studio&lt;/li&gt;
&lt;li&gt;Build the solution&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;using-net-core-sdk-from-the-command-line&#34;&gt;Using .NET Core SDK from the command line&lt;/h4&gt;
&lt;p&gt;From the &lt;code&gt;examples/csharp/Helloworld&lt;/code&gt; directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&amp;gt; dotnet build Greeter.sln
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    If you want to use gRPC C# from a project that uses the &amp;ldquo;classic&amp;rdquo; .csproj files (supported by Visual Studio 2013, 2015 and older versions of Mono), please refer to the
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/csharp/HelloworldLegacyCsproj/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Greeter using &amp;ldquo;classic&amp;rdquo; .csproj&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; example.

&lt;/div&gt;

&lt;h3 id=&#34;run-a-grpc-application&#34;&gt;Run a gRPC application&lt;/h3&gt;
&lt;p&gt;From the &lt;code&gt;examples/csharp/Helloworld&lt;/code&gt; directory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&amp;gt; &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; GreeterServer
&amp;gt; dotnet run -f netcoreapp2.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&amp;gt; &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; GreeterClient
&amp;gt; dotnet run -f netcoreapp2.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how to update the application with an extra method on the
server for the client to call. Our gRPC service is defined using protocol
buffers; you can find out lots more about how to define a service in a &lt;code&gt;.proto&lt;/code&gt;
file in &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;. For now all you need to know is that both the
server and the client &amp;ldquo;stub&amp;rdquo; have a &lt;code&gt;SayHello&lt;/code&gt; RPC method that takes a
&lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a &lt;code&gt;HelloResponse&lt;/code&gt; from the
server, and that this method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s update this so that the &lt;code&gt;Greeter&lt;/code&gt; service has two methods. Edit
&lt;code&gt;examples/protos/helloworld.proto&lt;/code&gt; and update it with a new &lt;code&gt;SayHelloAgain&lt;/code&gt;
method, with the same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;generate-grpc-code&#34;&gt;Generate gRPC code&lt;/h3&gt;
&lt;p&gt;Next we need to update the gRPC code used by our application to use the new service definition.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Grpc.Tools&lt;/code&gt; NuGet package contains the protoc and protobuf C# plugin binaries needed
to generate the code. Starting from version 1.17 the package also integrates with
MSBuild to provide &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;automatic C# code generation&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
from &lt;code&gt;.proto&lt;/code&gt; files.&lt;/p&gt;
&lt;p&gt;This example project already depends on the &lt;code&gt;Grpc.Tools.1.37.1&lt;/code&gt; NuGet package so just re-building the solution
is enough to regenerate the code from our modified &lt;code&gt;.proto&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;You can rebuild just like we first built the original
example by running &lt;code&gt;dotnet build Greeter.sln&lt;/code&gt; or by clicking &amp;ldquo;Build&amp;rdquo; in Visual Studio.&lt;/p&gt;
&lt;p&gt;The build regenerates the following files
under the &lt;code&gt;Greeter/obj/Debug/TARGET_FRAMEWORK&lt;/code&gt; directory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Helloworld.cs&lt;/code&gt; contains all the protocol buffer code to populate,
serialize, and retrieve our request and response message types&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HelloworldGrpc.cs&lt;/code&gt; provides generated client and server classes,
including:
&lt;ul&gt;
&lt;li&gt;an abstract class &lt;code&gt;Greeter.GreeterBase&lt;/code&gt; to inherit from when defining
Greeter service implementations&lt;/li&gt;
&lt;li&gt;a class &lt;code&gt;Greeter.GreeterClient&lt;/code&gt; that can be used to access remote Greeter
instances&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;update-and-run-the-application&#34;&gt;Update and run the application&lt;/h3&gt;
&lt;p&gt;We now have new generated server and client code, but we still need to implement
and call the new method in the human-written parts of our example application.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;With the &lt;code&gt;Greeter.sln&lt;/code&gt; open in your IDE, open &lt;code&gt;GreeterServer/Program.cs&lt;/code&gt;.
Implement the new method by editing the GreeterImpl class like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C#&#34; data-lang=&#34;C#&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;GreeterImpl&lt;/span&gt; : Greeter.GreeterBase
{
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Server side handler of the SayHello RPC
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; Task&amp;lt;HelloReply&amp;gt; SayHello(HelloRequest request, ServerCallContext context)
    {
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; Task.FromResult(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; HelloReply { Message = &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello &amp;#34;&lt;/span&gt; + request.Name });
    }

    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Server side handler for the SayHelloAgain RPC
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; Task&amp;lt;HelloReply&amp;gt; SayHelloAgain(HelloRequest request, ServerCallContext context)
    {
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; Task.FromResult(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; HelloReply { Message = &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello again &amp;#34;&lt;/span&gt; + request.Name });
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;With the same &lt;code&gt;Greeter.sln&lt;/code&gt; open in your IDE, open &lt;code&gt;GreeterClient/Program.cs&lt;/code&gt;.
Call the new method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-C#&#34; data-lang=&#34;C#&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;void&lt;/span&gt; Main(&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt;[] args)
{
    Channel channel = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Channel(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;127.0.0.1:50051&amp;#34;&lt;/span&gt;, ChannelCredentials.Insecure);

    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; client = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Greeter.GreeterClient(channel);
    String user = &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;you&amp;#34;&lt;/span&gt;;

    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; reply = client.SayHello(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; HelloRequest { Name = user });
    Console.WriteLine(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeting: &amp;#34;&lt;/span&gt; + reply.Message);

    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; secondReply = client.SayHelloAgain(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; HelloRequest { Name = user });
    Console.WriteLine(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeting: &amp;#34;&lt;/span&gt; + secondReply.Message);

    channel.ShutdownAsync().Wait();
    Console.WriteLine(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Press any key to exit...&amp;#34;&lt;/span&gt;);
    Console.ReadKey();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;rebuild-the-modified-example&#34;&gt;Rebuild the modified example&lt;/h4&gt;
&lt;p&gt;Rebuild the newly modified example just like we first built the original
example by running &lt;code&gt;dotnet build Greeter.sln&lt;/code&gt; or by clicking &amp;ldquo;Build&amp;rdquo; in Visual Studio.&lt;/p&gt;
&lt;h4 id=&#34;run&#34;&gt;Run!&lt;/h4&gt;
&lt;p&gt;Just like we did before, from the &lt;code&gt;examples/csharp/Helloworld&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&amp;gt; &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; GreeterServer
&amp;gt; dotnet run -f netcoreapp2.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&amp;gt; &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; GreeterClient
&amp;gt; dotnet run -f netcoreapp2.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/dart/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/dart/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://dart.dev&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Dart&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/strong&gt; version 2.12 or higher, through the Dart or &lt;a href=&#34;https://flutter.dev&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Flutter&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; SDKs&lt;/p&gt;
&lt;p&gt;For installation instructions, see &lt;a href=&#34;https://dart.dev/install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Install Dart&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; or &lt;a href=&#34;https://flutter.dev/docs/get-started/install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Install Flutter&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Protocol buffer&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; compiler&lt;/strong&gt;, &lt;code&gt;protoc&lt;/code&gt;, &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;version 3&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;For installation instructions, see &lt;a href=&#34;https://Joevaen.github.io/docs/protoc-installation/&#34;&gt;Protocol Buffer Compiler
Installation&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Dart plugin&lt;/strong&gt; for the protocol compiler:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Install the protocol compiler plugin for Dart (&lt;code&gt;protoc-gen-dart&lt;/code&gt;) using
the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ dart pub global activate protoc_plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Update your &lt;code&gt;PATH&lt;/code&gt; so that the &lt;code&gt;protoc&lt;/code&gt; compiler can find the plugin:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;PATH&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$PATH&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$HOME&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;/.pub-cache/bin&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    Dart gRPC supports the Flutter and Server platforms.

&lt;/div&gt;

&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-dart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-dart&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-dart/archive/master.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone https://github.com/grpc/grpc-dart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the quick start example directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-dart/example/helloworld
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-the-example&#34;&gt;Run the example&lt;/h3&gt;
&lt;p&gt;From the &lt;code&gt;example/helloworld&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Download package dependencies:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ dart pub get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ dart bin/server.dart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ dart bin/client.dart
Greeter client received: Hello, world!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-app&#34;&gt;Update the app&lt;/h3&gt;
&lt;p&gt;In this section you&amp;rsquo;ll update the app to make use of an extra server method. The
gRPC service is defined using &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. To learn more about how to
define a service in a &lt;code&gt;.proto&lt;/code&gt; file, see &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;. For now, all you
need to know is that both the server and the client stub have a &lt;code&gt;SayHello()&lt;/code&gt; RPC
method that takes a &lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a
&lt;code&gt;HelloReply&lt;/code&gt; from the server, and that the method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h4&gt;
&lt;p&gt;Open &lt;code&gt;protos/helloworld.proto&lt;/code&gt; and add a new &lt;code&gt;SayHelloAgain()&lt;/code&gt; method, with the
same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h4 id=&#34;regenerate-grpc-code&#34;&gt;Regenerate gRPC code&lt;/h4&gt;
&lt;p&gt;Before you can use the new service method, you need to recompile the updated
proto file. From the &lt;code&gt;example/helloworld&lt;/code&gt; directory, run the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ protoc --dart_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;grpc:lib/src/generated -Iprotos protos/helloworld.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You&amp;rsquo;ll find the regenerated request and response classes, and client and server
classes in the &lt;code&gt;lib/src/generated&lt;/code&gt; directory.&lt;/p&gt;
&lt;p&gt;Now implement and call the new RPC in the server and client code, respectively.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;Open &lt;code&gt;bin/server.dart&lt;/code&gt; and add the following &lt;code&gt;sayHelloAgain()&lt;/code&gt; method to the
&lt;code&gt;GreeterService&lt;/code&gt; class:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;GreeterService&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;extends&lt;/span&gt; GreeterServiceBase {
  &lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;@&lt;/span&gt;override
  Future&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;HelloReply&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; sayHello(ServiceCall call, HelloRequest request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; HelloReply()..message &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Hello, &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${&lt;/span&gt;request.name&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;!&amp;#39;&lt;/span&gt;;
  }

  &lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;@&lt;/span&gt;override
  Future&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;HelloReply&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; sayHelloAgain(ServiceCall call, HelloRequest request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; HelloReply()..message &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Hello again, &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${&lt;/span&gt;request.name&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;!&amp;#39;&lt;/span&gt;;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;Add a call to &lt;code&gt;sayHelloAgain()&lt;/code&gt; in &lt;code&gt;bin/client.dart&lt;/code&gt; like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;Future&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; main(List&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; args) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; channel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; ClientChannel(
    &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#99f&#34;&gt;port:&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;,
    &lt;span style=&#34;color:#99f&#34;&gt;options:&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; ChannelOptions(&lt;span style=&#34;color:#99f&#34;&gt;credentials:&lt;/span&gt; ChannelCredentials.insecure()),
  );
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; stub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; GreeterClient(channel);

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; args.isNotEmpty &lt;span style=&#34;color:#555&#34;&gt;?&lt;/span&gt; args[&lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;world&amp;#39;&lt;/span&gt;;

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;try&lt;/span&gt; {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; response &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; stub.sayHello(HelloRequest()..name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; name);
    print(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Greeter client received: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${&lt;/span&gt;response.message&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&lt;/span&gt;);
    response &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; stub.sayHelloAgain(HelloRequest()..name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; name);
    print(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Greeter client received: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${&lt;/span&gt;response.message&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&lt;/span&gt;);
  } &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;catch&lt;/span&gt; (e) {
    print(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Caught error: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;$&lt;/span&gt;e&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&lt;/span&gt;);
  }
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; channel.shutdown();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;run-the-updated-app&#34;&gt;Run the updated app&lt;/h3&gt;
&lt;p&gt;Run the client and server like you did before. Execute the following commands
from the &lt;code&gt;example/helloworld&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ dart bin/server.dart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client. This time, add a name as a command-line
argument:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ dart bin/client.dart Alice
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You&amp;rsquo;ll see the following output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;Greeter client received: Hello, Alice!
Greeter client received: Hello again, Alice!
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;contributing&#34;&gt;Contributing&lt;/h3&gt;
&lt;p&gt;If you experience problems with Dart gRPC or have a feature request, &lt;a href=&#34;https://github.com/grpc/grpc-dart/issues/new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;create an
issue&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; over the &lt;a href=&#34;https://github.com/grpc/grpc-dart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-dart&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/go/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/go/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://golang.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/strong&gt;, any one of the &lt;strong&gt;three latest major&lt;/strong&gt; &lt;a href=&#34;https://golang.org/doc/devel/release.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;releases of Go&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For installation instructions, see Go&amp;rsquo;s &lt;a href=&#34;https://golang.org/doc/install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Getting Started&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; guide.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Protocol buffer&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; compiler&lt;/strong&gt;, &lt;code&gt;protoc&lt;/code&gt;, &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;version 3&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For installation instructions, see &lt;a href=&#34;https://Joevaen.github.io/docs/protoc-installation/&#34;&gt;Protocol Buffer Compiler
Installation&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Go plugins&lt;/strong&gt; for the protocol compiler:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Install the protocol compiler plugins for Go using the following commands:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26
$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Update your &lt;code&gt;PATH&lt;/code&gt; so that the &lt;code&gt;protoc&lt;/code&gt; compiler can find the plugins:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;PATH&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$PATH&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;:&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;$(&lt;/span&gt;go env GOPATH&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;)&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;/bin&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-go&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-go/archive/v1.35.0.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.35.0 https://github.com/grpc/grpc-go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the quick start example directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-go/examples/helloworld
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-the-example&#34;&gt;Run the example&lt;/h3&gt;
&lt;p&gt;From the &lt;code&gt;examples/helloworld&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile and execute the server code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ go run greeter_server/main.go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From a different terminal, compile and execute the client code to see the
client output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ go run greeter_client/main.go
Greeting: Hello world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;In this section you&amp;rsquo;ll update the application with an extra server method. The
gRPC service is defined using &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. To learn more about how to
define a service in a &lt;code&gt;.proto&lt;/code&gt; file see &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.
For now, all you need to know is that both the
server and the client stub have a &lt;code&gt;SayHello()&lt;/code&gt; RPC method that takes a
&lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a &lt;code&gt;HelloReply&lt;/code&gt; from the
server, and that the method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Open &lt;code&gt;helloworld/helloworld.proto&lt;/code&gt; and add a new &lt;code&gt;SayHelloAgain()&lt;/code&gt; method, with
the same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;regenerate-grpc-code&#34;&gt;Regenerate gRPC code&lt;/h3&gt;
&lt;p&gt;Before you can use the new service method, you need to recompile the updated
&lt;code&gt;.proto&lt;/code&gt; file.&lt;/p&gt;
&lt;p&gt;While still in the &lt;code&gt;examples/helloworld&lt;/code&gt; directory, run the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ protoc --go_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;. --go_opt&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;paths&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;source_relative &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;    --go-grpc_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;. --go-grpc_opt&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;paths&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;source_relative &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;    helloworld/helloworld.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will regenerate the &lt;code&gt;helloworld/helloworld.pb.go&lt;/code&gt; and  &lt;code&gt;helloworld/helloworld_grpc.pb.go&lt;/code&gt; files, which contain:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Code for populating, serializing, and retrieving &lt;code&gt;HelloRequest&lt;/code&gt; and
&lt;code&gt;HelloReply&lt;/code&gt; message types.&lt;/li&gt;
&lt;li&gt;Generated client and server code.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;update-and-run-the-application&#34;&gt;Update and run the application&lt;/h3&gt;
&lt;p&gt;You have regenerated server and client code, but you still need to implement
and call the new method in the human-written parts of the example application.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;Open &lt;code&gt;greeter_server/main.go&lt;/code&gt; and add the following function to it:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;server) &lt;span style=&#34;color:#c0f&#34;&gt;SayHelloAgain&lt;/span&gt;(ctx context.Context, in &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;pb.HelloRequest) (&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;pb.HelloReply, &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;error&lt;/span&gt;) {
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;pb.HelloReply{Message: &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello again &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; in.&lt;span style=&#34;color:#c0f&#34;&gt;GetName&lt;/span&gt;()}, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;Open &lt;code&gt;greeter_client/main.go&lt;/code&gt; to add the following code to the end of the
&lt;code&gt;main()&lt;/code&gt; function body:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;r, err = c.&lt;span style=&#34;color:#c0f&#34;&gt;SayHelloAgain&lt;/span&gt;(ctx, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;pb.HelloRequest{Name: name})
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
        log.&lt;span style=&#34;color:#c0f&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;could not greet: %v&amp;#34;&lt;/span&gt;, err)
}
log.&lt;span style=&#34;color:#c0f&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeting: %s&amp;#34;&lt;/span&gt;, r.&lt;span style=&#34;color:#c0f&#34;&gt;GetMessage&lt;/span&gt;())
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save your changes.&lt;/p&gt;
&lt;h4 id=&#34;run&#34;&gt;Run!&lt;/h4&gt;
&lt;p&gt;Run the client and server like you did before. Execute the following commands
from the &lt;code&gt;examples/helloworld&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ go run greeter_server/main.go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client. This time, add a name as a
command-line argument:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ go run greeter_client/main.go Alice
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You&amp;rsquo;ll see the following output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;Greeting: Hello Alice
Greeting: Hello again Alice
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/java/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/java/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://jdk.java.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JDK&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; version 7 or higher&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-java&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-java&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-java/archive/v1.38.0.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.38.0 https://github.com/grpc/grpc-java
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the examples directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-java/examples
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-the-example&#34;&gt;Run the example&lt;/h3&gt;
&lt;p&gt;From the &lt;code&gt;examples&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the client and server&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew installDist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./build/install/examples/bin/hello-world-server
INFO: Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./build/install/examples/bin/hello-world-client
INFO: Will try to greet world ...
INFO: Greeting: Hello world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    We&amp;rsquo;ve omitted timestamps from the client and server trace output shown in this
page.

&lt;/div&gt;

&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;In this section you&amp;rsquo;ll update the application by adding an extra server method.
The gRPC service is defined using &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. To learn more about
how to define a service in a &lt;code&gt;.proto&lt;/code&gt; file see &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;. For now, all
you need to know is that both the server and the client stub have a &lt;code&gt;SayHello()&lt;/code&gt;
RPC method that takes a &lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a
&lt;code&gt;HelloReply&lt;/code&gt; from the server, and that the method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Open &lt;code&gt;src/main/proto/helloworld.proto&lt;/code&gt; and add a new &lt;code&gt;SayHelloAgain()&lt;/code&gt; method
with the same request and response types as &lt;code&gt;SayHello()&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;update-the-app&#34;&gt;Update the app&lt;/h3&gt;
&lt;p&gt;When you build the example, the build process regenerates &lt;code&gt;GreeterGrpc.java&lt;/code&gt;,
which contains the generated gRPC client and server classes. This also
regenerates classes for populating, serializing, and retrieving our request and
response types.&lt;/p&gt;
&lt;p&gt;However, you still need to implement and call the new method in the
hand-written parts of the example app.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;In the same directory, open
&lt;code&gt;src/main/java/io/grpc/examples/helloworld/HelloWorldServer.java&lt;/code&gt;. Implement the
new method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;GreeterImpl&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;extends&lt;/span&gt; GreeterGrpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;GreeterImplBase&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;

  &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;sayHello&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;HelloRequest req&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;HelloReply&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; responseObserver&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    HelloReply reply &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; HelloReply&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; req&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getName&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;reply&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

  &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;sayHelloAgain&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;HelloRequest req&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;HelloReply&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; responseObserver&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    HelloReply reply &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; HelloReply&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello again &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; req&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getName&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;reply&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;In the same directory, open
&lt;code&gt;src/main/java/io/grpc/examples/helloworld/HelloWorldClient.java&lt;/code&gt;. Call the new
method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;greet&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;String name&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;info&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Will try to greet &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34; ...&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
  HelloRequest request &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; HelloRequest&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setName&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;name&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
  HelloReply response&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    response &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; blockingStub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;sayHello&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;StatusRuntimeException e&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Level&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;WARNING&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;RPC failed: {0}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; e&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getStatus&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;info&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeting: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; response&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    response &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; blockingStub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;sayHelloAgain&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;StatusRuntimeException e&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Level&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;WARNING&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;RPC failed: {0}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; e&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getStatus&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;info&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeting: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; response&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;run-the-updated-app&#34;&gt;Run the updated app&lt;/h3&gt;
&lt;p&gt;Run the client and server like you did before. Execute the following commands
from the &lt;code&gt;examples&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the client and server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew installDist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./build/install/examples/bin/hello-world-server
INFO: Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./build/install/examples/bin/hello-world-client
INFO: Will try to greet world ...
INFO: Greeting: Hello world
INFO: Greeting: Hello again world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/kotlin/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/kotlin/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kotlinlang.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kotlin&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; version 1.3 or higher&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://jdk.java.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JDK&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; version 7 or higher&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-kotlin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-kotlin&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/archive/master.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone https://github.com/grpc/grpc-kotlin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the examples directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-kotlin/examples
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-the-example&#34;&gt;Run the example&lt;/h3&gt;
&lt;p&gt;From the &lt;code&gt;examples&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the client and server&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew installDist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./server/build/install/server/bin/hello-world-server
Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./client/build/install/client/bin/hello-world-client
Received: Hello world
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server app with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;In this section, you&amp;rsquo;ll update the app with an extra server method. The app&amp;rsquo;s
gRPC service, named &lt;code&gt;Greeter&lt;/code&gt;, is defined using &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. To learn
more about how to define a service in a &lt;code&gt;.proto&lt;/code&gt; file, see &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.
For now, all you need to know is that both the server and the client stub have a
&lt;code&gt;SayHello()&lt;/code&gt; RPC method that takes a &lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client
and returns a &lt;code&gt;HelloReply&lt;/code&gt; from the server, and that the method is defined like
this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Open &lt;code&gt;helloworld/hello_world.proto&lt;/code&gt; from the
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/protos/src/main/proto/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protos/src/main/proto/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder, and add a
new &lt;code&gt;SayHelloAgain()&lt;/code&gt; method, with the same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;update-the-app&#34;&gt;Update the app&lt;/h3&gt;
&lt;p&gt;When you build the example, the build process regenerates &lt;code&gt;HelloWorldGrpcKt.kt&lt;/code&gt;,
which contains the generated gRPC client and server classes. This also
regenerates classes for populating, serializing, and retrieving our request and
response types.&lt;/p&gt;
&lt;p&gt;However, you still need to implement and call the new method in the
hand-written parts of the example app.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;Open &lt;code&gt;helloworld/HelloWorldServer.kt&lt;/code&gt; from the
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/server/src/main/kotlin/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;server/src/main/kotlin/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder. Implement the new
method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloWorldService&lt;/span&gt; : GreeterGrpcKt.GreeterCoroutineImplBase() {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;sayHello&lt;/span&gt;(request: HelloRequest) = HelloReply
      .newBuilder()
      .setMessage(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${request.name}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
      .build()

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;sayHelloAgain&lt;/span&gt;(request: HelloRequest) = HelloReply
      .newBuilder()
      .setMessage(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello again &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${request.name}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
      .build()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;Open &lt;code&gt;helloworld/HelloWorldClient.kt&lt;/code&gt; from the
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/client/src/main/kotlin/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;client/src/main/kotlin/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder. Call the new
method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloWorldClient&lt;/span&gt;(
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; channel: ManagedChannel
) : Closeable {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; stub: GreeterCoroutineStub = GreeterCoroutineStub(channel)

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;greet&lt;/span&gt;(name: String) {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; request = HelloRequest.newBuilder().setName(name).build()
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; response = stub.sayHello(request)
    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Received: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${response.message}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; againResponse = stub.sayHelloAgain(request)
    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Received: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${againResponse.message}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
  }

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;close&lt;/span&gt;() {
    channel.shutdown().awaitTermination(&lt;span style=&#34;color:#f60&#34;&gt;5&lt;/span&gt;, TimeUnit.SECONDS)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;run-the-updated-app&#34;&gt;Run the updated app&lt;/h3&gt;
&lt;p&gt;Run the client and server like you did before. Execute the following commands
from the &lt;code&gt;examples&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the client and server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew installDist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./server/build/install/server/bin/hello-world-server
Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client. This time, add a name as a
command-line argument:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./client/build/install/client/bin/hello-world-client Alice
Received: Hello Alice
Received: Hello again Alice
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/node/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/node/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Node version 8.13.0 or higher&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;download-the-example&#34;&gt;Download the example&lt;/h3&gt;
&lt;p&gt;You&amp;rsquo;ll need a local copy of the example code to work through this quick start.
Download the example code from our GitHub repository (the following command
clones the entire repository, but you just need the examples for this quick start
and other tutorials):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# Clone the repository to get the example code&lt;/span&gt;
$ git clone -b v1.37.1 https://github.com/grpc/grpc
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# Navigate to the node example&lt;/span&gt;
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc/examples/node
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# Install the example&amp;#39;s dependencies&lt;/span&gt;
$ npm install
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# Navigate to the dynamic codegen &amp;#34;hello, world&amp;#34; Node example:&lt;/span&gt;
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; dynamic_codegen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;run-a-grpc-application&#34;&gt;Run a gRPC application&lt;/h3&gt;
&lt;p&gt;From the &lt;code&gt;examples/node/dynamic_codegen&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ node greeter_server.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ node greeter_client.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how to update the application with an extra method on the
server for the client to call. Our gRPC service is defined using protocol
buffers; you can find out lots more about how to define a service in a &lt;code&gt;.proto&lt;/code&gt;
file in &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;. For now all you need
to know is that both the server and the client &amp;ldquo;stub&amp;rdquo; have a &lt;code&gt;SayHello&lt;/code&gt; RPC
method that takes a &lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a
&lt;code&gt;HelloReply&lt;/code&gt; from the server, and that this method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s update this so that the &lt;code&gt;Greeter&lt;/code&gt; service has two methods. Edit
&lt;code&gt;examples/protos/helloworld.proto&lt;/code&gt; and update it with a new &lt;code&gt;SayHelloAgain&lt;/code&gt;
method, with the same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;update-and-run-the-application&#34;&gt;Update and run the application&lt;/h3&gt;
&lt;p&gt;We now have a new service definition, but we still need to implement and call
the new method in the human-written parts of our example application.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;In the same directory, open &lt;code&gt;greeter_server.js&lt;/code&gt;. Implement the new method like
this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; sayHello(call, callback) {
  callback(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;, {message&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Hello &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; call.request.name});
}

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; sayHelloAgain(call, callback) {
  callback(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;, {message&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Hello again, &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; call.request.name});
}

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; main() {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; server &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; grpc.Server();
  server.addService(hello_proto.Greeter.service,
                         {sayHello&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; sayHello, sayHelloAgain&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; sayHelloAgain});
  server.bindAsync(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;0.0.0.0:50051&amp;#39;&lt;/span&gt;, grpc.ServerCredentials.createInsecure(), () =&amp;gt; {
    server.start();
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;In the same directory, open &lt;code&gt;greeter_client.js&lt;/code&gt;. Call the new method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; main() {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; client &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; hello_proto.Greeter(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;localhost:50051&amp;#39;&lt;/span&gt;,
                                       grpc.credentials.createInsecure());
  client.sayHello({name&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;you&amp;#39;&lt;/span&gt;}, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(err, response) {
    console.log(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Greeting:&amp;#39;&lt;/span&gt;, response.message);
  });
  client.sayHelloAgain({name&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;you&amp;#39;&lt;/span&gt;}, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(err, response) {
    console.log(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Greeting:&amp;#39;&lt;/span&gt;, response.message);
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;run&#34;&gt;Run!&lt;/h4&gt;
&lt;p&gt;Just like we did before, from the &lt;code&gt;examples/node/dynamic_codegen&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ node greeter_server.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ node greeter_client.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;We have more than one grpc implementation for Node. For the pros and cons of
each package, see this &lt;a href=&#34;https://github.com/grpc/grpc-node/blob/master/PACKAGE-COMPARISON.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;package feature comparison&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/objective-c/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/objective-c/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;before-you-begin&#34;&gt;Before you begin&lt;/h3&gt;
&lt;h4 id=&#34;system-requirements&#34;&gt;System requirements&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;macOS version 10.11 (El Capitan) or higher&lt;/li&gt;
&lt;li&gt;iOS version 7.0 or higher&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CocoaPods version 1.0 or higher&lt;/p&gt;
&lt;p&gt;Check the status and version of CocoaPods on your system:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ pod --version
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If CocoaPods is not installed, follow the &lt;a href=&#34;https://cocoapods.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CocoaPods install
instructions&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Xcode version 7.2 or higher&lt;/p&gt;
&lt;p&gt;Check your Xcode version by running Xcode from Lauchpad, then select
&lt;strong&gt;Xcode &amp;gt; About Xcode&lt;/strong&gt; in the menu.&lt;/p&gt;
&lt;p&gt;Make sure the command line developer tools are installed:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ xcode-select --install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://brew.sh/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Homebrew&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;autoconf&lt;/code&gt;, &lt;code&gt;automake&lt;/code&gt;, &lt;code&gt;libtool&lt;/code&gt;, &lt;code&gt;pkg-config&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ brew install autoconf automake libtool pkg-config
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;download-the-example&#34;&gt;Download the example&lt;/h3&gt;
&lt;p&gt;You&amp;rsquo;ll need a local copy of the sample app source code to work through this
Quickstart. Copy the source code from GitHub
&lt;a href=&#34;https://github.com/grpc/grpc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;repository&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone --recursive -b v1.37.1 https://github.com/grpc/grpc.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;install-grpc-plugins-and-libraries&#34;&gt;Install gRPC plugins and libraries&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc
$ make
$ &lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;sudo&lt;span style=&#34;color:#555&#34;&gt;]&lt;/span&gt; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;install-protoc-compiler&#34;&gt;Install protoc compiler&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ brew tap grpc/grpc
$ brew install protobuf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;run-the-server&#34;&gt;Run the server:&lt;/h3&gt;
&lt;p&gt;For this sample app, we need a gRPC server running on the local machine. gRPC
Objective-C API supports creating gRPC clients but not gRPC servers. Therefore
instead we build and run the C++ server in the same repository:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; examples/cpp/helloworld
$ make
$ ./greeter_server &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;run-the-client&#34;&gt;Run the client:&lt;/h3&gt;
&lt;h4 id=&#34;generate-client-libraries-and-dependencies&#34;&gt;Generate client libraries and dependencies&lt;/h4&gt;
&lt;p&gt;Have CocoaPods generate and install the client library from our .proto files, as
well as installing several dependencies:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; ../../objective-c/helloworld
$ pod install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(This might have to compile OpenSSL, which takes around 15 minutes if Cocoapods
doesn&amp;rsquo;t have it yet on your computer&amp;rsquo;s cache.)&lt;/p&gt;
&lt;h4 id=&#34;run-the-client-app&#34;&gt;Run the client app&lt;/h4&gt;
&lt;p&gt;Open the Xcode workspace created by CocoaPods:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ open HelloWorld.xcworkspace
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This will open the app project with Xcode. Run the app in an iOS simulator
by pressing the Run button on the top left corner of Xcode window. You can check
the calling code in &lt;code&gt;main.m&lt;/code&gt; and see the results in Xcode&amp;rsquo;s console.&lt;/p&gt;
&lt;p&gt;The code sends a &lt;code&gt;HLWHelloRequest&lt;/code&gt; containing the string &amp;ldquo;Objective-C&amp;rdquo; to a
local server. The server responds with a &lt;code&gt;HLWHelloResponse&lt;/code&gt;, which contains a
string &amp;ldquo;Hello Objective-C&amp;rdquo; that is then output to the console.&lt;/p&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how to update the application with an extra method on the
server for the client to call. Our gRPC service is defined using Protocol
Buffers; you can find out lots more about how to define a service in a &lt;code&gt;.proto&lt;/code&gt;
file in Protocol Buffers
&lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;website&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. For now all you
need to know is that both the server and the client &amp;ldquo;stub&amp;rdquo; have a &lt;code&gt;SayHello&lt;/code&gt;
RPC method that takes a &lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a
&lt;code&gt;HelloResponse&lt;/code&gt; from the server, and that this method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s update this so that the &lt;code&gt;Greeter&lt;/code&gt; service has two methods. Edit
&lt;code&gt;examples/protos/helloworld.proto&lt;/code&gt; and update it with a new &lt;code&gt;SayHelloAgain&lt;/code&gt;
method, with the same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;update-the-client-and-server&#34;&gt;Update the client and server&lt;/h3&gt;
&lt;p&gt;We now have a new gRPC service definition, but we still need to implement and
call the new method in the human-written parts of our example application.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;As you remember, gRPC doesn&amp;rsquo;t provide a server API for Objective-C. Instead, we
need to update the C++ sample server. Open
&lt;code&gt;examples/cpp/helloworld/greeter_server.cc&lt;/code&gt;. Implement the new method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;GreeterServiceImpl&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; Greeter&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;Service {
  Status &lt;span style=&#34;color:#c0f&#34;&gt;SayHello&lt;/span&gt;(ServerContext&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; context, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; HelloRequest&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; request,
                  HelloReply&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; reply) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; {
    std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string prefix(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello &amp;#34;&lt;/span&gt;);
    reply&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;set_message(prefix &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;name());
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; Status&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;OK;
  }
  Status &lt;span style=&#34;color:#c0f&#34;&gt;SayHelloAgain&lt;/span&gt;(ServerContext&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; context, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; HelloRequest&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; request,
                  HelloReply&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; reply) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; {
    std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string prefix(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello again &amp;#34;&lt;/span&gt;);
    reply&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;set_message(prefix &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;name());
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; Status&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;OK;
  }
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;Edit the main function in &lt;code&gt;examples/objective-c/helloworld/main.m&lt;/code&gt; to call the new method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;main&lt;/span&gt;(&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; argc, &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;char&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; argv[]) {
  &lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;@&lt;/span&gt;autoreleasepool {
    HLWGreeter &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;client &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [[HLWGreeter alloc] &lt;span style=&#34;color:#99f&#34;&gt;initWithHost&lt;/span&gt;:kHostAddress];

    HLWHelloRequest &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;request &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [HLWHelloRequest message];
    request.name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;@&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Objective-C&amp;#34;&lt;/span&gt;;

    GRPCMutableCallOptions &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;options &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [[GRPCMutableCallOptions alloc] init];
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// this example does not use TLS (secure channel); use insecure channel instead
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    options.transport &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; GRPCDefaultTransportImplList.core_insecure;
    options.userAgentPrefix &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;@&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;HelloWorld/1.0&amp;#34;&lt;/span&gt;;

    [[client &lt;span style=&#34;color:#99f&#34;&gt;sayHelloWithMessage&lt;/span&gt;:request
                 &lt;span style=&#34;color:#99f&#34;&gt;responseHandler&lt;/span&gt;:[[HLWResponseHandler alloc] init]
                     &lt;span style=&#34;color:#99f&#34;&gt;callOptions&lt;/span&gt;:options] start];
    [[client &lt;span style=&#34;color:#99f&#34;&gt;sayHelloAgainWithMessage&lt;/span&gt;:request
                      &lt;span style=&#34;color:#99f&#34;&gt;responseHandler&lt;/span&gt;:[[HLWResponseHandler alloc] init]
                          &lt;span style=&#34;color:#99f&#34;&gt;callOptions&lt;/span&gt;:options] start];

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;build-and-run&#34;&gt;Build and run&lt;/h3&gt;
&lt;p&gt;First terminate the server process already running in the background:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ pkill greeter_server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then in directory &lt;code&gt;examples/cpp/helloworld&lt;/code&gt;, build and run the updated server
with the following commands:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ make
$ ./greeter_server &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Change directory to &lt;code&gt;examples/objective-c/helloworld&lt;/code&gt;, then clean up and
reinstall Pods for the client app with the following commands:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ rm -Rf Pods
$ rm Podfile.lock
$ rm -Rf HelloWorld.xcworkspace
$ pod install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This regenerates files in &lt;code&gt;Pods/HelloWorld&lt;/code&gt; based on the new proto file we wrote
above. Open the client Xcode project in Xcode:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ open HelloWorld.xcworkspace
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;and run the client app. If you look at the console messages, You&amp;rsquo;ll see two RPC calls,
one to SayHello and one to SayHelloAgain.&lt;/p&gt;
&lt;h3 id=&#34;troubleshooting&#34;&gt;Troubleshooting&lt;/h3&gt;
&lt;dl&gt;
&lt;dt&gt;When installing CocoaPods, error &lt;code&gt;activesupport requires Ruby version &amp;gt;= 2.2.2&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Install an older version of &lt;code&gt;activesupport&lt;/code&gt;, then install CocoaPods:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;sudo&lt;span style=&#34;color:#555&#34;&gt;]&lt;/span&gt; gem install activesupport -v 4.2.6
$ &lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;sudo&lt;span style=&#34;color:#555&#34;&gt;]&lt;/span&gt; gem install cocoapods
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/dd&gt;
&lt;dt&gt;When installing dependencies with CocoaPods, error &lt;code&gt;Unable to find a specification for !ProtoCompiler-gRPCPlugin&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Update the local clone of spec repo by running &lt;code&gt;pod repo update&lt;/code&gt;&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;Compiler error when compiling &lt;code&gt;objective_c_plugin.cc&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Removing &lt;code&gt;protobuf&lt;/code&gt; package with Homebrew before building gRPC may solve this
problem. We are working on a more elegant fix.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;When building HellowWorld, error &lt;code&gt;ld: unknown option: --no-as-needed&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;This problem is due to linker &lt;code&gt;ld&lt;/code&gt; in Apple LLVM not supporting the
&lt;code&gt;--no-as-needed&lt;/code&gt; option. We are working on a fix right now and will merge the
fix very soon.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;When building grpc, error &lt;code&gt;cannot find install-sh install.sh or shtool&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Remove the gRPC directory, clone a new one and try again. It is likely that
some auto generated files are corrupt; remove and rebuild may solve the
problem.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;When building grpc, error &lt;code&gt;Can&#39;t exec &amp;quot;aclocal&amp;quot;&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;The package &lt;code&gt;automake&lt;/code&gt; is missing. Install &lt;code&gt;automake&lt;/code&gt; should solve this problem.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;When building grpc, error &lt;code&gt;possibly undefined macro: AC_PROG_LIBTOOL&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;The package &lt;code&gt;libtool&lt;/code&gt; is missing. Install &lt;code&gt;libtool&lt;/code&gt; should solve this problem.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;When building grpc, error &lt;code&gt;cannot find install-sh, install.sh, or shtool&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Some of the auto generated files are corrupt. Remove the entire gRPC
directory, clone from GitHub, and build again.&lt;/p&gt;
&lt;/dd&gt;
&lt;dt&gt;Cannot find &lt;code&gt;protoc&lt;/code&gt; when building HelloWorld&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Run &lt;code&gt;brew install protobuf&lt;/code&gt; to get the &lt;code&gt;protoc&lt;/code&gt; compiler.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/php/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/php/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;PHP 7.0 or higher, PECL, Composer&lt;/li&gt;
&lt;li&gt;grpc extension, protocol buffers compiler: for installation instructions, see
the &lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/src/php/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;gRPC PHP readme&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    You can only create gRPC clients in PHP. Use &lt;a href=&#34;https://Joevaen.github.io/docs/languages/&#34;&gt;another
language&lt;/a&gt; to create a gRPC server.

&lt;/div&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Clone the &lt;a href=&#34;https://github.com/grpc/grpc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo and its submodules:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone --recurse-submodules -b v1.37.1 https://github.com/grpc/grpc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the quick start example directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc/examples/php
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Install the &lt;code&gt;grpc&lt;/code&gt; composer package:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./greeter_proto_gen.sh
$ composer install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-the-example&#34;&gt;Run the example&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Launch the a quick start server: for example, follow the instructions given
in the &lt;a href=&#34;https://Joevaen.github.io/docs/languages/node/quickstart/&#34;&gt;Quick start for Node&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From the &lt;code&gt;examples/php&lt;/code&gt; directory, run the PHP client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./run_greeter_client.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how to update the application with an extra method on the
server for the client to call. Our gRPC service is defined using protocol
buffers; you can find out lots more about how to define a service in a &lt;code&gt;.proto&lt;/code&gt;
file in &lt;a href=&#34;https://Joevaen.github.io/docs/languages/php/basics/&#34;&gt;Basics tutorial&lt;/a&gt;. For now all you need to know is that both the
server and the client &amp;ldquo;stub&amp;rdquo; have a &lt;code&gt;SayHello&lt;/code&gt; RPC method that takes a
&lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a &lt;code&gt;HelloResponse&lt;/code&gt; from
the server, and that this method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s update this so that the &lt;code&gt;Greeter&lt;/code&gt; service has two methods. Edit
&lt;code&gt;examples/protos/helloworld.proto&lt;/code&gt; and update it with a new &lt;code&gt;SayHelloAgain&lt;/code&gt;
method, with the same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;regenerate-grpc-code&#34;&gt;Regenerate gRPC code&lt;/h3&gt;
&lt;p&gt;Next we need to update the gRPC code used by our application to use the new
service definition. From the &lt;code&gt;grpc&lt;/code&gt; root directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ protoc --proto_path&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;examples/protos &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;  --php_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;examples/php &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;  --grpc_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;examples/php &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;  --plugin&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;protoc-gen-grpc&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;bins/opt/grpc_php_plugin &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;  ./examples/protos/helloworld.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;or running the helper script under the &lt;code&gt;grpc/example/php&lt;/code&gt; directory if you build
grpc-php-plugin by source:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./greeter_proto_gen.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This regenerates the protobuf files, which contain our generated client classes,
as well as classes for populating, serializing, and retrieving our request and
response types.&lt;/p&gt;
&lt;h3 id=&#34;update-and-run-the-application&#34;&gt;Update and run the application&lt;/h3&gt;
&lt;p&gt;We now have new generated client code, but we still need to implement and call
the new method in the human-written parts of our example application.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;In the same directory, open &lt;code&gt;greeter_server.js&lt;/code&gt;. Implement the new method like
this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; sayHello(call, callback) {
  callback(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;, {message&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Hello &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; call.request.name});
}

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; sayHelloAgain(call, callback) {
  callback(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;, {message&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Hello again, &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; call.request.name});
}

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; main() {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; server &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; grpc.Server();
  server.addProtoService(hello_proto.Greeter.service,
                         {sayHello&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; sayHello, sayHelloAgain&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; sayHelloAgain});
  server.bind(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;0.0.0.0:50051&amp;#39;&lt;/span&gt;, grpc.ServerCredentials.createInsecure());
  server.start();
}
...
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;In the same directory, open &lt;code&gt;greeter_client.php&lt;/code&gt;. Call the new method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#033&#34;&gt;$request&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Helloworld\HelloRequest();
&lt;span style=&#34;color:#033&#34;&gt;$request&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setName&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$name&lt;/span&gt;);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;list&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$reply&lt;/span&gt;, &lt;span style=&#34;color:#033&#34;&gt;$status&lt;/span&gt;) &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$client&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;SayHello&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$request&lt;/span&gt;)&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;wait&lt;/span&gt;();
&lt;span style=&#34;color:#033&#34;&gt;$message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$reply&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;();
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;list&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$reply&lt;/span&gt;, &lt;span style=&#34;color:#033&#34;&gt;$status&lt;/span&gt;) &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$client&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;SayHelloAgain&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$request&lt;/span&gt;)&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;wait&lt;/span&gt;();
&lt;span style=&#34;color:#033&#34;&gt;$message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$reply&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;run&#34;&gt;Run!&lt;/h4&gt;
&lt;p&gt;Just like we did before, from the &lt;code&gt;examples/node/dynamic_codegen&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ node greeter_server.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, from the &lt;code&gt;examples/php&lt;/code&gt; directory,
run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./run_greeter_client.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;https://Joevaen.github.io/docs/languages/php/basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/python/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/python/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Python 3.5 or higher&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pip&lt;/code&gt; version 9.0.1 or higher&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If necessary, upgrade your version of &lt;code&gt;pip&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python -m pip install --upgrade pip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;If you cannot upgrade &lt;code&gt;pip&lt;/code&gt; due to a system-owned installation, you can
run the example in a virtualenv:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python -m pip install virtualenv
$ virtualenv venv
$ &lt;span style=&#34;color:#366&#34;&gt;source&lt;/span&gt; venv/bin/activate
$ python -m pip install --upgrade pip
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;grpc&#34;&gt;gRPC&lt;/h4&gt;
&lt;p&gt;Install gRPC:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python -m pip install grpcio
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Or, to install it system wide:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ sudo python -m pip install grpcio
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;grpc-tools&#34;&gt;gRPC tools&lt;/h4&gt;
&lt;p&gt;Python&amp;rsquo;s gRPC tools include the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; and the
special plugin for generating server and client code from &lt;code&gt;.proto&lt;/code&gt; service
definitions. For the first part of our quick-start example, we&amp;rsquo;ve already
generated the server and client stubs from
&lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/protos/helloworld.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;helloworld.proto&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;,
but you&amp;rsquo;ll need the tools for the rest of our quick start, as well as later
tutorials and your own projects.&lt;/p&gt;
&lt;p&gt;To install gRPC tools, run:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python -m pip install grpcio-tools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;download-the-example&#34;&gt;Download the example&lt;/h3&gt;
&lt;p&gt;You&amp;rsquo;ll need a local copy of the example code to work through this quick start.
Download the example code from our GitHub repository (the following command
clones the entire repository, but you just need the examples for this quick start
and other tutorials):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# Clone the repository to get the example code:&lt;/span&gt;
$ git clone -b v1.37.1 https://github.com/grpc/grpc
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# Navigate to the &amp;#34;hello, world&amp;#34; Python example:&lt;/span&gt;
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc/examples/python/helloworld
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;run-a-grpc-application&#34;&gt;Run a gRPC application&lt;/h3&gt;
&lt;p&gt;From the &lt;code&gt;examples/python/helloworld&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python greeter_server.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python greeter_client.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how to update the application with an extra method on the
server for the client to call. Our gRPC service is defined using protocol
buffers; you can find out lots more about how to define a service in a &lt;code&gt;.proto&lt;/code&gt;
file in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;. For now all you need
to know is that both the server and the client &amp;ldquo;stub&amp;rdquo; have a &lt;code&gt;SayHello&lt;/code&gt; RPC
method that takes a &lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a
&lt;code&gt;HelloReply&lt;/code&gt; from the server, and that this method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s update this so that the &lt;code&gt;Greeter&lt;/code&gt; service has two methods. Edit
&lt;code&gt;examples/protos/helloworld.proto&lt;/code&gt; and update it with a new &lt;code&gt;SayHelloAgain&lt;/code&gt;
method, with the same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;generate-grpc-code&#34;&gt;Generate gRPC code&lt;/h3&gt;
&lt;p&gt;Next we need to update the gRPC code used by our application to use the new
service definition.&lt;/p&gt;
&lt;p&gt;From the &lt;code&gt;examples/python/helloworld&lt;/code&gt; directory, run:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python -m grpc_tools.protoc -I../../protos --python_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;. --grpc_python_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;. ../../protos/helloworld.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This regenerates &lt;code&gt;helloworld_pb2.py&lt;/code&gt; which contains our generated request and
response classes and &lt;code&gt;helloworld_pb2_grpc.py&lt;/code&gt; which contains our generated
client and server classes.&lt;/p&gt;
&lt;h3 id=&#34;update-and-run-the-application&#34;&gt;Update and run the application&lt;/h3&gt;
&lt;p&gt;We now have new generated server and client code, but we still need to implement
and call the new method in the human-written parts of our example application.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;In the same directory, open &lt;code&gt;greeter_server.py&lt;/code&gt;. Implement the new method like
this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Greeter&lt;/span&gt;(helloworld_pb2_grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;GreeterServicer):

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;SayHello&lt;/span&gt;(self, request, context):
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; helloworld_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;HelloReply(message&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Hello, &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;!&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;%&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;name)

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;SayHelloAgain&lt;/span&gt;(self, request, context):
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; helloworld_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;HelloReply(message&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Hello again, &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;%s&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;!&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;%&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;name)
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;In the same directory, open &lt;code&gt;greeter_client.py&lt;/code&gt;. Call the new method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-py&#34; data-lang=&#34;py&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;run&lt;/span&gt;():
  channel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;insecure_channel(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;localhost:50051&amp;#39;&lt;/span&gt;)
  stub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; helloworld_pb2_grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;GreeterStub(channel)
  response &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SayHello(helloworld_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;HelloRequest(name&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;you&amp;#39;&lt;/span&gt;))
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeter client received: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; response&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;message)
  response &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SayHelloAgain(helloworld_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;HelloRequest(name&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;you&amp;#39;&lt;/span&gt;))
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;print&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeter client received: &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; response&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;message)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;run&#34;&gt;Run!&lt;/h4&gt;
&lt;p&gt;Just like we did before, from the &lt;code&gt;examples/python/helloworld&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python greeter_server.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python greeter_client.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/languages/ruby/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/ruby/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Ruby version 2 or higher&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;grpc&#34;&gt;gRPC&lt;/h4&gt;
&lt;p&gt;To install gRPC, run the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ gem install grpc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;grpc-tools&#34;&gt;gRPC tools&lt;/h4&gt;
&lt;p&gt;Ruby&amp;rsquo;s gRPC tools include the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; and the special
plugin for generating server and client code from the &lt;code&gt;.proto&lt;/code&gt; service
definitions. For the first part of our quick-start example, we&amp;rsquo;ve already
generated the server and client stubs from
&lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/protos/helloworld.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;helloworld.proto&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;,
but you&amp;rsquo;ll need the tools for the rest of our quick start, as well as later
tutorials and your own projects.&lt;/p&gt;
&lt;p&gt;To install gRPC tools, run the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ gem install grpc-tools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;download-the-example&#34;&gt;Download the example&lt;/h3&gt;
&lt;p&gt;You&amp;rsquo;ll need a local copy of the example code to work through this quick start.
Download the example code from our GitHub repository (the following command
clones the entire repository, but you just need the examples for this quick start
and other tutorials):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# Clone the repository to get the example code:&lt;/span&gt;
$ git clone -b v1.37.1 https://github.com/grpc/grpc
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# Navigate to the &amp;#34;hello, world&amp;#34; Ruby example:&lt;/span&gt;
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc/examples/ruby
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;run-a-grpc-application&#34;&gt;Run a gRPC application&lt;/h3&gt;
&lt;p&gt;From the &lt;code&gt;examples/ruby&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ruby greeter_server.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ruby greeter_client.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how to update the application with an extra method on the
server for the client to call. Our gRPC service is defined using protocol
buffers; you can find out lots more about how to define a service in a &lt;code&gt;.proto&lt;/code&gt;
file in &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;. For now all you need
to know is that both the server and the client &amp;ldquo;stub&amp;rdquo; have a &lt;code&gt;SayHello&lt;/code&gt; RPC
method that takes a &lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a
&lt;code&gt;HelloResponse&lt;/code&gt; from the server, and that this method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Let&amp;rsquo;s update this so that the &lt;code&gt;Greeter&lt;/code&gt; service has two methods. Edit
&lt;code&gt;examples/protos/helloworld.proto&lt;/code&gt; and update it with a new &lt;code&gt;SayHelloAgain&lt;/code&gt;
method, with the same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;generate-grpc-code&#34;&gt;Generate gRPC code&lt;/h3&gt;
&lt;p&gt;Next we need to update the gRPC code used by our application to use the new
service definition. From the &lt;code&gt;examples/ruby/&lt;/code&gt; directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ grpc_tools_ruby_protoc -I ../protos --ruby_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;lib --grpc_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;lib ../protos/helloworld.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This regenerates &lt;code&gt;lib/helloworld_services_pb.rb&lt;/code&gt;, which contains our generated
client and server classes.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;In the same directory, open &lt;code&gt;greeter_server.rb&lt;/code&gt;. Implement the new method like this&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rb&#34; data-lang=&#34;rb&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;GreeterServer&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#360&#34;&gt;Helloworld&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;Greeter&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;Service&lt;/span&gt;

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;say_hello&lt;/span&gt;(hello_req, _unused_call)
    &lt;span style=&#34;color:#360&#34;&gt;Helloworld&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;HelloReply&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(&lt;span style=&#34;color:#fc3&#34;&gt;message&lt;/span&gt;: &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;#{&lt;/span&gt;hello_req&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;name&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;end&lt;/span&gt;

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;say_hello_again&lt;/span&gt;(hello_req, _unused_call)
    &lt;span style=&#34;color:#360&#34;&gt;Helloworld&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;HelloReply&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(&lt;span style=&#34;color:#fc3&#34;&gt;message&lt;/span&gt;: &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello again, &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;#{&lt;/span&gt;hello_req&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;name&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;In the same directory, open &lt;code&gt;greeter_client.rb&lt;/code&gt;. Call the new method like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-rb&#34; data-lang=&#34;rb&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;main&lt;/span&gt;
  stub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#360&#34;&gt;Helloworld&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;Greeter&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;Stub&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;localhost:50051&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#fc3&#34;&gt;:this_channel_is_insecure&lt;/span&gt;)
  user &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#360&#34;&gt;ARGV&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;size &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;?&lt;/span&gt;  &lt;span style=&#34;color:#360&#34;&gt;ARGV&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;]&lt;/span&gt; : &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;world&amp;#39;&lt;/span&gt;
  message &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;say_hello(&lt;span style=&#34;color:#360&#34;&gt;Helloworld&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;HelloRequest&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(&lt;span style=&#34;color:#366&#34;&gt;name&lt;/span&gt;: user))&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;message
  &lt;span style=&#34;color:#366&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeting: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;#{&lt;/span&gt;message&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
  message &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;say_hello_again(&lt;span style=&#34;color:#360&#34;&gt;Helloworld&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;HelloRequest&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(&lt;span style=&#34;color:#366&#34;&gt;name&lt;/span&gt;: user))&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;message
  &lt;span style=&#34;color:#366&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Greeting: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;#{&lt;/span&gt;message&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;run&#34;&gt;Run!&lt;/h4&gt;
&lt;p&gt;Just like we did before, from the &lt;code&gt;examples/ruby&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ruby greeter_server.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ruby greeter_client.rb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/platforms/android/java/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/platforms/android/java/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jdk.java.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JDK&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; version 7 or higher&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Android SDK, API level 16 or higher&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Install &lt;a href=&#34;https://developer.android.com/studio/index.html#downloads&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Android Studio&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; or the Android &lt;a href=&#34;https://developer.android.com/studio/index.html#command-tools&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;command-line tools&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Let other tools and scripts know where to find your Android SDK by setting
the following environment variable:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;ANDROID_SDK_ROOT&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&amp;lt;path-to-your-android-sdk&amp;gt;&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An android device set up for &lt;a href=&#34;https://developer.android.com/studio/command-line/adb.html#Enabling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;USB debugging&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; or an
&lt;a href=&#34;https://developer.android.com/studio/run/managing-avds.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Android Virtual Device&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    gRPC Java does not support running a server on an Android device. For this
quick start, the Android client app will connect to a server running on your
local (non-Android) computer.

&lt;/div&gt;

&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-java&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-java&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-java/archive/v1.38.0.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.38.0 https://github.com/grpc/grpc-java
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the examples directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-java/examples
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-the-example&#34;&gt;Run the example&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew installDist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./build/install/examples/bin/hello-world-server
INFO: Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, build the client and install it on your device:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; android/helloworld; ../../gradlew installDebug&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Launch the client app from your device.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the client app, enter the server&amp;rsquo;s &lt;strong&gt;Host&lt;/strong&gt; and &lt;strong&gt;Port&lt;/strong&gt; information. The
values you enter depend on the device kind (real or virtual) — for
details, see &lt;a href=&#34;#connecting-to-the-server&#34;&gt;Connecting to the server&lt;/a&gt; below.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Type &amp;ldquo;Alice&amp;rdquo; in the &lt;strong&gt;Message&lt;/strong&gt; box and click &lt;strong&gt;Send&lt;/strong&gt;. You&amp;rsquo;ll see the
following response:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nocode&#34; data-lang=&#34;nocode&#34;&gt;Hello Alice
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    We&amp;rsquo;ve omitted timestamps from the client and server trace output shown in this
page.

&lt;/div&gt;

&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;In this section you&amp;rsquo;ll update the application by adding an extra server method.
The gRPC service is defined using &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. To learn more about
how to define a service in a &lt;code&gt;.proto&lt;/code&gt; file see &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;. For now, all
you need to know is that both the server and the client stub have a &lt;code&gt;SayHello()&lt;/code&gt;
RPC method that takes a &lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a
&lt;code&gt;HelloReply&lt;/code&gt; from the server, and that the method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Make the following changes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Open &lt;code&gt;src/main/proto/helloworld.proto&lt;/code&gt; and add a new &lt;code&gt;SayHelloAgain()&lt;/code&gt;
method with the same request and response types as &lt;code&gt;SayHello()&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Make the same change to
&lt;code&gt;android/helloworld/app/src/main/proto/helloworld.proto&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Remember to save the files!&lt;/p&gt;
&lt;h3 id=&#34;update-the-app&#34;&gt;Update the app&lt;/h3&gt;
&lt;p&gt;When you build the example, the build process regenerates &lt;code&gt;GreeterGrpc.java&lt;/code&gt;,
which contains the generated gRPC client and server classes. This also
regenerates classes for populating, serializing, and retrieving our request and
response types.&lt;/p&gt;
&lt;p&gt;However, you still need to implement and call the new method in the
hand-written parts of the example app.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;Follow the instructions given in &lt;a href=&#34;https://Joevaen.github.io/docs/languages/java/quickstart/#update-the-server&#34;&gt;Update the
server&lt;/a&gt; of the Java quick start page.&lt;/p&gt;
&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;Follow these steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Open &lt;code&gt;HelloworldActivity.java&lt;/code&gt; from the
&lt;code&gt;android/helloworld/app/src/main/java/io/grpc/helloworldexample&lt;/code&gt; folder.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Locate the method containing the call to &lt;code&gt;sayHello()&lt;/code&gt;. You&amp;rsquo;ll see these
lines of code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;HelloReply reply &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;sayHello&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; reply&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add a call to &lt;code&gt;sayHelloAgain()&lt;/code&gt; in the &lt;code&gt;return&lt;/code&gt; statement expression like
this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; reply&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;\n&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;sayHelloAgain&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-the-updated-app&#34;&gt;Run the updated app&lt;/h3&gt;
&lt;p&gt;Run the client and server like you did before. Execute the following commands
from the &lt;code&gt;examples&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew installDist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./build/install/examples/bin/hello-world-server
INFO: Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, build the client and install it on your device:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; android/helloworld; ../../gradlew installDebug&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Launch the client app from your device.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;In the client app, enter the server&amp;rsquo;s &lt;strong&gt;Host&lt;/strong&gt; and &lt;strong&gt;Port&lt;/strong&gt; information. The
values you enter depend on the device kind (real or virtual)  — for
details, see &lt;a href=&#34;#connecting-to-the-server&#34;&gt;Connecting to the server&lt;/a&gt; below.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Type &amp;ldquo;Alice&amp;rdquo; in the &lt;strong&gt;Message&lt;/strong&gt; box and click &lt;strong&gt;Send&lt;/strong&gt;. You&amp;rsquo;ll see the
following response:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nocode&#34; data-lang=&#34;nocode&#34;&gt;Hello Alice
Hello again Alice
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;connecting-to-the-server&#34;&gt;Connecting to the server&lt;/h3&gt;
&lt;h4 id=&#34;connecting-from-a-virtual-device&#34;&gt;Connecting from a virtual device&lt;/h4&gt;
&lt;p&gt;Run the Hello World app on your Android Virtual Device and use the following
values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Host&lt;/strong&gt;: &lt;code&gt;10.0.2.2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Port&lt;/strong&gt;: 50051&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;connecting-from-a-physical-device&#34;&gt;Connecting from a physical device&lt;/h4&gt;
&lt;p&gt;To run the app on a physical device via USB debugging, you must configure USB
port forwarding using the &lt;code&gt;adb&lt;/code&gt; command as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ adb reverse tcp:8080 tcp:50051
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This sets up port forwarding from port &lt;code&gt;8080&lt;/code&gt; on the device to port &lt;code&gt;50051&lt;/code&gt; on
the connected computer, which is the port that the Hello World server is
listening on.&lt;/p&gt;
&lt;p&gt;In the app, use the following values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Host&lt;/strong&gt;: &lt;code&gt;localhost&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Port&lt;/strong&gt;: 8080&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/platforms/android/kotlin/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/platforms/android/kotlin/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://kotlinlang.org&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Kotlin&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; version 1.3 or higher&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://jdk.java.net&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;JDK&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; version 7 or higher&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Android SDK, API level 16 or higher&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Install &lt;a href=&#34;https://developer.android.com/studio/index.html#downloads&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Android Studio&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; or the Android &lt;a href=&#34;https://developer.android.com/studio/index.html#command-tools&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;command-line tools&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Let other tools and scripts know where to find your Android SDK by setting
the following environment variable:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;ANDROID_SDK_ROOT&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&amp;lt;path-to-your-android-sdk&amp;gt;&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;An android device set up for &lt;a href=&#34;https://developer.android.com/studio/command-line/adb.html#Enabling&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;USB debugging&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; or an
&lt;a href=&#34;https://developer.android.com/studio/run/managing-avds.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Android Virtual Device&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    gRPC Kotlin does not support running a server on an Android device. For this
quick start, the Android client app will connect to a server running on your
local (non-Android) computer.

&lt;/div&gt;

&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-kotlin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-kotlin&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/archive/master.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone https://github.com/grpc/grpc-kotlin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the examples directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-kotlin/examples
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-the-example&#34;&gt;Run the example&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew installDist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./server/build/install/server/bin/hello-world-server
Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, build the client and install it on your device:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew :android:installDebug
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Launch the client app from your device.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Type &amp;ldquo;Alice&amp;rdquo; in the &lt;strong&gt;Name&lt;/strong&gt; box and click &lt;strong&gt;Send&lt;/strong&gt;. You&amp;rsquo;ll see the
following response:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nocode&#34; data-lang=&#34;nocode&#34;&gt;Hello Alice
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;h3 id=&#34;update-the-grpc-service&#34;&gt;Update the gRPC service&lt;/h3&gt;
&lt;p&gt;In this section you&amp;rsquo;ll update the application by adding an extra server method.
The gRPC service is defined using &lt;a href=&#34;https://developers.google.com/protocol-buffers&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. To learn more about
how to define a service in a &lt;code&gt;.proto&lt;/code&gt; file see &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;. For now, all
you need to know is that both the server and the client stub have a &lt;code&gt;SayHello()&lt;/code&gt;
RPC method that takes a &lt;code&gt;HelloRequest&lt;/code&gt; parameter from the client and returns a
&lt;code&gt;HelloReply&lt;/code&gt; from the server, and that the method is defined like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Open &lt;code&gt;helloworld/hello_world.proto&lt;/code&gt; from the
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/protos/src/main/proto/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protos/src/main/proto/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder, and add a
new &lt;code&gt;SayHelloAgain()&lt;/code&gt; method, with the same request and response types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The greeting service definition.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; Greeter {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends a greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHello (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sends another greeting
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SayHelloAgain (HelloRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HelloReply) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The request message containing the user&amp;#39;s name.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The response message containing the greetings
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;HelloReply&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Remember to save the file!&lt;/p&gt;
&lt;h3 id=&#34;update-the-app&#34;&gt;Update the app&lt;/h3&gt;
&lt;p&gt;When you build the example, the build process regenerates &lt;code&gt;HelloWorldGrpcKt.kt&lt;/code&gt;,
which contains the generated gRPC client and server classes. This also
regenerates classes for populating, serializing, and retrieving our request and
response types.&lt;/p&gt;
&lt;p&gt;However, you still need to implement and call the new method in the
hand-written parts of the example app.&lt;/p&gt;
&lt;h4 id=&#34;update-the-server&#34;&gt;Update the server&lt;/h4&gt;
&lt;p&gt;Follow the instructions given in &lt;a href=&#34;https://Joevaen.github.io/docs/languages/kotlin/quickstart/#update-the-server&#34;&gt;Update the
server&lt;/a&gt; of the Kotlin
quick start page.&lt;/p&gt;
&lt;h4 id=&#34;update-the-client&#34;&gt;Update the client&lt;/h4&gt;
&lt;p&gt;Follow these steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Open &lt;code&gt;helloworld/MainActivity.kt&lt;/code&gt; from the
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/blob/master/examples/android/src/main/kotlin/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;client/src/main/kotlin/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Locate the function containing the call to &lt;code&gt;sayHello()&lt;/code&gt;. You&amp;rsquo;ll see these
lines of code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; response = greeter.sayHello(request)
responseText.text = response.message
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Add a call to &lt;code&gt;sayHelloAgain()&lt;/code&gt; and change how the response message is
created. Replace the lines of code above with the following:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; response = greeter.sayHello(request)
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; againResponse = greeter.sayHelloAgain(request)
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; message = &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${response.message}&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${againResponse.message}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
responseText.text = message
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-the-updated-app&#34;&gt;Run the updated app&lt;/h3&gt;
&lt;p&gt;Run the client and server like you did before. Execute the following commands
from the &lt;code&gt;examples&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew installDist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./server/build/install/server/bin/hello-world-server
Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;50051&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, build the client and install it on your device:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew :android:installDebug
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Launch the client app from your device.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Type &amp;ldquo;Alice&amp;rdquo; in the &lt;strong&gt;Message&lt;/strong&gt; box and click &lt;strong&gt;Send&lt;/strong&gt;. You&amp;rsquo;ll see the
following response:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nocode&#34; data-lang=&#34;nocode&#34;&gt;Hello Alice
Hello again Alice
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Learn how gRPC works in &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;
and &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/core-concepts/&#34;&gt;Core concepts&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;!--
- Work through the [Basics tutorial][].
--&gt;
&lt;ul&gt;
&lt;li&gt;Explore the &lt;a href=&#34;../api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Quick start</title>
      <link>https://Joevaen.github.io/docs/platforms/web/quickstart/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/platforms/web/quickstart/</guid>
      <description>
        
        
        &lt;h3 id=&#34;prerequisites&#34;&gt;Prerequisites&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Docker and &lt;code&gt;docker-compose&lt;/code&gt; supporting &lt;a href=&#34;https://docs.docker.com/compose/compose-file/compose-versioning&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Docker Compose file version 3&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
For installation instructions see &lt;a href=&#34;https://docs.docker.com/compose/install/#install-compose&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Install Compose&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-web&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-web&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-web/archive/master.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone https://github.com/grpc/grpc-web
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the repo&amp;rsquo;s root directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-web
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;run-an-echo-example-from-your-browser&#34;&gt;Run an Echo example from your browser!&lt;/h3&gt;
&lt;p&gt;From the &lt;code&gt;grpc-web&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Fetch required packages and tools:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ docker-compose pull
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    &lt;p&gt;Getting the following warning? You can ignore it for the purpose of running the
example app:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nocode&#34; data-lang=&#34;nocode&#34;&gt;WARNING: Some service image(s) must be built from source
&lt;/code&gt;&lt;/pre&gt;

&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Launch services as background processes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ docker-compose up -d node-server envoy commonjs-client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From your browser:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Visit
&lt;a href=&#34;http://localhost:8081/echotest.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;localhost:8081/echotest.html&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Enter a message, like &amp;ldquo;Hello&amp;rdquo;, in the text-input box.&lt;/li&gt;
&lt;li&gt;Press the &lt;strong&gt;Send&lt;/strong&gt; button.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You&amp;rsquo;ll see your message echoed by the server below the input box.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Congratulations! You&amp;rsquo;ve just run a client-server application with gRPC.&lt;/p&gt;
&lt;p&gt;Once you are done, shutdown the services that you launched earlier by running
the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ docker-compose down
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;what-is-happening&#34;&gt;What is happening?&lt;/h3&gt;
&lt;p&gt;This example app has three key components:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;node-server&lt;/code&gt; is a standard gRPC server, implemented in Node. This server
listens at port &lt;code&gt;:9090&lt;/code&gt;, and implements the app&amp;rsquo;s business logic (echoing
client messages).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;envoy&lt;/code&gt; is the Envoy proxy. It listens at &lt;code&gt;:8080&lt;/code&gt; and forwards the browser&amp;rsquo;s
gRPC-Web requests to port &lt;code&gt;:9090&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;commonjs-client&lt;/code&gt;: this component generates the client stub class using the
&lt;code&gt;protoc-gen-grpc-web&lt;/code&gt; protoc plugin, compiles all the JS dependencies using
&lt;code&gt;webpack&lt;/code&gt;, and hosts the static content (&lt;code&gt;echotest.html&lt;/code&gt; and &lt;code&gt;dist/main.js&lt;/code&gt;)
at port &lt;code&gt;:8081&lt;/code&gt; using a simple web server. User messages entered from the
webpage are sent to the Envoy proxy as gRPC-web requests.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;whats-next&#34;&gt;What&amp;rsquo;s next&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Work through the &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/cpp/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/cpp/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic C++ programmer&amp;rsquo;s introduction to working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Generate server and client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the C++ gRPC API to write a simple client and server for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes that you have read the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and are familiar
with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. Note
that the example in this tutorial uses the proto3 version of the protocol
buffers language: you can find out more in
the &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/cpp-generated&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;C++
generated code
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;example-code-and-setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;code&gt;grpc&lt;/code&gt; repo under &lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/cpp/route_guide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/cpp/route_guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
Get the example code and build gRPC:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Follow the Quick start instructions to &lt;a href=&#34;https://Joevaen.github.io/docs/languages/cpp/quickstart/#install-grpc&#34;&gt;build and locally install gRPC from
source&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From the repo folder, change to the route guide example directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; examples/cpp/route_guide
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run &lt;code&gt;cmake&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ mkdir -p cmake/build
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; cmake/build
$ cmake -DCMAKE_PREFIX_PATH&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$MY_INSTALL_DIR&lt;/span&gt; ../..
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Our first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to
define the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
You can see the complete .proto file in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/protos/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;examples/protos/route_guide.proto&lt;/code&gt;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in your .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;server-side streaming RPC&lt;/em&gt; where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;client-side streaming RPC&lt;/em&gt; where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;generating-client-and-server-code&#34;&gt;Generating client and server code&lt;/h3&gt;
&lt;p&gt;Next we need to generate the gRPC client and server interfaces from our .proto
service definition. We do this using the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; with
a special gRPC C++ plugin.&lt;/p&gt;
&lt;p&gt;For simplicity, we&amp;rsquo;ve provided a &lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/cpp/route_guide/CMakeLists.txt&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CMakeLists.txt&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
that runs &lt;code&gt;protoc&lt;/code&gt; for you with the appropriate plugin, input, and output (if
you want to run this yourself, make sure you&amp;rsquo;ve installed protoc and followed
the gRPC code &lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/src/cpp/README.md#cmake&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;installation instructions&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; first):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ make route_guide.grpc.pb.o
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;which actually runs:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ protoc -I ../../protos --grpc_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;. --plugin&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;protoc-gen-grpc&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;`&lt;/span&gt;which grpc_cpp_plugin&lt;span style=&#34;color:#c30&#34;&gt;`&lt;/span&gt; ../../protos/route_guide.proto
$ protoc -I ../../protos --cpp_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;. ../../protos/route_guide.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Running this command generates the following files in your current directory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;route_guide.pb.h&lt;/code&gt;, the header which declares your generated message classes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;route_guide.pb.cc&lt;/code&gt;, which contains the implementation of your message classes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;route_guide.grpc.pb.h&lt;/code&gt;, the header which declares your generated service
classes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;route_guide.grpc.pb.cc&lt;/code&gt;, which contains the implementation of your service
classes&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These contain:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;All the protocol buffer code to populate, serialize, and retrieve our request
and response message types&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A class called &lt;code&gt;RouteGuide&lt;/code&gt; that contains&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a remote interface type (or &lt;em&gt;stub&lt;/em&gt;) for clients to call with the methods
defined in the &lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;li&gt;two abstract interfaces for servers to implement, also with the methods
defined in the &lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;server&#34;&gt;Creating the server&lt;/h3&gt;
&lt;p&gt;First let&amp;rsquo;s look at how we create a &lt;code&gt;RouteGuide&lt;/code&gt; server. If you&amp;rsquo;re only
interested in creating gRPC clients, you can skip this section and go straight
to &lt;a href=&#34;#client&#34;&gt;Creating the client&lt;/a&gt; (though you might find it interesting
anyway!).&lt;/p&gt;
&lt;p&gt;There are two parts to making our &lt;code&gt;RouteGuide&lt;/code&gt; service do its job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the service interface generated from our service definition:
doing the actual &amp;ldquo;work&amp;rdquo; of our service.&lt;/li&gt;
&lt;li&gt;Running a gRPC server to listen for requests from clients and return the
service responses.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find our example &lt;code&gt;RouteGuide&lt;/code&gt; server in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/cpp/route_guide/route_guide_server.cc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/cpp/route_guide/route_guide_server.cc&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
Let&amp;rsquo;s take a closer look at how it works.&lt;/p&gt;
&lt;h4 id=&#34;implementing-routeguide&#34;&gt;Implementing RouteGuide&lt;/h4&gt;
&lt;p&gt;As you can see, our server has a &lt;code&gt;RouteGuideImpl&lt;/code&gt; class that implements the
generated &lt;code&gt;RouteGuide::Service&lt;/code&gt; interface:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;RouteGuideImpl&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; RouteGuide&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;Service {
...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this case we&amp;rsquo;re implementing the &lt;em&gt;synchronous&lt;/em&gt; version of &lt;code&gt;RouteGuide&lt;/code&gt;, which
provides our default gRPC server behaviour. It&amp;rsquo;s also possible to implement an
asynchronous interface, &lt;code&gt;RouteGuide::AsyncService&lt;/code&gt;, which allows you to further
customize your server&amp;rsquo;s threading behaviour, though we won&amp;rsquo;t look at this in
this tutorial.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RouteGuideImpl&lt;/code&gt; implements all our service methods. Let&amp;rsquo;s look at the simplest
type first, &lt;code&gt;GetFeature&lt;/code&gt;, which just gets a &lt;code&gt;Point&lt;/code&gt; from the client and returns
the corresponding feature information from its database in a &lt;code&gt;Feature&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;Status &lt;span style=&#34;color:#c0f&#34;&gt;GetFeature&lt;/span&gt;(ServerContext&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; context, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; Point&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; point,
                  Feature&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; feature) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; {
  feature&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;set_name(GetFeatureName(&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;point, feature_list_));
  feature&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;mutable_location()&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;CopyFrom(&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;point);
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; Status&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;OK;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method is passed a context object for the RPC, the client&amp;rsquo;s &lt;code&gt;Point&lt;/code&gt; protocol
buffer request, and a &lt;code&gt;Feature&lt;/code&gt; protocol buffer to fill in with the response
information. In the method we populate the &lt;code&gt;Feature&lt;/code&gt; with the appropriate
information, and then &lt;code&gt;return&lt;/code&gt; with an &lt;code&gt;OK&lt;/code&gt; status to tell gRPC that we&amp;rsquo;ve
finished dealing with the RPC and that the &lt;code&gt;Feature&lt;/code&gt; can be returned to the
client.&lt;/p&gt;
&lt;p&gt;Note that all service methods can (and will!) be called from multiple threads at
the same time. You have to make sure that your method implementations are
thread safe. In our example, &lt;code&gt;feature_list_&lt;/code&gt; is never changed after
construction, so it is safe by design. But if &lt;code&gt;feature_list_&lt;/code&gt; would change during
the lifetime of the service, we would need to synchronize access to this member.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s look at something a bit more complicated - a streaming RPC.
&lt;code&gt;ListFeatures&lt;/code&gt; is a server-side streaming RPC, so we need to send back multiple
&lt;code&gt;Feature&lt;/code&gt;s to our client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;Status &lt;span style=&#34;color:#c0f&#34;&gt;ListFeatures&lt;/span&gt;(ServerContext&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; context, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; Rectangle&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; rectangle,
                    ServerWriter&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;*&lt;/span&gt; writer) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;auto&lt;/span&gt; lo &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; rectangle&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;lo();
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;auto&lt;/span&gt; hi &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; rectangle&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;hi();
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;long&lt;/span&gt; left &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;min(lo.longitude(), hi.longitude());
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;long&lt;/span&gt; right &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;max(lo.longitude(), hi.longitude());
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;long&lt;/span&gt; top &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;max(lo.latitude(), hi.latitude());
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;long&lt;/span&gt; bottom &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;min(lo.latitude(), hi.latitude());
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#99f&#34;&gt;f&lt;/span&gt; : feature_list_) {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (f.location().longitude() &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;=&lt;/span&gt; left &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        f.location().longitude() &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;=&lt;/span&gt; right &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        f.location().latitude() &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;=&lt;/span&gt; bottom &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        f.location().latitude() &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;=&lt;/span&gt; top) {
      writer&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Write(f);
    }
  }
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; Status&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;OK;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, instead of getting simple request and response objects in our
method parameters, this time we get a request object (the &lt;code&gt;Rectangle&lt;/code&gt; in which
our client wants to find &lt;code&gt;Feature&lt;/code&gt;s) and a special &lt;code&gt;ServerWriter&lt;/code&gt; object. In the
method, we populate as many &lt;code&gt;Feature&lt;/code&gt; objects as we need to return, writing them
to the &lt;code&gt;ServerWriter&lt;/code&gt; using its &lt;code&gt;Write()&lt;/code&gt; method. Finally, as in our simple RPC,
we &lt;code&gt;return Status::OK&lt;/code&gt; to tell gRPC that we&amp;rsquo;ve finished writing responses.&lt;/p&gt;
&lt;p&gt;If you look at the client-side streaming method &lt;code&gt;RecordRoute&lt;/code&gt; you&amp;rsquo;ll see it&amp;rsquo;s
quite similar, except this time we get a &lt;code&gt;ServerReader&lt;/code&gt; instead of a request
object and a single response. We use the &lt;code&gt;ServerReader&lt;/code&gt;s &lt;code&gt;Read()&lt;/code&gt; method to
repeatedly read in our client&amp;rsquo;s requests to a request object (in this case a
&lt;code&gt;Point&lt;/code&gt;) until there are no more messages: the server needs to check the return
value of &lt;code&gt;Read()&lt;/code&gt; after each call. If &lt;code&gt;true&lt;/code&gt;, the stream is still good and it
can continue reading; if &lt;code&gt;false&lt;/code&gt; the message stream has ended.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;while&lt;/span&gt; (stream&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Read(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;point)) {
  ...&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;//process client input
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;Status &lt;span style=&#34;color:#c0f&#34;&gt;RouteChat&lt;/span&gt;(ServerContext&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; context,
                 ServerReaderWriter&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote, RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;*&lt;/span&gt; stream) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; {
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;vector&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; received_notes;
  RouteNote note;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;while&lt;/span&gt; (stream&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Read(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;note)) {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#99f&#34;&gt;n&lt;/span&gt; : received_notes) {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (n.location().latitude() &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; note.location().latitude() &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
          n.location().longitude() &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; note.location().longitude()) {
        stream&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Write(n);
      }
    }
    received_notes.push_back(note);
  }

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; Status&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;OK;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This time we get a &lt;code&gt;ServerReaderWriter&lt;/code&gt; that can be used to read &lt;em&gt;and&lt;/em&gt; write
messages. The syntax for reading and writing here is exactly the same as for our
client-streaming and server-streaming methods. Although each side will always
get the other&amp;rsquo;s messages in the order they were written, both the client and
server can read and write in any order — the streams operate completely
independently.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-server&#34;&gt;Starting the server&lt;/h4&gt;
&lt;p&gt;Once we&amp;rsquo;ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for our &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;RunServer&lt;/span&gt;(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt; db_path) {
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string server_address(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;0.0.0.0:50051&amp;#34;&lt;/span&gt;);
  RouteGuideImpl service(db_path);

  ServerBuilder builder;
  builder.AddListeningPort(server_address, grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;InsecureServerCredentials());
  builder.RegisterService(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;service);
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Server&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; server(builder.BuildAndStart());
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Server listening on &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; server_address &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;endl;
  server&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Wait();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we build and start our server using a &lt;code&gt;ServerBuilder&lt;/code&gt;. To do this, we:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create an instance of our service implementation class &lt;code&gt;RouteGuideImpl&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Create an instance of the factory &lt;code&gt;ServerBuilder&lt;/code&gt; class.&lt;/li&gt;
&lt;li&gt;Specify the address and port we want to use to listen for client requests
using the builder&amp;rsquo;s &lt;code&gt;AddListeningPort()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Register our service implementation with the builder.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;BuildAndStart()&lt;/code&gt; on the builder to create and start an RPC server for
our service.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;Wait()&lt;/code&gt; on the server to do a blocking wait until process is killed or
&lt;code&gt;Shutdown()&lt;/code&gt; is called.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, we&amp;rsquo;ll look at creating a C++ client for our &lt;code&gt;RouteGuide&lt;/code&gt;
service. You can see our complete example client code in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/cpp/route_guide/route_guide_client.cc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/cpp/route_guide/route_guide_client.cc&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;creating-a-stub&#34;&gt;Creating a stub&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a &lt;em&gt;stub&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;First we need to create a gRPC &lt;em&gt;channel&lt;/em&gt; for our stub, specifying the server
address and port we want to connect to - in our case we&amp;rsquo;ll use no SSL:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;CreateChannel(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;localhost:50051&amp;#34;&lt;/span&gt;, grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;InsecureChannelCredentials());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    In order to set additional options for the &lt;em&gt;channel&lt;/em&gt;, use the &lt;code&gt;grpc::CreateCustomChannel()&lt;/code&gt; api with any special channel arguments - &lt;code&gt;grpc::ChannelArguments&lt;/code&gt;.

&lt;/div&gt;

&lt;p&gt;Now we can use the channel to create our stub using the &lt;code&gt;NewStub&lt;/code&gt; method provided in the &lt;code&gt;RouteGuide&lt;/code&gt; class we generated from our .proto.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt;
 RouteGuideClient(std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;ChannelInterface&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; channel,
                  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt; db)
     &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; stub_(RouteGuide&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;NewStub(channel)) {
   ...
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how we call our service methods. Note that in this tutorial
we&amp;rsquo;re calling the &lt;em&gt;blocking/synchronous&lt;/em&gt; versions of each method: this means
that the RPC call waits for the server to respond, and will either return a
response or raise an exception.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; is nearly as straightforward as calling a
local method.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;Point point;
Feature feature;
point &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; MakePoint(&lt;span style=&#34;color:#f60&#34;&gt;409146138&lt;/span&gt;, &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;746188906&lt;/span&gt;);
GetOneFeature(point, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;feature);

...

&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;bool&lt;/span&gt; GetOneFeature(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; Point&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt; point, Feature&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; feature) {
  ClientContext context;
  Status status &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub_&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;GetFeature(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;context, point, feature);
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we create and populate a request protocol buffer object (in our
case &lt;code&gt;Point&lt;/code&gt;), and create a response protocol buffer object for the server to
fill in. We also create a &lt;code&gt;ClientContext&lt;/code&gt; object for our call - you can
optionally set RPC configuration values on this object, such as deadlines,
though for now we&amp;rsquo;ll use the default settings. Note that you cannot reuse this
object between calls. Finally, we call the method on the stub, passing it the
context, request, and response. If the method returns &lt;code&gt;OK&lt;/code&gt;, then we can read the
response information from the server from our response object.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Found feature called &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; feature&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;name()  &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34; at &amp;#34;&lt;/span&gt;
          &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; feature&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;location().latitude()&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;kCoordFactor_ &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;, &amp;#34;&lt;/span&gt;
          &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; feature&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;location().longitude()&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;kCoordFactor_ &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;endl;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;streaming-rpcs&#34;&gt;Streaming RPCs&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at our streaming methods. If you&amp;rsquo;ve already read &lt;a href=&#34;#server&#34;&gt;Creating the
server&lt;/a&gt; some of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides. Here&amp;rsquo;s where we call the server-side
streaming method &lt;code&gt;ListFeatures&lt;/code&gt;, which returns a stream of geographical
&lt;code&gt;Feature&lt;/code&gt;s:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;ClientReader&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; reader(
    stub_&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;ListFeatures(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;context, rect));
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;while&lt;/span&gt; (reader&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Read(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;feature)) {
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Found feature called &amp;#34;&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; feature.name() &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34; at &amp;#34;&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; feature.location().latitude()&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;kCoordFactor_ &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;, &amp;#34;&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; feature.location().longitude()&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;kCoordFactor_ &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;endl;
}
Status status &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; reader&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Finish();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Instead of passing the method a context, request, and response, we pass it a
context and request and get a &lt;code&gt;ClientReader&lt;/code&gt; object back. The client can use the
&lt;code&gt;ClientReader&lt;/code&gt; to read the server&amp;rsquo;s responses. We use the &lt;code&gt;ClientReader&lt;/code&gt;s
&lt;code&gt;Read()&lt;/code&gt; method to repeatedly read in the server&amp;rsquo;s responses to a response
protocol buffer object (in this case a &lt;code&gt;Feature&lt;/code&gt;) until there are no more
messages: the client needs to check the return value of &lt;code&gt;Read()&lt;/code&gt; after each
call. If &lt;code&gt;true&lt;/code&gt;, the stream is still good and it can continue reading; if
&lt;code&gt;false&lt;/code&gt; the message stream has ended. Finally, we call &lt;code&gt;Finish()&lt;/code&gt; on the stream
to complete the call and get our RPC status.&lt;/p&gt;
&lt;p&gt;The client-side streaming method &lt;code&gt;RecordRoute&lt;/code&gt; is similar, except there we pass
the method a context and response object and get back a &lt;code&gt;ClientWriter&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;ClientWriter&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; writer(
    stub_&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;RecordRoute(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;context, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;stats));
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt; kPoints; i&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt; f &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; feature_list_[feature_distribution(generator)];
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Visiting point &amp;#34;&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; f.location().latitude()&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;kCoordFactor_ &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;, &amp;#34;&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; f.location().longitude()&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;kCoordFactor_ &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;endl;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#555&#34;&gt;!&lt;/span&gt;writer&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Write(f.location())) {
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Broken stream.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;break&lt;/span&gt;;
  }
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;this_thread&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;sleep_for(std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;chrono&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;milliseconds(
      delay_distribution(generator)));
}
writer&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;WritesDone();
Status status &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; writer&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Finish();
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (status.IsOk()) {
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished trip with &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; stats.point_count() &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34; points&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Passed &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; stats.feature_count() &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34; features&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Travelled &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; stats.distance() &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34; meters&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;It took &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; stats.elapsed_time() &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34; seconds&amp;#34;&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;endl;
} &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;else&lt;/span&gt; {
  std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;cout &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;RecordRoute rpc failed.&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;endl;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once we&amp;rsquo;ve finished writing our client&amp;rsquo;s requests to the stream using &lt;code&gt;Write()&lt;/code&gt;,
we need to call &lt;code&gt;WritesDone()&lt;/code&gt; on the stream to let gRPC know that we&amp;rsquo;ve
finished writing, then &lt;code&gt;Finish()&lt;/code&gt; to complete the call and get our RPC status.
If the status is &lt;code&gt;OK&lt;/code&gt;, our response object that we initially passed to
&lt;code&gt;RecordRoute()&lt;/code&gt; will be populated with the server&amp;rsquo;s response.&lt;/p&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;. In this
case, we just pass a context to the method and get back a &lt;code&gt;ClientReaderWriter&lt;/code&gt;,
which we can use to both write and read messages.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;ClientReaderWriter&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote, RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; stream(
    stub_&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;RouteChat(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;context));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The syntax for reading and writing here is exactly the same as for our
client-streaming and server-streaming methods. Although each side will always
get the other&amp;rsquo;s messages in the order they were written, both the client and
server can read and write in any order — the streams operate completely
independently.&lt;/p&gt;
&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Build the client and server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./route_guide_server
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;From a different terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./route_guide_client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/csharp/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/csharp/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic C# programmer&amp;rsquo;s introduction to working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Generate server and client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the C# gRPC API to write a simple client and server for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes that you have read the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and are familiar
with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. Note that the
example in this tutorial uses the proto3 version of the protocol buffers
language: you can find out more in the
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/csharp-generated&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;C# generated code reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;example-code-and-setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code for our tutorial is in
&lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/csharp/RouteGuide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc/grpc/examples/csharp/RouteGuide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. To
download the example, clone the &lt;code&gt;grpc&lt;/code&gt; repository by running the following
command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.37.1 https://github.com/grpc/grpc
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;All the files for this tutorial are in the directory
&lt;code&gt;examples/csharp/RouteGuide&lt;/code&gt;. Open the solution
&lt;code&gt;examples/csharp/RouteGuide/RouteGuide.sln&lt;/code&gt; from Visual Studio (Windows or Mac) or Visual Studio Code.
For additional installation details, see the &lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/src/csharp#how-to-use&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;How to use
instructions&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Our first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to
define the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
You can see the complete .proto file in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/protos/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;examples/protos/route_guide.proto&lt;/code&gt;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in your .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the client
object and waits for a response to come back, just like a normal function
call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;server-side streaming RPC&lt;/em&gt; where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;client-side streaming RPC&lt;/em&gt; where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our  &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;generating-client-and-server-code&#34;&gt;Generating client and server code&lt;/h3&gt;
&lt;p&gt;Next we need to generate the gRPC client and server interfaces from our .proto
service definition. This can be done by invoking the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; with
a special gRPC C# plugin from the command line, but starting from version
1.17 the &lt;code&gt;Grpc.Tools&lt;/code&gt; NuGet package integrates with MSBuild to provide &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/src/csharp/BUILD-INTEGRATION.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;automatic C# code generation&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
from &lt;code&gt;.proto&lt;/code&gt; files, which gives much better developer experience by running
the right commands for you as part of the build.&lt;/p&gt;
&lt;p&gt;This example already has a dependency on &lt;code&gt;Grpc.Tools&lt;/code&gt; NuGet package and the
&lt;code&gt;route_guide.proto&lt;/code&gt; has already been added to the project, so the only thing
needed to generate the client and server code is to build the solution.
That can be done by running &lt;code&gt;dotnet build RouteGuide.sln&lt;/code&gt; or building directly
in Visual Studio.&lt;/p&gt;
&lt;p&gt;The build regenerates the following files
under the &lt;code&gt;RouteGuide/obj/Debug/TARGET_FRAMEWORK&lt;/code&gt; directory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RouteGuide.cs&lt;/code&gt; contains all the protocol buffer code to populate,
serialize, and retrieve our request and response message types&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteGuideGrpc.cs&lt;/code&gt; provides generated client and server classes,
including:
&lt;ul&gt;
&lt;li&gt;an abstract class &lt;code&gt;RouteGuide.RouteGuideBase&lt;/code&gt; to inherit from when defining
RouteGuide service implementations&lt;/li&gt;
&lt;li&gt;a class &lt;code&gt;RouteGuide.RouteGuideClient&lt;/code&gt; that can be used to access remote
RouteGuide instances&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;server&#34;&gt;Creating the server&lt;/h3&gt;
&lt;p&gt;First let&amp;rsquo;s look at how we create a &lt;code&gt;RouteGuide&lt;/code&gt; server. If you&amp;rsquo;re only
interested in creating gRPC clients, you can skip this section and go straight
to &lt;a href=&#34;#client&#34;&gt;Creating the client&lt;/a&gt; (though you might find it interesting
anyway!).&lt;/p&gt;
&lt;p&gt;There are two parts to making our &lt;code&gt;RouteGuide&lt;/code&gt; service do its job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the service functionality by inheriting from the base class
generated from our service definition: doing the actual &amp;ldquo;work&amp;rdquo; of our service.&lt;/li&gt;
&lt;li&gt;Running a gRPC server to listen for requests from clients and return the
service responses.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find our example &lt;code&gt;RouteGuide&lt;/code&gt; server in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/csharp/RouteGuide/RouteGuideServer/RouteGuideImpl.cs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/csharp/RouteGuide/RouteGuideServer/RouteGuideImpl.cs&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
Let&amp;rsquo;s take a closer look at how it works.&lt;/p&gt;
&lt;h4 id=&#34;implementing-routeguide&#34;&gt;Implementing RouteGuide&lt;/h4&gt;
&lt;p&gt;As you can see, our server has a &lt;code&gt;RouteGuideImpl&lt;/code&gt; class that inherits from the
generated &lt;code&gt;RouteGuide.RouteGuideBase&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteGuideImpl provides an implementation of the RouteGuide service.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;RouteGuideImpl&lt;/span&gt; : RouteGuide.RouteGuideBase
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;RouteGuideImpl&lt;/code&gt; implements all our service methods. Let&amp;rsquo;s look at the simplest
type first, &lt;code&gt;GetFeature&lt;/code&gt;, which just gets a &lt;code&gt;Point&lt;/code&gt; from the client and returns
the corresponding feature information from its database in a &lt;code&gt;Feature&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; Task&amp;lt;Feature&amp;gt; GetFeature(Point request, Grpc.Core.ServerCallContext context)
{
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; Task.FromResult(CheckFeature(request));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method is passed a context for the RPC (which is empty in the alpha
release), the client&amp;rsquo;s &lt;code&gt;Point&lt;/code&gt; protocol buffer request, and returns a &lt;code&gt;Feature&lt;/code&gt;
protocol buffer. In the method we create the &lt;code&gt;Feature&lt;/code&gt; with the appropriate
information, and then return it. To allow asynchronous implementation, the
method returns &lt;code&gt;Task&amp;lt;Feature&amp;gt;&lt;/code&gt; rather than just &lt;code&gt;Feature&lt;/code&gt;. You are free to
perform your computations synchronously and return the result once you&amp;rsquo;ve
finished, just as we do in the example.&lt;/p&gt;
&lt;h5 id=&#34;server-side-streaming-rpc&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at something a bit more complicated - a streaming RPC.
&lt;code&gt;ListFeatures&lt;/code&gt; is a server-side streaming RPC, so we need to send back multiple
&lt;code&gt;Feature&lt;/code&gt; protocol buffers to our client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// in RouteGuideImpl
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; Task ListFeatures(Rectangle request,
    Grpc.Core.IServerStreamWriter&amp;lt;Feature&amp;gt; responseStream,
    Grpc.Core.ServerCallContext context)
{
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; responses = features.FindAll( (feature) =&amp;gt; feature.Exists() &amp;amp;&amp;amp; request.Contains(feature.Location) );
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; response &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; responses)
    {
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; responseStream.WriteAsync(response);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, here the request object is a &lt;code&gt;Rectangle&lt;/code&gt; in which our client
wants to find &lt;code&gt;Feature&lt;/code&gt;s, but instead of returning a simple response we need to
write responses to an asynchronous stream &lt;code&gt;IServerStreamWriter&lt;/code&gt; using async
method &lt;code&gt;WriteAsync&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Similarly, the client-side streaming method &lt;code&gt;RecordRoute&lt;/code&gt; uses an
&lt;a href=&#34;https://github.com/Reactive-Extensions/Rx.NET/blob/master/Ix.NET/Source/System.Interactive.Async/IAsyncEnumerator.cs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;IAsyncEnumerator&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;,
to read the stream of requests using the async method &lt;code&gt;MoveNext&lt;/code&gt; and the
&lt;code&gt;Current&lt;/code&gt; property.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; Task&amp;lt;RouteSummary&amp;gt; RecordRoute(Grpc.Core.IAsyncStreamReader&amp;lt;Point&amp;gt; requestStream,
    Grpc.Core.ServerCallContext context)
{
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; pointCount = &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; featureCount = &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;;
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; distance = &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;;
    Point previous = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;;
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; stopwatch = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Stopwatch();
    stopwatch.Start();

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; requestStream.MoveNext())
    {
        &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; point = requestStream.Current;
        pointCount++;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (CheckFeature(point).Exists())
        {
            featureCount++;
        }
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (previous != &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;)
        {
            distance += (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt;) previous.GetDistance(point);
        }
        previous = point;
    }

    stopwatch.Stop();

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; RouteSummary
    {
        PointCount = pointCount,
        FeatureCount = featureCount,
        Distance = distance,
        ElapsedTime = (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt;)(stopwatch.ElapsedMilliseconds / &lt;span style=&#34;color:#f60&#34;&gt;1000&lt;/span&gt;)
    };
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;bidirectional-streaming-rpc&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; Task RouteChat(Grpc.Core.IAsyncStreamReader&amp;lt;RouteNote&amp;gt; requestStream,
    Grpc.Core.IServerStreamWriter&amp;lt;RouteNote&amp;gt; responseStream,
    Grpc.Core.ServerCallContext context)
{
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; requestStream.MoveNext())
    {
        &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; note = requestStream.Current;
        List&amp;lt;RouteNote&amp;gt; prevNotes = AddNoteForLocation(note.Location, note);
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; prevNote &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; prevNotes)
        {
            &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; responseStream.WriteAsync(prevNote);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here the method receives both &lt;code&gt;requestStream&lt;/code&gt; and &lt;code&gt;responseStream&lt;/code&gt; arguments.
Reading the requests is done the same way as in the client-side streaming method
&lt;code&gt;RecordRoute&lt;/code&gt;.  Writing the responses is done the same way as in the server-side
streaming method &lt;code&gt;ListFeatures&lt;/code&gt;.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-server&#34;&gt;Starting the server&lt;/h4&gt;
&lt;p&gt;Once we&amp;rsquo;ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for our &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; features = RouteGuideUtil.LoadFeatures();

Server server = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Server
{
    Services = { RouteGuide.BindService(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; RouteGuideImpl(features)) },
    Ports = { &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; ServerPort(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;, Port, ServerCredentials.Insecure) }
};
server.Start();

Console.WriteLine(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;RouteGuide server listening on port &amp;#34;&lt;/span&gt; + port);
Console.WriteLine(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Press any key to stop the server...&amp;#34;&lt;/span&gt;);
Console.ReadKey();

server.ShutdownAsync().Wait();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we build and start our server using &lt;code&gt;Grpc.Core.Server&lt;/code&gt; class. To
do this, we:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create an instance of &lt;code&gt;Grpc.Core.Server&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Create an instance of our service implementation class &lt;code&gt;RouteGuideImpl&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Register our service implementation by adding its service definition to the
&lt;code&gt;Services&lt;/code&gt; collection (We obtain the service definition from the generated
&lt;code&gt;RouteGuide.BindService&lt;/code&gt; method).&lt;/li&gt;
&lt;li&gt;Specify the address and port we want to use to listen for client requests.
This is done by adding &lt;code&gt;ServerPort&lt;/code&gt; to the &lt;code&gt;Ports&lt;/code&gt; collection.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;Start&lt;/code&gt; on the server instance to start an RPC server for our service.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, we&amp;rsquo;ll look at creating a C# client for our &lt;code&gt;RouteGuide&lt;/code&gt;
service. You can see our complete example client code in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/csharp/RouteGuide/RouteGuideClient/Program.cs&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/csharp/RouteGuide/RouteGuideClient/Program.cs&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;creating-a-client-object&#34;&gt;Creating a client object&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a client object (also referred
to as &lt;em&gt;stub&lt;/em&gt; for other gRPC languages).&lt;/p&gt;
&lt;p&gt;First, we need to create a gRPC client channel that will connect to gRPC server.
Then, we create an instance of the &lt;code&gt;RouteGuide.RouteGuideClient&lt;/code&gt; class generated
from our .proto, passing the channel as an argument.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;Channel channel = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Channel(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;127.0.0.1:50052&amp;#34;&lt;/span&gt;, ChannelCredentials.Insecure);
&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; client = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; RouteGuide.RouteGuideClient(channel);

&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// YOUR CODE GOES HERE
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;
channel.ShutdownAsync().Wait();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how we call our service methods. gRPC C# provides asynchronous
versions of each of the supported method types. For convenience, gRPC C# also
provides a synchronous method stub, but only for simple (single request/single
response) RPCs.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc-1&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; in a synchronous way is nearly as
straightforward as calling a local method.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;Point request = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Point { Latitude = &lt;span style=&#34;color:#f60&#34;&gt;409146138&lt;/span&gt;, Longitude = -&lt;span style=&#34;color:#f60&#34;&gt;746188906&lt;/span&gt; };
Feature feature = client.GetFeature(request);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we create and populate a request protocol buffer object (in our
case &lt;code&gt;Point&lt;/code&gt;), and call the desired method on the client object, passing it the
request. If the RPC finishes with success, the response protocol buffer (in our
case &lt;code&gt;Feature&lt;/code&gt;) is returned. Otherwise, an exception of type &lt;code&gt;RpcException&lt;/code&gt; is
thrown, indicating the status code of the problem.&lt;/p&gt;
&lt;p&gt;Alternatively, if you are in an async context, you can call an asynchronous
version of the method and use the &lt;code&gt;await&lt;/code&gt; keyword to await the result:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;Point request = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Point { Latitude = &lt;span style=&#34;color:#f60&#34;&gt;409146138&lt;/span&gt;, Longitude = -&lt;span style=&#34;color:#f60&#34;&gt;746188906&lt;/span&gt; };
Feature feature = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; client.GetFeatureAsync(request);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;streaming-rpcs&#34;&gt;Streaming RPCs&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at our streaming methods. If you&amp;rsquo;ve already read &lt;a href=&#34;#server&#34;&gt;Creating the
server&lt;/a&gt; some of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides. The difference with respect to
simple call is that the client methods return an instance of a call object. This
provides access to request/response streams and/or the asynchronous result,
depending on the streaming type you are using.&lt;/p&gt;
&lt;p&gt;Here&amp;rsquo;s where we call the server-side streaming method &lt;code&gt;ListFeatures&lt;/code&gt;, which has
the property &lt;code&gt;ReponseStream&lt;/code&gt; of type &lt;code&gt;IAsyncEnumerator&amp;lt;Feature&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; call = client.ListFeatures(request))
{
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; call.ResponseStream.MoveNext())
    {
        Feature feature = call.ResponseStream.Current;
        Console.WriteLine(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Received &amp;#34;&lt;/span&gt; + feature.ToString());
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The client-side streaming method &lt;code&gt;RecordRoute&lt;/code&gt; is similar, except we use the
property &lt;code&gt;RequestStream&lt;/code&gt; to write the requests one by one using &lt;code&gt;WriteAsync&lt;/code&gt;,
and eventually signal that no more requests will be sent using &lt;code&gt;CompleteAsync&lt;/code&gt;.
The method result can be obtained through the property &lt;code&gt;ResponseAsync&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; call = client.RecordRoute())
{
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; point &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; points)
    {
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; call.RequestStream.WriteAsync(point);
    }
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; call.RequestStream.CompleteAsync();

    RouteSummary summary = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; call.ResponseAsync;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat&lt;/code&gt;. In this
case, we write the request to &lt;code&gt;RequestStream&lt;/code&gt; and receive the responses from
&lt;code&gt;ResponseStream&lt;/code&gt;. As you can see from the example, the streams are independent
of each other.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;using&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; call = client.RouteChat())
{
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; responseReaderTask = Task.Run(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; () =&amp;gt;
    {
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; call.ResponseStream.MoveNext())
        {
            &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;var&lt;/span&gt; note = call.ResponseStream.Current;
            Console.WriteLine(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Received &amp;#34;&lt;/span&gt; + note);
        }
    });

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;foreach&lt;/span&gt; (RouteNote request &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; requests)
    {
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; call.RequestStream.WriteAsync(request);
    }
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; call.RequestStream.CompleteAsync();
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; responseReaderTask;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Build the client and server:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;Using Visual Studio (or Visual Studio For Mac)&lt;/dt&gt;
&lt;dd&gt;Open the solution &lt;code&gt;examples/csharp/RouteGuide/RouteGuide.sln&lt;/code&gt; and select &lt;strong&gt;Build&lt;/strong&gt;.&lt;/dd&gt;
&lt;dt&gt;Using &lt;code&gt;dotnet&lt;/code&gt; command line tool&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Run &lt;code&gt;dotnet build RouteGuide.sln&lt;/code&gt; from the &lt;code&gt;examples/csharp/RouteGuide&lt;/code&gt;
directory. For additional instructions on building the gRPC example with the
&lt;code&gt;dotnet&lt;/code&gt; command line tool, see &lt;a href=&#34;../quickstart/&#34;&gt;Quick start&lt;/a&gt;.&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&amp;gt; &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; RouteGuideServer
&amp;gt; dotnet run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;From a different terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;&amp;gt; &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; RouteGuideClient
&amp;gt; dotnet run
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can also run the server and client directly from Visual Studio.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/dart/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/dart/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic Dart programmer&amp;rsquo;s introduction to working with
gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Generate server and client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the Dart gRPC API to write a simple client and server for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes that you have read the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and are familiar
with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. Note that the
example in this tutorial uses the proto3 version of the protocol buffers
language: you can find out more in the
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;example-code-and-setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code for our tutorial is in
&lt;a href=&#34;https://github.com/grpc/grpc-dart/tree/master/example/route_guide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc/grpc-dart/example/route_guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
To download the example, clone the &lt;code&gt;grpc-dart&lt;/code&gt; repository by running the following
command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone https://github.com/grpc/grpc-dart.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then change your current directory to &lt;code&gt;grpc-dart/example/route_guide&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-dart/example/route_guide
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You should have already installed the tools needed to generate client and server
interface code &amp;ndash; if you haven&amp;rsquo;t, see &lt;a href=&#34;../quickstart/&#34;&gt;Quick start&lt;/a&gt; for setup instructions.&lt;/p&gt;
&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Our first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to
define the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. You can see the
complete .proto file in
&lt;a href=&#34;https://github.com/grpc/grpc-dart/blob/master/example/route_guide/protos/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;example/route_guide/protos/route_guide.proto&lt;/code&gt;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in your .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;server-side streaming RPC&lt;/em&gt; where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;client-side streaming RPC&lt;/em&gt; where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;generating-client-and-server-code&#34;&gt;Generating client and server code&lt;/h3&gt;
&lt;p&gt;Next we need to generate the gRPC client and server interfaces from our &lt;code&gt;.proto&lt;/code&gt;
service definition. We do this using the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; with
a special Dart plugin. This is similar to what we did in the &lt;a href=&#34;../quickstart/&#34;&gt;Quick start&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;From the &lt;code&gt;route_guide&lt;/code&gt; example directory run:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;protoc -I protos/ protos/route_guide.proto --dart_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;grpc:lib/src/generated
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Running this command generates the following files in the &lt;code&gt;lib/src/generated&lt;/code&gt;
directory under the &lt;code&gt;route_guide&lt;/code&gt; example directory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;route_guide.pb.dart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;route_guide.pbenum.dart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;route_guide.pbgrpc.dart&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;route_guide.pbjson.dart&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This contains:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All the protocol buffer code to populate, serialize, and retrieve our request
and response message types&lt;/li&gt;
&lt;li&gt;An interface type (or &lt;em&gt;stub&lt;/em&gt;) for clients to call with the methods defined in
the &lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;li&gt;An interface type for servers to implement, also with the methods defined in
the &lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;server&#34;&gt;Creating the server&lt;/h3&gt;
&lt;p&gt;First let&amp;rsquo;s look at how we create a &lt;code&gt;RouteGuide&lt;/code&gt; server. If you&amp;rsquo;re only
interested in creating gRPC clients, you can skip this section and go straight
to &lt;a href=&#34;#client&#34;&gt;Creating the client&lt;/a&gt; (though you might find it interesting
anyway!).&lt;/p&gt;
&lt;p&gt;There are two parts to making our &lt;code&gt;RouteGuide&lt;/code&gt; service do its job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the service interface generated from our service definition:
doing the actual &amp;ldquo;work&amp;rdquo; of our service.&lt;/li&gt;
&lt;li&gt;Running a gRPC server to listen for requests from clients and dispatch them to
the right service implementation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find our example &lt;code&gt;RouteGuide&lt;/code&gt; server in
&lt;a href=&#34;https://github.com/grpc/grpc-dart/tree/master/example/route_guide/lib/src/server.dart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-dart/example/route_guide/lib/src/server.dart&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
Let&amp;rsquo;s take a closer look at how it works.&lt;/p&gt;
&lt;h4 id=&#34;implementing-routeguide&#34;&gt;Implementing RouteGuide&lt;/h4&gt;
&lt;p&gt;As you can see, our server has a &lt;code&gt;RouteGuideService&lt;/code&gt; class that extends the
generated abstract &lt;code&gt;RouteGuideServiceBase&lt;/code&gt; class:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;RouteGuideService&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;extends&lt;/span&gt; RouteGuideServiceBase {
  Future&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; getFeature(grpc.ServiceCall call, Point request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; {
    ...
  }

  Stream&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; listFeatures(
      grpc.ServiceCall call, Rectangle request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; {
    ...
  }

  Future&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteSummary&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; recordRoute(
      grpc.ServiceCall call, Stream&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; {
    ...
  }

  Stream&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; routeChat(
      grpc.ServiceCall call, Stream&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; {
    ...
  }

  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;RouteGuideService&lt;/code&gt; implements all our service methods. Let&amp;rsquo;s look at the
simplest type first, &lt;code&gt;GetFeature&lt;/code&gt;, which just gets a &lt;code&gt;Point&lt;/code&gt; from the client and
returns the corresponding feature information from its database in a &lt;code&gt;Feature&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/// GetFeature handler. Returns a feature for the given location.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/// The [context] object provides access to client metadata, cancellation, etc.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;@&lt;/span&gt;override
Future&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; getFeature(grpc.ServiceCall call, Point request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; featuresDb.firstWhere((f) &lt;span style=&#34;color:#555&#34;&gt;=&amp;gt;&lt;/span&gt; f.location &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; request,
      &lt;span style=&#34;color:#99f&#34;&gt;orElse:&lt;/span&gt; () &lt;span style=&#34;color:#555&#34;&gt;=&amp;gt;&lt;/span&gt; Feature()..location &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; request);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method is passed a context object for the RPC and the client&amp;rsquo;s &lt;code&gt;Point&lt;/code&gt;
protocol buffer request. It returns a &lt;code&gt;Feature&lt;/code&gt; protocol buffer object with the
response information. In the method we populate the &lt;code&gt;Feature&lt;/code&gt; with the appropriate
information, and then &lt;code&gt;return&lt;/code&gt; it to the gRPC framework, which sends it back to
the client.&lt;/p&gt;
&lt;h5 id=&#34;server-side-streaming-rpc&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at one of our streaming RPCs. &lt;code&gt;ListFeatures&lt;/code&gt; is a server-side
streaming RPC, so we need to send back multiple &lt;code&gt;Feature&lt;/code&gt;s to our client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/// ListFeatures handler. Returns a stream of features within the given
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/// rectangle.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;@&lt;/span&gt;override
Stream&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; listFeatures(
    grpc.ServiceCall call, Rectangle request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; normalizedRectangle &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; _normalize(request);
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// For each feature, check if it is in the given bounding box
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; feature &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; featuresDb) {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (feature.name.isEmpty) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;continue&lt;/span&gt;;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; location &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; feature.location;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (_contains(normalizedRectangle, location)) {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;yield&lt;/span&gt; feature;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, instead of getting and returning simple request and response
objects in our method, this time we get a request object (the &lt;code&gt;Rectangle&lt;/code&gt; in
which our client wants to find &lt;code&gt;Feature&lt;/code&gt;s) and return a &lt;code&gt;Stream&lt;/code&gt; of &lt;code&gt;Feature&lt;/code&gt;
objects.&lt;/p&gt;
&lt;p&gt;In the method, we populate as many &lt;code&gt;Feature&lt;/code&gt; objects as we need to return,
adding them to the returned stream using &lt;code&gt;yield&lt;/code&gt;. The stream is automatically
closed when the method returns, telling gRPC that we have finished writing
responses.&lt;/p&gt;
&lt;p&gt;Should any error happen in this call, the error will be added as an exception
to the stream, and the gRPC layer will translate it into an appropriate RPC
status to be sent on the wire.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at something a little more complicated: the client-side
streaming method &lt;code&gt;RecordRoute&lt;/code&gt;, where we get a stream of &lt;code&gt;Point&lt;/code&gt;s from the
client and return a single &lt;code&gt;RouteSummary&lt;/code&gt; with information about their trip. As
you can see, this time the request parameter is a stream, which the server can
use to both read request messages from the client. The server returns its single
response just like in the simple RPC case.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/// RecordRoute handler. Gets a stream of points, and responds with statistics
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/// about the &amp;#34;trip&amp;#34;: number of points, number of known features visited,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/// total distance traveled, and total time spent.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;@&lt;/span&gt;override
Future&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteSummary&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; recordRoute(
    grpc.ServiceCall call, Stream&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; {
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; pointCount &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; featureCount &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;;
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;double&lt;/span&gt; distance &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0.0&lt;/span&gt;;
  Point previous;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; timer &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; Stopwatch();

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; location &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; request) {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#555&#34;&gt;!&lt;/span&gt;timer.isRunning) timer.start();
    pointCount&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; feature &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; featuresDb.firstWhere((f) &lt;span style=&#34;color:#555&#34;&gt;=&amp;gt;&lt;/span&gt; f.location &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; location,
        &lt;span style=&#34;color:#99f&#34;&gt;orElse:&lt;/span&gt; () &lt;span style=&#34;color:#555&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;);
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (feature &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
      featureCount&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// For each point after the first, add the incremental distance from the
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// previous point to the total distance value.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (previous &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;) distance &lt;span style=&#34;color:#555&#34;&gt;+=&lt;/span&gt; _distance(previous, location);
    previous &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; location;
  }
  timer.stop();
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; RouteSummary()
    ..pointCount &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; pointCount
    ..featureCount &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; featureCount
    ..distance &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; distance.round()
    ..elapsedTime &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; timer.elapsed.inSeconds;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the method body we use &lt;code&gt;await for&lt;/code&gt; in the request stream to repeatedly read
in our client&amp;rsquo;s requests (in this case &lt;code&gt;Point&lt;/code&gt; objects) until there are no more
messages. Once the request stream is done, the server can return its
&lt;code&gt;RouteSummary&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/// RouteChat handler. Receives a stream of message/location pairs, and
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/// responds with a stream of all previous messages at each of those
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/// locations.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;@&lt;/span&gt;override
Stream&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; routeChat(
    grpc.ServiceCall call, Stream&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; note &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; request) {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; notes &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; routeNotes.putIfAbsent(note.location, () &lt;span style=&#34;color:#555&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt;[]);
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; note &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; notes) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;yield&lt;/span&gt; note;
    notes.add(note);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This time we get a stream of &lt;code&gt;RouteNote&lt;/code&gt; that, as in our client-side streaming
example, can be used to read messages. However, this time we return values via
our method&amp;rsquo;s returned stream while the client is still writing messages to
&lt;em&gt;their&lt;/em&gt; message stream.&lt;/p&gt;
&lt;p&gt;The syntax for reading and writing here is the same as our client-streaming and
server-streaming methods. Although each side will always get the other&amp;rsquo;s messages
in the order they were written, both the client and server can read and write in
any order — the streams operate completely independently.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-server&#34;&gt;Starting the server&lt;/h4&gt;
&lt;p&gt;Once we&amp;rsquo;ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for our &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;Future&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; main(List&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;String&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; args) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; server &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; grpc.Server([RouteGuideService()]);
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; server.serve(&lt;span style=&#34;color:#99f&#34;&gt;port:&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;8080&lt;/span&gt;);
  print(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Server listening...&amp;#39;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To build and start a server, we:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create an instance of the gRPC server using &lt;code&gt;grpc.Server()&lt;/code&gt;,
giving a list of service implementations.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;serve()&lt;/code&gt; on the server to start listening for requests, optionally passing
in the address and port to listen on. The server will continue to serve requests
asynchronously until &lt;code&gt;shutdown()&lt;/code&gt; is called on it.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, we&amp;rsquo;ll look at creating a Dart client for our &lt;code&gt;RouteGuide&lt;/code&gt;
service. The complete client code is available from
&lt;a href=&#34;https://github.com/grpc/grpc-dart/tree/master/example/route_guide/lib/src/client.dart&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-dart/example/route_guide/lib/src/client.dart&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;creating-a-stub&#34;&gt;Creating a stub&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a gRPC &lt;em&gt;channel&lt;/em&gt; to communicate
with the server. We create this by passing the server address and port number to
&lt;code&gt;ClientChannel()&lt;/code&gt; as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; channel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; ClientChannel(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;,
    &lt;span style=&#34;color:#99f&#34;&gt;port:&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;8080&lt;/span&gt;,
    &lt;span style=&#34;color:#99f&#34;&gt;options:&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; ChannelOptions(
        &lt;span style=&#34;color:#99f&#34;&gt;credentials:&lt;/span&gt; ChannelCredentials.insecure()));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can use &lt;code&gt;ChannelOptions&lt;/code&gt; to set TLS options (for example, trusted
certificates) for the channel, if necessary.&lt;/p&gt;
&lt;p&gt;Once the gRPC &lt;em&gt;channel&lt;/em&gt; is setup, we need a client &lt;em&gt;stub&lt;/em&gt; to perform RPCs. We
get it by instantiating &lt;code&gt;RouteGuideClient&lt;/code&gt;, which is provided by the package
generated from the example &lt;code&gt;.proto&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;stub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; RouteGuideClient(channel,
    &lt;span style=&#34;color:#99f&#34;&gt;options:&lt;/span&gt; CallOptions(&lt;span style=&#34;color:#99f&#34;&gt;timeout:&lt;/span&gt; Duration(&lt;span style=&#34;color:#99f&#34;&gt;seconds:&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;30&lt;/span&gt;)));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can use &lt;code&gt;CallOptions&lt;/code&gt; to set auth credentials (for example, GCE credentials
or JWT credentials) when a service requires them. The &lt;code&gt;RouteGuide&lt;/code&gt; service
doesn&amp;rsquo;t require any credentials.&lt;/p&gt;
&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how we call our service methods. Note that in gRPC-Dart, RPCs
are always asynchronous, which means that the RPC returns a &lt;code&gt;Future&lt;/code&gt; or &lt;code&gt;Stream&lt;/code&gt;
that must be listened to, to get the response from the server or an error.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc-1&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; is nearly as straightforward as calling a
local method.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; point &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; Point()
  ..latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;409146138&lt;/span&gt;
  ..longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;746188906&lt;/span&gt;;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; feature &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; stub.getFeature(point));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we call the method on the stub we got earlier. In our method
parameters we pass a request protocol buffer object (in our case &lt;code&gt;Point&lt;/code&gt;).
We can also pass an optional &lt;code&gt;CallOptions&lt;/code&gt; object which lets us change our RPC&amp;rsquo;s
behavior if necessary, such as time-out. If the call doesn&amp;rsquo;t return an error,
the returned &lt;code&gt;Future&lt;/code&gt; completes with the response information from the server.
If there is an error, the &lt;code&gt;Future&lt;/code&gt; will complete with the error.&lt;/p&gt;
&lt;h5 id=&#34;server-side-streaming-rpc-1&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Here&amp;rsquo;s where we call the server-side streaming method &lt;code&gt;ListFeatures&lt;/code&gt;, which
returns a stream of geographical &lt;code&gt;Feature&lt;/code&gt;s. If you&amp;rsquo;ve already read &lt;a href=&#34;#server&#34;&gt;Creating
the server&lt;/a&gt; some of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; rect &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; Rectangle()...; &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// initialize a Rectangle
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;try&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; feature &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; stub.listFeatures(rect)) {
    print(feature);
  }
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;catch&lt;/span&gt; (e) {
  print(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;ERROR: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;$&lt;/span&gt;e&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As in the simple RPC, we pass the method a request. However, instead of getting
a &lt;code&gt;Future&lt;/code&gt; back, we get a &lt;code&gt;Stream&lt;/code&gt;. The client can use the stream to read the
server&amp;rsquo;s responses.&lt;/p&gt;
&lt;p&gt;We use &lt;code&gt;await for&lt;/code&gt; on the returned stream to repeatedly read in the server&amp;rsquo;s
responses to a response protocol buffer object (in this case a &lt;code&gt;Feature&lt;/code&gt;) until
there are no more messages.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc-1&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;The client-side streaming method &lt;code&gt;RecordRoute&lt;/code&gt; is similar to the server-side
method, except that we pass the method a &lt;code&gt;Stream&lt;/code&gt; and get a &lt;code&gt;Future&lt;/code&gt; back.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; random &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; Random();

&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Generate a number of random points
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;Stream&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; generateRoute(&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; count) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt; count; i&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;) {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; point &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; featuresDb[random.nextInt(featuresDb.length)].location;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;yield&lt;/span&gt; point;
  }
}

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; pointCount &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; random.nextInt(&lt;span style=&#34;color:#f60&#34;&gt;100&lt;/span&gt;) &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;; &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Traverse at least two points
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; summary &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; stub.recordRoute(generateRoute(pointCount));
print(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Route summary: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;$&lt;/span&gt;summary&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Since the &lt;code&gt;generateRoute()&lt;/code&gt; method is &lt;code&gt;async*&lt;/code&gt;, the points will be generated when
gRPC listens to the request stream and sends the point messages to the server. Once
the stream is done (when &lt;code&gt;generateRoute()&lt;/code&gt; returns), gRPC knows that we&amp;rsquo;ve finished
writing and are expecting to receive a response. The returned &lt;code&gt;Future&lt;/code&gt; will either
complete with the &lt;code&gt;RouteSummary&lt;/code&gt; message received from the server, or an error.&lt;/p&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc-1&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;. As in the
case of &lt;code&gt;RecordRoute&lt;/code&gt;, we pass the method a stream where we will write the request
messages, and like in &lt;code&gt;ListFeatures&lt;/code&gt;, we get back a stream that we can use to read
the response messages. However, this time we will send values via our method&amp;rsquo;s stream
while the server is also writing messages to &lt;em&gt;their&lt;/em&gt; message stream.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-dart&#34; data-lang=&#34;dart&#34;&gt;Stream&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; outgoingNotes &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; ...;

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; responses &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub.routeChat(outgoingNotes);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; note &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; responses) {
  print(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Got message &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${&lt;/span&gt;note.message&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; at &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${&lt;/span&gt;note.location.latitude&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;, &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${&lt;/span&gt;note
      .location.longitude&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The syntax for reading and writing here is very similar to our client-side and
server-side streaming methods. Although each side will always get the other&amp;rsquo;s
messages in the order they were written, both the client and server can read and
write in any order — the streams operate completely independently.&lt;/p&gt;
&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Work from the example directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; example/route_guide
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Get packages:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ dart pub get
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ dart bin/server.dart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;From a different terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ dart bin/client.dart
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;reporting-issues&#34;&gt;Reporting issues&lt;/h3&gt;
&lt;p&gt;If you find a problem with Dart gRPC, please &lt;a href=&#34;https://github.com/grpc/grpc-dart/issues/new&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;file an issue&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
in our issue tracker.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/go/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/go/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic Go programmer&amp;rsquo;s introduction to
working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a &lt;code&gt;.proto&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;Generate server and client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the Go gRPC API to write a simple client and server for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes that you have read the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and are familiar with
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
Note that the example in this tutorial uses the proto3 version of the protocol
buffers language: you can find out more in the &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and the
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/go-generated&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Go generated code
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;setup&#34;&gt;Setup&lt;/h3&gt;
&lt;p&gt;You should have already installed the tools needed to generate client and server
interface code &amp;ndash; if you haven&amp;rsquo;t, see the &lt;a href=&#34;../quickstart/#prerequisites&#34;&gt;Prerequisites&lt;/a&gt; section of &lt;a href=&#34;../quickstart/&#34;&gt;Quick
start&lt;/a&gt; for setup instructions.&lt;/p&gt;
&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-go&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-go/archive/v1.35.0.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.35.0 https://github.com/grpc/grpc-go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the example directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-go/examples/route_guide
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Our first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to
define the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
For the complete &lt;code&gt;.proto&lt;/code&gt; file, see
&lt;a href=&#34;https://github.com/grpc/grpc-go/blob/master/examples/route_guide/routeguide/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;routeguide/route_guide.proto&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in your .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;server-side streaming RPC&lt;/em&gt; where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;client-side streaming RPC&lt;/em&gt; where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our .proto file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;generating-client-and-server-code&#34;&gt;Generating client and server code&lt;/h3&gt;
&lt;p&gt;Next we need to generate the gRPC client and server interfaces from our &lt;code&gt;.proto&lt;/code&gt;
service definition. We do this using the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; with
a special gRPC Go plugin. This is similar to what we did in the &lt;a href=&#34;../quickstart/&#34;&gt;Quick start&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;From the &lt;code&gt;examples/route_guide&lt;/code&gt; directory, run the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ protoc --go_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;. --go_opt&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;paths&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;source_relative &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;    --go-grpc_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;. --go-grpc_opt&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;paths&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;source_relative &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;    routeguide/route_guide.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Running this command generates the following files in the
&lt;a href=&#34;https://github.com/grpc/grpc-go/blob/master/examples/route_guide/routeguide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;routeguide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; directory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;route_guide.pb.go&lt;/code&gt;, which contains all the protocol buffer code to
populate, serialize, and retrieve request and response message types.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;route_guide_grpc.pb.go&lt;/code&gt;, which contains the following:
&lt;ul&gt;
&lt;li&gt;An interface type (or &lt;em&gt;stub&lt;/em&gt;) for clients to call with the methods defined in
the &lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;li&gt;An interface type for servers to implement, also with the methods defined in
the &lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;server&#34;&gt;Creating the server&lt;/h3&gt;
&lt;p&gt;First let&amp;rsquo;s look at how we create a &lt;code&gt;RouteGuide&lt;/code&gt; server. If you&amp;rsquo;re only
interested in creating gRPC clients, you can skip this section and go straight
to &lt;a href=&#34;#client&#34;&gt;Creating the client&lt;/a&gt; (though you might find it interesting
anyway!).&lt;/p&gt;
&lt;p&gt;There are two parts to making our &lt;code&gt;RouteGuide&lt;/code&gt; service do its job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the service interface generated from our service definition:
doing the actual &amp;ldquo;work&amp;rdquo; of our service.&lt;/li&gt;
&lt;li&gt;Running a gRPC server to listen for requests from clients and dispatch them to
the right service implementation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find our example &lt;code&gt;RouteGuide&lt;/code&gt; server in
&lt;a href=&#34;https://github.com/grpc/grpc-go/tree/master/examples/route_guide/server/server.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;server/server.go&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
Let&amp;rsquo;s take a closer look at how it works.&lt;/p&gt;
&lt;h4 id=&#34;implementing-routeguide&#34;&gt;Implementing RouteGuide&lt;/h4&gt;
&lt;p&gt;As you can see, our server has a &lt;code&gt;routeGuideServer&lt;/code&gt; struct type that implements
the generated &lt;code&gt;RouteGuideServer&lt;/code&gt; interface:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;type&lt;/span&gt; routeGuideServer &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;struct&lt;/span&gt; {
        &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
}
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;routeGuideServer) &lt;span style=&#34;color:#c0f&#34;&gt;GetFeature&lt;/span&gt;(ctx context.Context, point &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;pb.Point) (&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;pb.Feature, &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;error&lt;/span&gt;) {
        &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
}
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;routeGuideServer) &lt;span style=&#34;color:#c0f&#34;&gt;ListFeatures&lt;/span&gt;(rect &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;error&lt;/span&gt; {
        &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
}
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;routeGuideServer) &lt;span style=&#34;color:#c0f&#34;&gt;RecordRoute&lt;/span&gt;(stream pb.RouteGuide_RecordRouteServer) &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;error&lt;/span&gt; {
        &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
}
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;routeGuideServer) &lt;span style=&#34;color:#c0f&#34;&gt;RouteChat&lt;/span&gt;(stream pb.RouteGuide_RouteChatServer) &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;error&lt;/span&gt; {
        &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
}
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;The &lt;code&gt;routeGuideServer&lt;/code&gt; implements all our service methods. Let&amp;rsquo;s look at the
simplest type first, &lt;code&gt;GetFeature&lt;/code&gt;, which just gets a &lt;code&gt;Point&lt;/code&gt; from the client and
returns the corresponding feature information from its database in a &lt;code&gt;Feature&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;routeGuideServer) &lt;span style=&#34;color:#c0f&#34;&gt;GetFeature&lt;/span&gt;(ctx context.Context, point &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;pb.Point) (&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;pb.Feature, &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;error&lt;/span&gt;) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; _, feature &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;range&lt;/span&gt; s.savedFeatures {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; proto.&lt;span style=&#34;color:#c0f&#34;&gt;Equal&lt;/span&gt;(feature.Location, point) {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; feature, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt;
    }
  }
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// No feature was found, return an unnamed feature
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;pb.Feature{Location: point}, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method is passed a context object for the RPC and the client&amp;rsquo;s &lt;code&gt;Point&lt;/code&gt;
protocol buffer request. It returns a &lt;code&gt;Feature&lt;/code&gt; protocol buffer object with the
response information and an &lt;code&gt;error&lt;/code&gt;. In the method we populate the &lt;code&gt;Feature&lt;/code&gt;
with the appropriate information, and then &lt;code&gt;return&lt;/code&gt; it along with an &lt;code&gt;nil&lt;/code&gt; error
to tell gRPC that we&amp;rsquo;ve finished dealing with the RPC and that the &lt;code&gt;Feature&lt;/code&gt; can
be returned to the client.&lt;/p&gt;
&lt;h5 id=&#34;server-side-streaming-rpc&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at one of our streaming RPCs. &lt;code&gt;ListFeatures&lt;/code&gt; is a server-side
streaming RPC, so we need to send back multiple &lt;code&gt;Feature&lt;/code&gt;s to our client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;routeGuideServer) &lt;span style=&#34;color:#c0f&#34;&gt;ListFeatures&lt;/span&gt;(rect &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;pb.Rectangle, stream pb.RouteGuide_ListFeaturesServer) &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;error&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; _, feature &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;range&lt;/span&gt; s.savedFeatures {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;inRange&lt;/span&gt;(feature.Location, rect) {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; stream.&lt;span style=&#34;color:#c0f&#34;&gt;Send&lt;/span&gt;(feature); err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; err
      }
    }
  }
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, instead of getting simple request and response objects in our
method parameters, this time we get a request object (the &lt;code&gt;Rectangle&lt;/code&gt; in which
our client wants to find &lt;code&gt;Feature&lt;/code&gt;s) and a special
&lt;code&gt;RouteGuide_ListFeaturesServer&lt;/code&gt; object to write our responses.&lt;/p&gt;
&lt;p&gt;In the method, we populate as many &lt;code&gt;Feature&lt;/code&gt; objects as we need to return,
writing them to the &lt;code&gt;RouteGuide_ListFeaturesServer&lt;/code&gt; using its &lt;code&gt;Send()&lt;/code&gt; method.
Finally, as in our simple RPC, we return a &lt;code&gt;nil&lt;/code&gt; error to tell gRPC that we&amp;rsquo;ve
finished writing responses. Should any error happen in this call, we return a
non-&lt;code&gt;nil&lt;/code&gt; error; the gRPC layer will translate it into an appropriate RPC status
to be sent on the wire.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at something a little more complicated: the client-side streaming
method &lt;code&gt;RecordRoute&lt;/code&gt;, where we get a stream of &lt;code&gt;Point&lt;/code&gt;s from the client and
return a single &lt;code&gt;RouteSummary&lt;/code&gt; with information about their trip. As you can
see, this time the method doesn&amp;rsquo;t have a request parameter at all. Instead, it
gets a &lt;code&gt;RouteGuide_RecordRouteServer&lt;/code&gt; stream, which the server can use to both
read &lt;em&gt;and&lt;/em&gt; write messages - it can receive client messages using its &lt;code&gt;Recv()&lt;/code&gt;
method and return its single response using its &lt;code&gt;SendAndClose()&lt;/code&gt; method.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;routeGuideServer) &lt;span style=&#34;color:#c0f&#34;&gt;RecordRoute&lt;/span&gt;(stream pb.RouteGuide_RecordRouteServer) &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;error&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; pointCount, featureCount, distance &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; lastPoint &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;pb.Point
  startTime &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; time.&lt;span style=&#34;color:#c0f&#34;&gt;Now&lt;/span&gt;()
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; {
    point, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; stream.&lt;span style=&#34;color:#c0f&#34;&gt;Recv&lt;/span&gt;()
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; io.EOF {
      endTime &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; time.&lt;span style=&#34;color:#c0f&#34;&gt;Now&lt;/span&gt;()
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; stream.&lt;span style=&#34;color:#c0f&#34;&gt;SendAndClose&lt;/span&gt;(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;pb.RouteSummary{
        PointCount:   pointCount,
        FeatureCount: featureCount,
        Distance:     distance,
        ElapsedTime:  &lt;span style=&#34;color:#366&#34;&gt;int32&lt;/span&gt;(endTime.&lt;span style=&#34;color:#c0f&#34;&gt;Sub&lt;/span&gt;(startTime).&lt;span style=&#34;color:#c0f&#34;&gt;Seconds&lt;/span&gt;()),
      })
    }
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; err
    }
    pointCount&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; _, feature &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;range&lt;/span&gt; s.savedFeatures {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; proto.&lt;span style=&#34;color:#c0f&#34;&gt;Equal&lt;/span&gt;(feature.Location, point) {
        featureCount&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;
      }
    }
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; lastPoint &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
      distance &lt;span style=&#34;color:#555&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;calcDistance&lt;/span&gt;(lastPoint, point)
    }
    lastPoint = point
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the method body we use the &lt;code&gt;RouteGuide_RecordRouteServer&lt;/code&gt;&amp;rsquo;s &lt;code&gt;Recv()&lt;/code&gt; method
to repeatedly read in our client&amp;rsquo;s requests to a request object (in this case a
&lt;code&gt;Point&lt;/code&gt;) until there are no more messages: the server needs to check the error
returned from &lt;code&gt;Read()&lt;/code&gt; after each call. If this is &lt;code&gt;nil&lt;/code&gt;, the stream is still
good and it can continue reading; if it&amp;rsquo;s &lt;code&gt;io.EOF&lt;/code&gt; the message stream has ended
and the server can return its &lt;code&gt;RouteSummary&lt;/code&gt;. If it has any other value, we
return the error &amp;ldquo;as is&amp;rdquo; so that it&amp;rsquo;ll be translated to an RPC status by the
gRPC layer.&lt;/p&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;func&lt;/span&gt; (s &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;routeGuideServer) &lt;span style=&#34;color:#c0f&#34;&gt;RouteChat&lt;/span&gt;(stream pb.RouteGuide_RouteChatServer) &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;error&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; {
    in, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; stream.&lt;span style=&#34;color:#c0f&#34;&gt;Recv&lt;/span&gt;()
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; io.EOF {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt;
    }
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; err
    }
    key &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;serialize&lt;/span&gt;(in.Location)
                &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt; &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// look for notes to be sent to client
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; _, note &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;range&lt;/span&gt; s.routeNotes[key] {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; stream.&lt;span style=&#34;color:#c0f&#34;&gt;Send&lt;/span&gt;(note); err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; err
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This time we get a &lt;code&gt;RouteGuide_RouteChatServer&lt;/code&gt; stream that, as in our
client-side streaming example, can be used to read and write messages. However,
this time we return values via our method&amp;rsquo;s stream while the client is still
writing messages to &lt;em&gt;their&lt;/em&gt; message stream.&lt;/p&gt;
&lt;p&gt;The syntax for reading and writing here is very similar to our client-streaming
method, except the server uses the stream&amp;rsquo;s &lt;code&gt;Send()&lt;/code&gt; method rather than
&lt;code&gt;SendAndClose()&lt;/code&gt; because it&amp;rsquo;s writing multiple responses. Although each side
will always get the other&amp;rsquo;s messages in the order they were written, both the
client and server can read and write in any order — the streams operate
completely independently.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-server&#34;&gt;Starting the server&lt;/h4&gt;
&lt;p&gt;Once we&amp;rsquo;ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for our &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;flag.&lt;span style=&#34;color:#c0f&#34;&gt;Parse&lt;/span&gt;()
lis, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; net.&lt;span style=&#34;color:#c0f&#34;&gt;Listen&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;, fmt.&lt;span style=&#34;color:#c0f&#34;&gt;Sprintf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;localhost:%d&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;port))
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
  log.&lt;span style=&#34;color:#c0f&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;failed to listen: %v&amp;#34;&lt;/span&gt;, err)
}
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; opts []grpc.ServerOption
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
grpcServer &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; grpc.&lt;span style=&#34;color:#c0f&#34;&gt;NewServer&lt;/span&gt;(opts&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;)
pb.&lt;span style=&#34;color:#c0f&#34;&gt;RegisterRouteGuideServer&lt;/span&gt;(grpcServer, &lt;span style=&#34;color:#c0f&#34;&gt;newServer&lt;/span&gt;())
grpcServer.&lt;span style=&#34;color:#c0f&#34;&gt;Serve&lt;/span&gt;(lis)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To build and start a server, we:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Specify the port we want to use to listen for client requests using:&lt;br&gt;
&lt;code&gt;lis, err := net.Listen(...)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Create an instance of the gRPC server using &lt;code&gt;grpc.NewServer(...)&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Register our service implementation with the gRPC server.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;Serve()&lt;/code&gt; on the server with our port details to do a blocking wait
until the process is killed or &lt;code&gt;Stop()&lt;/code&gt; is called.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, we&amp;rsquo;ll look at creating a Go client for our &lt;code&gt;RouteGuide&lt;/code&gt;
service. You can see our complete example client code in
&lt;a href=&#34;https://github.com/grpc/grpc-go/tree/master/examples/route_guide/client/client.go&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-go/examples/route_guide/client/client.go&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;creating-a-stub&#34;&gt;Creating a stub&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a gRPC &lt;em&gt;channel&lt;/em&gt; to communicate
with the server. We create this by passing the server address and port number to
&lt;code&gt;grpc.Dial()&lt;/code&gt; as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; opts []grpc.DialOption
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
conn, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; grpc.&lt;span style=&#34;color:#c0f&#34;&gt;Dial&lt;/span&gt;(&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;serverAddr, opts&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;)
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
  &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
}
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;defer&lt;/span&gt; conn.&lt;span style=&#34;color:#c0f&#34;&gt;Close&lt;/span&gt;()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can use &lt;code&gt;DialOptions&lt;/code&gt; to set the auth credentials (for example, TLS, GCE
credentials, or JWT credentials) in &lt;code&gt;grpc.Dial&lt;/code&gt; when a service requires them.
The &lt;code&gt;RouteGuide&lt;/code&gt; service doesn&amp;rsquo;t require any credentials.&lt;/p&gt;
&lt;p&gt;Once the gRPC &lt;em&gt;channel&lt;/em&gt; is setup, we need a client &lt;em&gt;stub&lt;/em&gt; to perform RPCs. We
get it using the &lt;code&gt;NewRouteGuideClient&lt;/code&gt; method provided by the &lt;code&gt;pb&lt;/code&gt; package
generated from the example &lt;code&gt;.proto&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;client &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; pb.&lt;span style=&#34;color:#c0f&#34;&gt;NewRouteGuideClient&lt;/span&gt;(conn)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how we call our service methods. Note that in gRPC-Go, RPCs
operate in a blocking/synchronous mode, which means that the RPC call waits for
the server to respond, and will either return a response or an error.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc-1&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; is nearly as straightforward as calling a
local method.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;feature, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; client.&lt;span style=&#34;color:#c0f&#34;&gt;GetFeature&lt;/span&gt;(context.&lt;span style=&#34;color:#c0f&#34;&gt;Background&lt;/span&gt;(), &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;pb.Point{&lt;span style=&#34;color:#f60&#34;&gt;409146138&lt;/span&gt;, &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;746188906&lt;/span&gt;})
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
  &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we call the method on the stub we got earlier. In our method
parameters we create and populate a request protocol buffer object (in our case
&lt;code&gt;Point&lt;/code&gt;). We also pass a &lt;code&gt;context.Context&lt;/code&gt; object which lets us change our RPC&amp;rsquo;s
behavior if necessary, such as time-out/cancel an RPC in flight. If the call
doesn&amp;rsquo;t return an error, then we can read the response information from the
server from the first return value.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;log.&lt;span style=&#34;color:#c0f&#34;&gt;Println&lt;/span&gt;(feature)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;server-side-streaming-rpc-1&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Here&amp;rsquo;s where we call the server-side streaming method &lt;code&gt;ListFeatures&lt;/code&gt;, which
returns a stream of geographical &lt;code&gt;Feature&lt;/code&gt;s. If you&amp;rsquo;ve already read &lt;a href=&#34;#server&#34;&gt;Creating
the server&lt;/a&gt; some of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;rect &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;pb.Rectangle{ &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt; }  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// initialize a pb.Rectangle
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;stream, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; client.&lt;span style=&#34;color:#c0f&#34;&gt;ListFeatures&lt;/span&gt;(context.&lt;span style=&#34;color:#c0f&#34;&gt;Background&lt;/span&gt;(), rect)
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
  &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
}
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; {
    feature, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; stream.&lt;span style=&#34;color:#c0f&#34;&gt;Recv&lt;/span&gt;()
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; io.EOF {
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;break&lt;/span&gt;
    }
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
        log.&lt;span style=&#34;color:#c0f&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;%v.ListFeatures(_) = _, %v&amp;#34;&lt;/span&gt;, client, err)
    }
    log.&lt;span style=&#34;color:#c0f&#34;&gt;Println&lt;/span&gt;(feature)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As in the simple RPC, we pass the method a context and a request. However,
instead of getting a response object back, we get back an instance of
&lt;code&gt;RouteGuide_ListFeaturesClient&lt;/code&gt;. The client can use the
&lt;code&gt;RouteGuide_ListFeaturesClient&lt;/code&gt; stream to read the server&amp;rsquo;s responses.&lt;/p&gt;
&lt;p&gt;We use the &lt;code&gt;RouteGuide_ListFeaturesClient&lt;/code&gt;&amp;rsquo;s &lt;code&gt;Recv()&lt;/code&gt; method to repeatedly read
in the server&amp;rsquo;s responses to a response protocol buffer object (in this case a
&lt;code&gt;Feature&lt;/code&gt;) until there are no more messages: the client needs to check the error
&lt;code&gt;err&lt;/code&gt; returned from &lt;code&gt;Recv()&lt;/code&gt; after each call. If &lt;code&gt;nil&lt;/code&gt;, the stream is still good
and it can continue reading; if it&amp;rsquo;s &lt;code&gt;io.EOF&lt;/code&gt; then the message stream has ended;
otherwise there must be an RPC error, which is passed over through &lt;code&gt;err&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc-1&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;The client-side streaming method &lt;code&gt;RecordRoute&lt;/code&gt; is similar to the server-side
method, except that we only pass the method a context and get a
&lt;code&gt;RouteGuide_RecordRouteClient&lt;/code&gt; stream back, which we can use to both write &lt;em&gt;and&lt;/em&gt;
read messages.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Create a random number of random points
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;r &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; rand.&lt;span style=&#34;color:#c0f&#34;&gt;New&lt;/span&gt;(rand.&lt;span style=&#34;color:#c0f&#34;&gt;NewSource&lt;/span&gt;(time.&lt;span style=&#34;color:#c0f&#34;&gt;Now&lt;/span&gt;().&lt;span style=&#34;color:#c0f&#34;&gt;UnixNano&lt;/span&gt;()))
pointCount &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;int&lt;/span&gt;(r.&lt;span style=&#34;color:#c0f&#34;&gt;Int31n&lt;/span&gt;(&lt;span style=&#34;color:#f60&#34;&gt;100&lt;/span&gt;)) &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Traverse at least two points
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; points []&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;pb.Point
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;; i &amp;lt; pointCount; i&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt; {
  points = &lt;span style=&#34;color:#366&#34;&gt;append&lt;/span&gt;(points, &lt;span style=&#34;color:#c0f&#34;&gt;randomPoint&lt;/span&gt;(r))
}
log.&lt;span style=&#34;color:#c0f&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Traversing %d points.&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#366&#34;&gt;len&lt;/span&gt;(points))
stream, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; client.&lt;span style=&#34;color:#c0f&#34;&gt;RecordRoute&lt;/span&gt;(context.&lt;span style=&#34;color:#c0f&#34;&gt;Background&lt;/span&gt;())
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
  log.&lt;span style=&#34;color:#c0f&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;%v.RecordRoute(_) = _, %v&amp;#34;&lt;/span&gt;, client, err)
}
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; _, point &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;range&lt;/span&gt; points {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; stream.&lt;span style=&#34;color:#c0f&#34;&gt;Send&lt;/span&gt;(point); err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
    log.&lt;span style=&#34;color:#c0f&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;%v.Send(%v) = %v&amp;#34;&lt;/span&gt;, stream, point, err)
  }
}
reply, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; stream.&lt;span style=&#34;color:#c0f&#34;&gt;CloseAndRecv&lt;/span&gt;()
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
  log.&lt;span style=&#34;color:#c0f&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;%v.CloseAndRecv() got error %v, want %v&amp;#34;&lt;/span&gt;, stream, err, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt;)
}
log.&lt;span style=&#34;color:#c0f&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Route summary: %v&amp;#34;&lt;/span&gt;, reply)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;RouteGuide_RecordRouteClient&lt;/code&gt; has a &lt;code&gt;Send()&lt;/code&gt; method that we can use to send
requests to the server. Once we&amp;rsquo;ve finished writing our client&amp;rsquo;s requests to the
stream using &lt;code&gt;Send()&lt;/code&gt;, we need to call &lt;code&gt;CloseAndRecv()&lt;/code&gt; on the stream to let
gRPC know that we&amp;rsquo;ve finished writing and are expecting to receive a response.
We get our RPC status from the &lt;code&gt;err&lt;/code&gt; returned from &lt;code&gt;CloseAndRecv()&lt;/code&gt;. If the
status is &lt;code&gt;nil&lt;/code&gt;, then the first return value from &lt;code&gt;CloseAndRecv()&lt;/code&gt; will be a
valid server response.&lt;/p&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc-1&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;. As in the
case of &lt;code&gt;RecordRoute&lt;/code&gt;, we only pass the method a context object and get back a
stream that we can use to both write and read messages. However, this time we
return values via our method&amp;rsquo;s stream while the server is still writing messages
to &lt;em&gt;their&lt;/em&gt; message stream.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;stream, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; client.&lt;span style=&#34;color:#c0f&#34;&gt;RouteChat&lt;/span&gt;(context.&lt;span style=&#34;color:#c0f&#34;&gt;Background&lt;/span&gt;())
waitc &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;make&lt;/span&gt;(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;chan&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;struct&lt;/span&gt;{})
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;go&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;func&lt;/span&gt;() {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; {
    in, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; stream.&lt;span style=&#34;color:#c0f&#34;&gt;Recv&lt;/span&gt;()
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; io.EOF {
      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// read done.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#366&#34;&gt;close&lt;/span&gt;(waitc)
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt;
    }
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
      log.&lt;span style=&#34;color:#c0f&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Failed to receive a note : %v&amp;#34;&lt;/span&gt;, err)
    }
    log.&lt;span style=&#34;color:#c0f&#34;&gt;Printf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Got message %s at point(%d, %d)&amp;#34;&lt;/span&gt;, in.Message, in.Location.Latitude, in.Location.Longitude)
  }
}()
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; _, note &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;range&lt;/span&gt; notes {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; stream.&lt;span style=&#34;color:#c0f&#34;&gt;Send&lt;/span&gt;(note); err &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;nil&lt;/span&gt; {
    log.&lt;span style=&#34;color:#c0f&#34;&gt;Fatalf&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Failed to send a note: %v&amp;#34;&lt;/span&gt;, err)
  }
}
stream.&lt;span style=&#34;color:#c0f&#34;&gt;CloseSend&lt;/span&gt;()
&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;-&lt;/span&gt;waitc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The syntax for reading and writing here is very similar to our client-side
streaming method, except we use the stream&amp;rsquo;s &lt;code&gt;CloseSend()&lt;/code&gt; method once we&amp;rsquo;ve
finished our call. Although each side will always get the other&amp;rsquo;s messages in
the order they were written, both the client and server can read and write in
any order — the streams operate completely independently.&lt;/p&gt;
&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Execute the following commands from the &lt;code&gt;examples/route_guide&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ go run server/server.go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ go run client/client.go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You&amp;rsquo;ll see output like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nocode&#34; data-lang=&#34;nocode&#34;&gt;Getting feature for point (409146138, -746188906)
name:&amp;quot;Berkshire Valley Management Area Trail, Jefferson, NJ, USA&amp;quot; location:&amp;lt;latitude:409146138 longitude:-746188906 &amp;gt;
Getting feature for point (0, 0)
location:&amp;lt;&amp;gt;
Looking for features within lo:&amp;lt;latitude:400000000 longitude:-750000000 &amp;gt; hi:&amp;lt;latitude:420000000 longitude:-730000000 &amp;gt;
name:&amp;quot;Patriots Path, Mendham, NJ 07945, USA&amp;quot; location:&amp;lt;latitude:407838351 longitude:-746143763 &amp;gt;
...
name:&amp;quot;3 Hasta Way, Newton, NJ 07860, USA&amp;quot; location:&amp;lt;latitude:410248224 longitude:-747127767 &amp;gt;
Traversing 56 points.
Route summary: point_count:56 distance:497013163
Got message First message at point(0, 1)
Got message Second message at point(0, 2)
Got message Third message at point(0, 3)
Got message First message at point(0, 1)
Got message Fourth message at point(0, 1)
Got message Second message at point(0, 2)
Got message Fifth message at point(0, 2)
Got message Third message at point(0, 3)
Got message Sixth message at point(0, 3)
&lt;/code&gt;&lt;/pre&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    We&amp;rsquo;ve omitted timestamps from the client and server trace output shown in this
page.

&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/java/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/java/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic Java programmer&amp;rsquo;s introduction to
working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Generate server and client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the Java gRPC API to write a simple client and server for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes that you have read the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and are familiar
with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. Note
that the example in this tutorial uses the
&lt;a href=&#34;https://github.com/google/protobuf/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; version of the protocol
buffers language: you can find out more in the &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/java-generated&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Java
generated code
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;example-code-and-setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code for our tutorial is in
&lt;a href=&#34;https://github.com/grpc/grpc-java/tree/master/examples/src/main/java/io/grpc/examples/routeguide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc/grpc-java/examples/src/main/java/io/grpc/examples/routeguide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
To download the example, clone the latest release in &lt;code&gt;grpc-java&lt;/code&gt; repository by
running the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.38.0 https://github.com/grpc/grpc-java.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then change your current directory to &lt;code&gt;grpc-java/examples&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-java/examples
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Our first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to
define the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. You can
see the complete .proto file in
&lt;a href=&#34;https://github.com/grpc/grpc-java/blob/master/examples/src/main/proto/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-java/examples/src/main/proto/route_guide.proto&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As we&amp;rsquo;re generating Java code in this example, we&amp;rsquo;ve specified a &lt;code&gt;java_package&lt;/code&gt;
file option in our .proto:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;option&lt;/span&gt; java_package &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;io.grpc.examples.routeguide&amp;#34;&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This specifies the package we want to use for our generated Java classes. If no
explicit &lt;code&gt;java_package&lt;/code&gt; option is given in the .proto file, then by default the
proto package (specified using the &amp;ldquo;package&amp;rdquo; keyword) will be used. However,
proto packages generally do not make good Java packages since proto packages are
not expected to start with reverse domain names. If we generate code in another
language from this .proto, the &lt;code&gt;java_package&lt;/code&gt; option has no effect.&lt;/p&gt;
&lt;p&gt;To define a service, we specify a named &lt;code&gt;service&lt;/code&gt; in the .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then we define &lt;code&gt;rpc&lt;/code&gt; methods inside our service definition, specifying their
request and response types. gRPC lets you define four kinds of service methods,
all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;server-side streaming RPC&lt;/em&gt; where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;client-side streaming RPC&lt;/em&gt; where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;generating-client-and-server-code&#34;&gt;Generating client and server code&lt;/h3&gt;
&lt;p&gt;Next we need to generate the gRPC client and server interfaces from our .proto
service definition. We do this using the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; with
a special gRPC Java plugin. You need to use the
&lt;a href=&#34;https://github.com/google/protobuf/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; compiler (which supports
both proto2 and proto3 syntax) in order to generate gRPC services.&lt;/p&gt;
&lt;p&gt;When using Gradle or Maven, the protoc build plugin can generate the necessary
code as part of the build. You can refer to the &lt;a href=&#34;https://github.com/grpc/grpc-java/blob/master/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-java README&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; for
how to generate code from your own &lt;code&gt;.proto&lt;/code&gt; files.&lt;/p&gt;
&lt;p&gt;The following classes are generated from our service definition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Feature.java&lt;/code&gt;, &lt;code&gt;Point.java&lt;/code&gt;, &lt;code&gt;Rectangle.java&lt;/code&gt;, and others which contain all
the protocol buffer code to populate, serialize, and retrieve our request and
response message types.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteGuideGrpc.java&lt;/code&gt; which contains (along with some other useful code):
&lt;ul&gt;
&lt;li&gt;a base class for &lt;code&gt;RouteGuide&lt;/code&gt; servers to implement,
&lt;code&gt;RouteGuideGrpc.RouteGuideImplBase&lt;/code&gt;, with all the methods defined in the
&lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;stub&lt;/em&gt; classes that clients can use to talk to a &lt;code&gt;RouteGuide&lt;/code&gt; server.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;server&#34;&gt;Creating the server&lt;/h3&gt;
&lt;p&gt;First let&amp;rsquo;s look at how we create a &lt;code&gt;RouteGuide&lt;/code&gt; server. If you&amp;rsquo;re only
interested in creating gRPC clients, you can skip this section and go straight
to &lt;a href=&#34;#client&#34;&gt;Creating the client&lt;/a&gt; (though you might find it interesting
anyway!).&lt;/p&gt;
&lt;p&gt;There are two parts to making our &lt;code&gt;RouteGuide&lt;/code&gt; service do its job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Overriding the service base class generated from our service definition: doing
the actual &amp;ldquo;work&amp;rdquo; of our service.&lt;/li&gt;
&lt;li&gt;Running a gRPC server to listen for requests from clients and return the
service responses.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find our example &lt;code&gt;RouteGuide&lt;/code&gt; server in
&lt;a href=&#34;https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideServer.java&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-java/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideServer.java&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
Let&amp;rsquo;s take a closer look at how it works.&lt;/p&gt;
&lt;h4 id=&#34;implementing-routeguide&#34;&gt;Implementing RouteGuide&lt;/h4&gt;
&lt;p&gt;As you can see, our server has a &lt;code&gt;RouteGuideService&lt;/code&gt; class that extends the
generated &lt;code&gt;RouteGuideGrpc.RouteGuideImplBase&lt;/code&gt; abstract class:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;RouteGuideService&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;extends&lt;/span&gt; RouteGuideGrpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;RouteGuideImplBase&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RouteGuideService&lt;/code&gt; implements all our service methods. Let&amp;rsquo;s
look at the simplest method first, &lt;code&gt;GetFeature()&lt;/code&gt;, which just gets a &lt;code&gt;Point&lt;/code&gt; from
the client and returns the corresponding feature information from its database
in a &lt;code&gt;Feature&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;getFeature&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Point request&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; responseObserver&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;checkFeature&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;));&lt;/span&gt;
  responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; Feature &lt;span style=&#34;color:#c0f&#34;&gt;checkFeature&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Point location&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Feature feature &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; features&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;feature&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; location&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; feature&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; location&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;())&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; feature&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// No feature was found, return an unnamed feature.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; Feature&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setName&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;location&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;getFeature()&lt;/code&gt; method takes two parameters:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Point&lt;/code&gt;: the request&lt;/li&gt;
&lt;li&gt;&lt;code&gt;StreamObserver&amp;lt;Feature&amp;gt;&lt;/code&gt;: a response observer, which is a special interface
for the server to call with its response.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To return our response to the client and complete the call:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We construct and populate a &lt;code&gt;Feature&lt;/code&gt; response object to return to the
client, as specified in our service definition. In this example, we do this
in a separate private &lt;code&gt;checkFeature()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;We use the response observer&amp;rsquo;s &lt;code&gt;onNext()&lt;/code&gt; method to return the &lt;code&gt;Feature&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;We use the response observer&amp;rsquo;s &lt;code&gt;onCompleted()&lt;/code&gt; method to specify that we&amp;rsquo;ve
finished dealing with the RPC.&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;server-side-streaming-rpc&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Next let&amp;rsquo;s look at one of our streaming RPCs. &lt;code&gt;ListFeatures&lt;/code&gt; is a server-side
streaming RPC, so we need to send back multiple &lt;code&gt;Feature&lt;/code&gt;s to our client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; Collection&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; features&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;

&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;

&lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;listFeatures&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Rectangle request&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; responseObserver&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; left &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; min&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLo&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getHi&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; right &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; max&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLo&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getHi&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; top &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; max&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLo&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getHi&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; bottom &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; min&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLo&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getHi&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Feature feature &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; features&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(!&lt;/span&gt;RouteGuideUtil&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;exists&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;feature&lt;span style=&#34;color:#555&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;continue&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; lat &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; feature&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; lon &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; feature&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;lon &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;=&lt;/span&gt; left &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; lon &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;=&lt;/span&gt; right &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; lat &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;=&lt;/span&gt; bottom &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; lat &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;=&lt;/span&gt; top&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;feature&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Like the simple RPC, this method gets a request object (the &lt;code&gt;Rectangle&lt;/code&gt; in which
our client wants to find &lt;code&gt;Feature&lt;/code&gt;s) and a &lt;code&gt;StreamObserver&lt;/code&gt; response observer.&lt;/p&gt;
&lt;p&gt;This time, we get as many &lt;code&gt;Feature&lt;/code&gt; objects as we need to return to the client
(in this case, we select them from the service&amp;rsquo;s feature collection based on
whether they&amp;rsquo;re inside our request &lt;code&gt;Rectangle&lt;/code&gt;), and write them each in turn to
the response observer using its &lt;code&gt;onNext()&lt;/code&gt; method. Finally, as in our simple
RPC, we use the response observer&amp;rsquo;s &lt;code&gt;onCompleted()&lt;/code&gt; method to tell gRPC that
we&amp;rsquo;ve finished writing responses.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at something a little more complicated: the client-side streaming
method &lt;code&gt;RecordRoute()&lt;/code&gt;, where we get a stream of &lt;code&gt;Point&lt;/code&gt;s from the client and
return a single &lt;code&gt;RouteSummary&lt;/code&gt; with information about their trip.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;recordRoute&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteSummary&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; responseObserver&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; pointCount&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; featureCount&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; distance&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
    Point previous&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;long&lt;/span&gt; startTime &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; System&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;nanoTime&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Point point&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      pointCount&lt;span style=&#34;color:#555&#34;&gt;++;&lt;/span&gt;
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteGuideUtil&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;exists&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;checkFeature&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;point&lt;span style=&#34;color:#555&#34;&gt;)))&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        featureCount&lt;span style=&#34;color:#555&#34;&gt;++;&lt;/span&gt;
      &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// For each point after the first, add the incremental distance from the previous point
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// to the total distance value.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;previous &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        distance &lt;span style=&#34;color:#555&#34;&gt;+=&lt;/span&gt; calcDistance&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;previous&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; point&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
      &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
      previous &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; point&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onError&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Throwable t&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Level&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;WARNING&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Encountered error in recordRoute&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; t&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;long&lt;/span&gt; seconds &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; NANOSECONDS&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;toSeconds&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;System&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;nanoTime&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt; startTime&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
      responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteSummary&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setPointCount&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;pointCount&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt;
          &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setFeatureCount&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;featureCount&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setDistance&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;distance&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt;
          &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setElapsedTime&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;((&lt;/span&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; seconds&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
      responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;};&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, like the previous method types our method gets a
&lt;code&gt;StreamObserver&lt;/code&gt; response observer parameter, but this time it returns a
&lt;code&gt;StreamObserver&lt;/code&gt; for the client to write its &lt;code&gt;Point&lt;/code&gt;s.&lt;/p&gt;
&lt;p&gt;In the method body we instantiate an anonymous &lt;code&gt;StreamObserver&lt;/code&gt; to return, in
which we:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Override the &lt;code&gt;onNext()&lt;/code&gt; method to get features and other information each time
the client writes a &lt;code&gt;Point&lt;/code&gt; to the message stream.&lt;/li&gt;
&lt;li&gt;Override the &lt;code&gt;onCompleted()&lt;/code&gt; method (called when the &lt;em&gt;client&lt;/em&gt; has finished
writing messages) to populate and build our &lt;code&gt;RouteSummary&lt;/code&gt;. We then call our
method&amp;rsquo;s own response observer&amp;rsquo;s &lt;code&gt;onNext()&lt;/code&gt; with our &lt;code&gt;RouteSummary&lt;/code&gt;, and then
call its &lt;code&gt;onCompleted()&lt;/code&gt; method to finish the call from the server side.&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;routeChat&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; responseObserver&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteNote note&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      List&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; notes &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; getOrCreateNotes&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;note&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;

      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Respond with all previous notes at this location.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteNote prevNote &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; notes&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;toArray&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; RouteNote&lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;0&lt;span style=&#34;color:#555&#34;&gt;]))&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;prevNote&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
      &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Now add the new note to the list
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      notes&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;add&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;note&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onError&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Throwable t&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Level&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;WARNING&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Encountered error in routeChat&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; t&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      responseObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;};&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As with our client-side streaming example, we both get and return a
&lt;code&gt;StreamObserver&lt;/code&gt; response observer, except this time we return values via our
method&amp;rsquo;s response observer while the client is still writing messages to &lt;em&gt;their&lt;/em&gt;
message stream. The syntax for reading and writing here is exactly the same as
for our client-streaming and server-streaming methods. Although each side will
always get the other&amp;rsquo;s messages in the order they were written, both the client
and server can read and write in any order — the streams operate completely
independently.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-server&#34;&gt;Starting the server&lt;/h4&gt;
&lt;p&gt;Once we&amp;rsquo;ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for our &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;RouteGuideServer&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; port&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; URL featureFile&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throws&lt;/span&gt; IOException &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;ServerBuilder&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;forPort&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;port&lt;span style=&#34;color:#555&#34;&gt;),&lt;/span&gt; port&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; RouteGuideUtil&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;parseFeatures&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;featureFile&lt;span style=&#34;color:#555&#34;&gt;));&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/** Create a RouteGuide server using serverBuilder as a base and features as data. */&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;RouteGuideServer&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;ServerBuilder&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; serverBuilder&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; port&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; Collection&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; features&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;port&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; port&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
  server &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; serverBuilder&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;addService&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; RouteGuideService&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;features&lt;span style=&#34;color:#555&#34;&gt;))&lt;/span&gt;
      &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;start&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throws&lt;/span&gt; IOException &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  server&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;start&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
  logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;info&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Server started, listening on &amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; port&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
 &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we build and start our server using a &lt;code&gt;ServerBuilder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To do this, we:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Specify the address and port we want to use to listen for client requests
using the builder&amp;rsquo;s &lt;code&gt;forPort()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Create an instance of our service implementation class &lt;code&gt;RouteGuideService&lt;/code&gt;
and pass it to the builder&amp;rsquo;s &lt;code&gt;addService()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;build()&lt;/code&gt; and &lt;code&gt;start()&lt;/code&gt; on the builder to create and start an RPC server
for our service.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, we&amp;rsquo;ll look at creating a client for our &lt;code&gt;RouteGuide&lt;/code&gt;
service. You can see our complete example client code in
&lt;a href=&#34;https://github.com/grpc/grpc-java/blob/master/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideClient.java&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-java/examples/src/main/java/io/grpc/examples/routeguide/RouteGuideClient.java&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;instantiating-a-stub&#34;&gt;Instantiating a stub&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a &lt;em&gt;stub&lt;/em&gt;, or rather, two stubs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;em&gt;blocking/synchronous&lt;/em&gt; stub: this means that the RPC call waits for the
server to respond, and will either return a response or raise an exception.&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;non-blocking/asynchronous&lt;/em&gt; stub that makes non-blocking calls to the
server, where the response is returned asynchronously. You can make certain
types of streaming call only using the asynchronous stub.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;First we need to create a gRPC &lt;em&gt;channel&lt;/em&gt; for our stub, specifying the server
address and port we want to connect to:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;RouteGuideClient&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;String host&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; port&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;ManagedChannelBuilder&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;forAddress&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;host&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; port&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;usePlaintext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/** Construct client for accessing RouteGuide server using the existing channel. */&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;RouteGuideClient&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;ManagedChannelBuilder&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;?&amp;gt;&lt;/span&gt; channelBuilder&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  channel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; channelBuilder&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
  blockingStub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; RouteGuideGrpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBlockingStub&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;channel&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
  asyncStub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; RouteGuideGrpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newStub&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;channel&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We use a &lt;code&gt;ManagedChannelBuilder&lt;/code&gt; to create the channel.&lt;/p&gt;
&lt;p&gt;Now we can use the channel to create our stubs using the &lt;code&gt;newStub&lt;/code&gt; and
&lt;code&gt;newBlockingStub&lt;/code&gt; methods provided in the &lt;code&gt;RouteGuideGrpc&lt;/code&gt; class we generated
from our .proto.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;blockingStub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; RouteGuideGrpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBlockingStub&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;channel&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
asyncStub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; RouteGuideGrpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newStub&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;channel&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how we call our service methods.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc-1&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; on the blocking stub is as straightforward
as calling a local method.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Point request &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; Point&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;lat&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;lon&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
Feature feature&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  feature &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; blockingStub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getFeature&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;StatusRuntimeException e&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Level&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;WARNING&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;RPC failed: {0}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; e&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getStatus&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We create and populate a request protocol buffer object (in our case &lt;code&gt;Point&lt;/code&gt;),
pass it to the &lt;code&gt;getFeature()&lt;/code&gt; method on our blocking stub, and get back a
&lt;code&gt;Feature&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If an error occurs, it is encoded as a &lt;code&gt;Status&lt;/code&gt;, which we can obtain from the
&lt;code&gt;StatusRuntimeException&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&#34;server-side-streaming-rpc-1&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Next, let&amp;rsquo;s look at a server-side streaming call to &lt;code&gt;ListFeatures&lt;/code&gt;, which
returns a stream of geographical &lt;code&gt;Feature&lt;/code&gt;s:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Rectangle request &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
    Rectangle&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLo&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;lowLat&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;lowLon&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;())&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setHi&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;hiLat&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;hiLon&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
Iterator&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; features&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  features &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; blockingStub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;listFeatures&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;StatusRuntimeException e&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Level&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;WARNING&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;RPC failed: {0}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; e&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getStatus&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, it&amp;rsquo;s very similar to the simple RPC we just looked at, except
instead of returning a single &lt;code&gt;Feature&lt;/code&gt;, the method returns an &lt;code&gt;Iterator&lt;/code&gt; that
the client can use to read all the returned &lt;code&gt;Feature&lt;/code&gt;s.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc-1&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Now for something a little more complicated: the client-side streaming method
&lt;code&gt;RecordRoute&lt;/code&gt;, where we send a stream of &lt;code&gt;Point&lt;/code&gt;s to the server and get back a
single &lt;code&gt;RouteSummary&lt;/code&gt;. For this method we need to use the asynchronous stub. If
you&amp;rsquo;ve already read &lt;a href=&#34;#server&#34;&gt;Creating the server&lt;/a&gt; some of this may look very
familiar - asynchronous streaming RPCs are implemented in a similar way on both
sides.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;recordRoute&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;List&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; features&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; numPoints&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throws&lt;/span&gt; InterruptedException &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  info&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;*** RecordRoute&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; CountDownLatch finishLatch &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; CountDownLatch&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
  StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteSummary&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; responseObserver &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteSummary&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteSummary summary&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      info&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished trip with {0} points. Passed {1} features. &amp;#34;&lt;/span&gt;
          &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Travelled {2} meters. It took {3} seconds.&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; summary&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getPointCount&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt;
          summary&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getFeatureCount&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; summary&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getDistance&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; summary&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getElapsedTime&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onError&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Throwable t&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      Status status &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; Status&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;fromThrowable&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;t&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
      logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Level&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;WARNING&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;RecordRoute Failed: {0}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; status&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
      finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;countDown&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      info&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished RecordRoute&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
      finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;countDown&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;};&lt;/span&gt;

  StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; requestObserver &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; asyncStub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;recordRoute&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;responseObserver&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Send numPoints points randomly selected from the features list.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    Random rand &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Random&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt; numPoints&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;i&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; index &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; rand&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;nextInt&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;features&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;size&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
      Point point &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; features&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;index&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
      info&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Visiting point {0}, {1}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; RouteGuideUtil&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;point&lt;span style=&#34;color:#555&#34;&gt;),&lt;/span&gt;
          RouteGuideUtil&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;point&lt;span style=&#34;color:#555&#34;&gt;));&lt;/span&gt;
      requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;point&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sleep for a bit before sending the next one.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      Thread&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;sleep&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;rand&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;nextInt&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;1000&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; 500&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getCount&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RPC completed or errored before we finished sending.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sending further requests won&amp;#39;t error, but they will just be thrown away.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
      &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RuntimeException e&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Cancel RPC
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onError&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;e&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throw&lt;/span&gt; e&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Mark the end of requests
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;

  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Receiving happens asynchronously
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; TimeUnit&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;MINUTES&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, to call this method we need to create a &lt;code&gt;StreamObserver&lt;/code&gt;, which
implements a special interface for the server to call with its &lt;code&gt;RouteSummary&lt;/code&gt;
response. In our &lt;code&gt;StreamObserver&lt;/code&gt; we:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Override the &lt;code&gt;onNext()&lt;/code&gt; method to print out the returned information when the
server writes a &lt;code&gt;RouteSummary&lt;/code&gt; to the message stream.&lt;/li&gt;
&lt;li&gt;Override the &lt;code&gt;onCompleted()&lt;/code&gt; method (called when the &lt;em&gt;server&lt;/em&gt; has completed
the call on its side) to reduce a &lt;code&gt;CountDownLatch&lt;/code&gt; that we can check to see if
the server has finished writing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We then pass the &lt;code&gt;StreamObserver&lt;/code&gt; to the asynchronous stub&amp;rsquo;s &lt;code&gt;recordRoute()&lt;/code&gt;
method and get back our own &lt;code&gt;StreamObserver&lt;/code&gt; request observer to write our
&lt;code&gt;Point&lt;/code&gt;s to send to the server.  Once we&amp;rsquo;ve finished writing points, we use the
request observer&amp;rsquo;s &lt;code&gt;onCompleted()&lt;/code&gt; method to tell gRPC that we&amp;rsquo;ve finished
writing on the client side. Once we&amp;rsquo;re done, we check our &lt;code&gt;CountDownLatch&lt;/code&gt; to
check that the server has completed on its side.&lt;/p&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc-1&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;routeChat&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throws&lt;/span&gt; Exception &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
  info&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;*** RoutChat&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; CountDownLatch finishLatch &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; CountDownLatch&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
  StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; requestObserver &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
      asyncStub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;routeChat&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteNote note&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
          info&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Got message \&amp;#34;{0}\&amp;#34; at {1}, {2}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; note&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; note&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt;
              &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; note&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

        &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onError&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Throwable t&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
          Status status &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; Status&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;fromThrowable&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;t&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
          logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;log&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Level&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;WARNING&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;RouteChat Failed: {0}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; status&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
          finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;countDown&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

        &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
          info&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished RouteChat&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
          finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;countDown&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
      &lt;span style=&#34;color:#555&#34;&gt;});&lt;/span&gt;

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    RouteNote&lt;span style=&#34;color:#555&#34;&gt;[]&lt;/span&gt; requests &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;newNote&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;First message&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;),&lt;/span&gt; newNote&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Second message&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#555&#34;&gt;),&lt;/span&gt;
            newNote&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Third message&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;),&lt;/span&gt; newNote&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Fourth message&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#555&#34;&gt;)};&lt;/span&gt;

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteNote request &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; requests&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
      info&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Sending message \&amp;#34;{0}\&amp;#34; at {1}, {2}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt;
          &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
      requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RuntimeException e&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Cancel RPC
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onError&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;e&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throw&lt;/span&gt; e&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Mark the end of requests
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;

  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Receiving happens asynchronously
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; TimeUnit&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;MINUTES&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As with our client-side streaming example, we both get and return a
&lt;code&gt;StreamObserver&lt;/code&gt; response observer, except this time we send values via our
method&amp;rsquo;s response observer while the server is still writing messages to &lt;em&gt;their&lt;/em&gt;
message stream. The syntax for reading and writing here is exactly the same as
for our client-streaming method. Although each side will always get the other&amp;rsquo;s
messages in the order they were written, both the client and server can read and
write in any order — the streams operate completely independently.&lt;/p&gt;
&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Follow the instructions in the &lt;a href=&#34;https://github.com/grpc/grpc-java/blob/master/examples/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example directory README&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; to build and run the
client and server.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/kotlin/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/kotlin/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic Kotlin programmer&amp;rsquo;s introduction to
working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a &lt;code&gt;.proto&lt;/code&gt; file.&lt;/li&gt;
&lt;li&gt;Generate server and client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the Kotlin gRPC API to write a simple client and server for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You should already be familiar gRPC and protocol buffers; if not, see
&lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and the proto3 &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Language guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;setup&#34;&gt;Setup&lt;/h3&gt;
&lt;p&gt;This tutorial has the same &lt;a href=&#34;../quickstart/#prerequisites&#34;&gt;prerequisites&lt;/a&gt; as the &lt;a href=&#34;../quickstart/&#34;&gt;Quick start&lt;/a&gt;. Install the
necessary SDKs and tools before proceeding.&lt;/p&gt;
&lt;h3 id=&#34;get-the-example-code&#34;&gt;Get the example code&lt;/h3&gt;
&lt;p&gt;The example code is part of the &lt;a href=&#34;https://github.com/grpc/grpc-kotlin&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-kotlin&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repo.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/archive/master.zip&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Download the repo as a zip file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and unzip it, or clone
the repo:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone https://github.com/grpc/grpc-kotlin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Change to the examples directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-kotlin/examples
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Your first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to define
the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you&amp;rsquo;d like to follow along by looking at the complete &lt;code&gt;.proto&lt;/code&gt; file, see
&lt;code&gt;routeguide/route_guide.proto&lt;/code&gt; from the
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/protos/src/main/proto/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protos/src/main/proto/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in the &lt;code&gt;.proto&lt;/code&gt; file like
this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;server-side streaming RPC&lt;/em&gt; where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;client-side streaming RPC&lt;/em&gt; where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used by the service methods &amp;ndash; for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;generating-client-and-server-code&#34;&gt;Generating client and server code&lt;/h3&gt;
&lt;p&gt;Next, you need to generate the gRPC client and server interfaces from the &lt;code&gt;.proto&lt;/code&gt;
service definition. You do this using the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; with
special gRPC Kotlin and Java plugins.&lt;/p&gt;
&lt;p&gt;When using Gradle or Maven, the &lt;code&gt;protoc&lt;/code&gt; build plugin will generate the
necessary code as part of the build process. For a Gradle example, see
&lt;a href=&#34;https://github.com/grpc/grpc-kotlin/blob/master/examples/stub/build.gradle.kts&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;stub/build.gradle.kts&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If you run &lt;code&gt;./gradlew installDist&lt;/code&gt; from the examples folder, the following files
are generated from the service definition &amp;ndash; you&amp;rsquo;ll find the generated files in
subdirectories below &lt;code&gt;stub/build/generated/source/proto/main&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Feature.java&lt;/code&gt;, &lt;code&gt;Point.java&lt;/code&gt;, &lt;code&gt;Rectangle.java&lt;/code&gt;, and others, which contain all
the protocol buffer code to populate, serialize, and retrieve our request and
response message types.&lt;/p&gt;
&lt;p&gt;You&amp;rsquo;ll find these files in the &lt;code&gt;java/io/grpc/examples/routeguide&lt;/code&gt;
subdirectory.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;RouteGuideOuterClassGrpcKt.kt&lt;/code&gt;, which contains, among other things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RouteGuideGrpcKt.RouteGuideCoroutineImplBase&lt;/code&gt;, an abstract base class for
&lt;code&gt;RouteGuide&lt;/code&gt; servers to implement, with all the methods defined in the
&lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteGuideGrpcKt.RouteGuideCoroutineStub&lt;/code&gt;, a class that clients use to talk
to a &lt;code&gt;RouteGuide&lt;/code&gt; server.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You&amp;rsquo;ll find this Kotlin file under &lt;code&gt;grpckt/io/grpc/examples/routeguide&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;server&#34;&gt;Creating the server&lt;/h3&gt;
&lt;p&gt;First consider how to create a &lt;code&gt;RouteGuide&lt;/code&gt; server. If you&amp;rsquo;re only interested in
creating gRPC clients, skip ahead to &lt;a href=&#34;#client&#34;&gt;Creating the client&lt;/a&gt; &amp;ndash; though
you might find this section interesting anyway!&lt;/p&gt;
&lt;p&gt;There are two main things that you need to do when creating a &lt;code&gt;RouteGuide&lt;/code&gt;
server:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Extend the &lt;code&gt;RouteGuideCoroutineImplBase&lt;/code&gt; service base class to do the actual
service work.&lt;/li&gt;
&lt;li&gt;Create and run a gRPC server to listen for requests from clients and return
the service responses.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Open the example &lt;code&gt;RouteGuide&lt;/code&gt; server code in &lt;code&gt;routeguide/RouteGuideServer.kt&lt;/code&gt;
under the &lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/server/src/main/kotlin/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;server/src/main/kotlin/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder.&lt;/p&gt;
&lt;h4 id=&#34;implementing-routeguide&#34;&gt;Implementing RouteGuide&lt;/h4&gt;
&lt;p&gt;As you can see, the server has a &lt;code&gt;RouteGuideService&lt;/code&gt; class that extends the
generated service base class:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;RouteGuideService&lt;/span&gt;(
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; features: Collection&amp;lt;Feature&amp;gt;,
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
) : RouteGuideGrpcKt.RouteGuideCoroutineImplBase() {
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;RouteGuideService&lt;/code&gt; implements all the service methods. Consider the simplest
method first, &lt;code&gt;GetFeature()&lt;/code&gt;, which gets a &lt;code&gt;Point&lt;/code&gt; from the client and returns a
&lt;code&gt;Feature&lt;/code&gt; built from the corresponding feature information in the database.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;getFeature&lt;/span&gt;(request: Point): Feature =
    features.find { &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;it&lt;/span&gt;.location &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; request } &lt;span style=&#34;color:#555&#34;&gt;?:&lt;/span&gt;
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// No feature was found, return an unnamed feature.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    Feature.newBuilder().apply { location = request }.build()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method accepts a client&amp;rsquo;s &lt;code&gt;Point&lt;/code&gt; message request as a parameter, and it
returns a &lt;code&gt;Feature&lt;/code&gt; message as a response. The method populates the &lt;code&gt;Feature&lt;/code&gt;
with the appropriate information, and then returns it to the gRPC framework,
which sends it back to the client.&lt;/p&gt;
&lt;h5 id=&#34;server-side-streaming-rpc&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Next, consider one of the streaming RPCs. &lt;code&gt;ListFeatures()&lt;/code&gt; is a server-side
streaming RPC, so the server gets to send back multiple &lt;code&gt;Feature&lt;/code&gt; messages to
the client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;listFeatures&lt;/span&gt;(request: Rectangle): Flow&amp;lt;Feature&amp;gt; =
  features.asFlow().filter { &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;it&lt;/span&gt;.exists() &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;it&lt;/span&gt;.location &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; request }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The request object is a &lt;code&gt;Rectangle&lt;/code&gt;. The server collects, and returns to the
client, all the &lt;code&gt;Feature&lt;/code&gt; objects in its collection that are inside the given
&lt;code&gt;Rectangle&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Now consider something a little more complicated: the client-side streaming
method &lt;code&gt;RecordRoute()&lt;/code&gt;, where the server gets a stream of &lt;code&gt;Point&lt;/code&gt; objects from
the client, and returns a single &lt;code&gt;RouteSummary&lt;/code&gt; with information about their
trip through the given points.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;recordRoute&lt;/span&gt;(requests: Flow&amp;lt;Point&amp;gt;): RouteSummary {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; pointCount = &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; featureCount = &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; distance = &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; previous: Point? = &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; stopwatch = Stopwatch.createStarted(ticker)
  requests.collect { request &lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;
    pointCount&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (getFeature(request).exists()) {
      featureCount&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;
    }
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; prev = previous
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (prev &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;) {
      distance &lt;span style=&#34;color:#555&#34;&gt;+=&lt;/span&gt; prev distanceTo request
    }
    previous = request
  }
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; RouteSummary.newBuilder().apply {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;.pointCount = pointCount
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;.featureCount = featureCount
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;.distance = distance
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;this&lt;/span&gt;.elapsedTime = Durations.fromMicros(stopwatch.elapsed(TimeUnit.MICROSECONDS))
  }.build()
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The request parameter is a stream of client request messages represented as a
Kotlin &lt;a href=&#34;https://kotlinlang.org/docs/reference/coroutines/flow.html#flows&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Flow&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. The server returns a single response just like in the simple
RPC case.&lt;/p&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, consider the bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;override&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;routeChat&lt;/span&gt;(requests: Flow&amp;lt;RouteNote&amp;gt;): Flow&amp;lt;RouteNote&amp;gt; =
  flow {
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// could use transform, but it&amp;#39;s currently experimental
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    requests.collect { note &lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; notes: MutableList&amp;lt;RouteNote&amp;gt; = routeNotes.computeIfAbsent(note.location) {
        Collections.synchronizedList(mutableListOf&amp;lt;RouteNote&amp;gt;())
      }
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (prevNote &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; notes.toTypedArray()) { &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// thread-safe snapshot
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;        emit(prevNote)
      }
      notes &lt;span style=&#34;color:#555&#34;&gt;+=&lt;/span&gt; note
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Similar to the client-side streaming example, for this method, the server gets a
stream of &lt;code&gt;RouteNote&lt;/code&gt; objects as a &lt;code&gt;Flow&lt;/code&gt;. However, this time the server returns
&lt;code&gt;RouteNote&lt;/code&gt; instances via the method&amp;rsquo;s returned stream &lt;em&gt;while&lt;/em&gt; the client is still
writing messages to &lt;em&gt;its&lt;/em&gt; message stream.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-server&#34;&gt;Starting the server&lt;/h4&gt;
&lt;p&gt;Once all the server&amp;rsquo;s methods are implemented, you need code to create a gRPC
server instance, something like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;RouteGuideServer&lt;/span&gt;(
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; port: Int,
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; features: Collection&amp;lt;Feature&amp;gt; = Database.features(),
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; server: Server =
      ServerBuilder.forPort(port)
        .addService(RouteGuideService(features)).build()
) {

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;start&lt;/span&gt;() {
    server.start()
    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Server started, listening on &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;$port&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
  }
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
}

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;main&lt;/span&gt;(args: Array&amp;lt;String&amp;gt;) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; port = &lt;span style=&#34;color:#f60&#34;&gt;8980&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; server = RouteGuideServer(port)
  server.start()
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A server instance is built and started using a &lt;code&gt;ServerBuilder&lt;/code&gt; as follows:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Specify the port, that the server will listen for client requests on, using
&lt;code&gt;forPort()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Create an instance of the service implementation class &lt;code&gt;RouteGuideService&lt;/code&gt;
and pass it to the builder&amp;rsquo;s &lt;code&gt;addService()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;build()&lt;/code&gt; and &lt;code&gt;start()&lt;/code&gt; on the builder to create and start an RPC server
for the route guide service.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, you&amp;rsquo;ll look at a client for the &lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/p&gt;
&lt;p&gt;For the complete client code, open &lt;code&gt;routeguide/RouteGuideClient.kt&lt;/code&gt;
under the &lt;a href=&#34;https://github.com/grpc/grpc-kotlin/tree/master/examples/client/src/main/kotlin/io/grpc/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;client/src/main/kotlin/io/grpc/examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder.&lt;/p&gt;
&lt;h4 id=&#34;instantiating-a-stub&#34;&gt;Instantiating a stub&lt;/h4&gt;
&lt;p&gt;To call service methods, you first need to create a gRPC &lt;em&gt;channel&lt;/em&gt; using a
&lt;code&gt;ManagedChannelBuilder&lt;/code&gt;. You&amp;rsquo;ll use this channel to communicate with the server.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; channel = ManagedChannelBuilder.forAddress(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;localhost&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#f60&#34;&gt;8980&lt;/span&gt;).usePlaintext().build()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once the gRPC channel is setup, you need a client &lt;em&gt;stub&lt;/em&gt; to perform RPCs. Get it
by instantiating &lt;code&gt;RouteGuideCoroutineStub&lt;/code&gt;, which is available from the package
that was generated from the &lt;code&gt;.proto&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; stub = RouteGuideCoroutineStub(channel)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now consider how you&amp;rsquo;ll call service methods.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc-1&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature()&lt;/code&gt; is as straightforward as calling a local
method:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; request = point(latitude, longitude)
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; feature = stub.getFeature(request)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The stub method &lt;code&gt;getFeature()&lt;/code&gt; executes the corresponding RPC, suspending until
the RPC completes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;getFeature&lt;/span&gt;(latitude: Int, longitude: Int) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; request = point(latitude, longitude)
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; feature = stub.getFeature(request)
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (feature.exists()) { &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt; }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;server-side-streaming-rpc-1&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Next, consider the server-side streaming &lt;code&gt;ListFeatures()&lt;/code&gt; RPC, which returns a
stream of geographical features:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;listFeatures&lt;/span&gt;(lowLat: Int, lowLon: Int, hiLat: Int, hiLon: Int) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; request = Rectangle.newBuilder()
    .setLo(point(lowLat, lowLon))
    .setHi(point(hiLat, hiLon))
    .build()
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; i = &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;
  stub.listFeatures(request).collect { feature &lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;
    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Result #&lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${i++}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;: &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;$feature&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The stub &lt;code&gt;listFeatures()&lt;/code&gt; method returns a stream of features in the form of a
&lt;code&gt;Flow&amp;lt;Feature&amp;gt;&lt;/code&gt; instance. The flow &lt;code&gt;collect()&lt;/code&gt; method allows the client to
processes the server-provided features as they become available.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc-1&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;The client-side streaming &lt;code&gt;RecordRoute()&lt;/code&gt; RPC sends a stream of &lt;code&gt;Point&lt;/code&gt; messages
to the server and gets back a single &lt;code&gt;RouteSummary&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;recordRoute&lt;/span&gt;(points: Flow&amp;lt;Point&amp;gt;) {
  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;*** RecordRoute&amp;#34;&lt;/span&gt;)
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; summary = stub.recordRoute(points)
  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished trip with &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${summary.pointCount}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; points.&amp;#34;&lt;/span&gt;)
  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Passed &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${summary.featureCount}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; features.&amp;#34;&lt;/span&gt;)
  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Travelled &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${summary.distance}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; meters.&amp;#34;&lt;/span&gt;)
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; duration = summary.elapsedTime.seconds
  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;It took &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;$duration&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; seconds.&amp;#34;&lt;/span&gt;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method generates the route points from the points associated with a randomly
selected list of features. The random selection is taken from a previously
loaded feature collection:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;generateRoutePoints&lt;/span&gt;(features: List&amp;lt;Feature&amp;gt;, numPoints: Int): Flow&amp;lt;Point&amp;gt; = flow {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (i &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1.&lt;/span&gt;.numPoints) {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; feature = features.random(random)
    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Visiting point &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${feature.location.toStr()}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
    emit(feature.location)
    delay(timeMillis = random.nextLong(&lt;span style=&#34;color:#f60&#34;&gt;500L&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;1500L&lt;/span&gt;))
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that flow points are emitted lazily, that is, only once the server requests
them. Once a point has been emitted to the flow, the point generator suspends
until the server requests the next point.&lt;/p&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc-1&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, consider the bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;. As in the case
of &lt;code&gt;RecordRoute()&lt;/code&gt;, you pass to the stub method a stream that you use to write
the request messages to; like in &lt;code&gt;ListFeatures()&lt;/code&gt;, you get back a stream that
you can use to read response messages from. However, this time you send values
via our method&amp;rsquo;s stream while the server is also writing messages to &lt;em&gt;its&lt;/em&gt;
message stream.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-kotlin&#34; data-lang=&#34;kotlin&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;suspend&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;routeChat&lt;/span&gt;() {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; requests = generateOutgoingNotes()
  stub.routeChat(requests).collect { note &lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;
    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Got message &lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${note.message}&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; at &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${note.location.toStr()}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
  }
  println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished RouteChat&amp;#34;&lt;/span&gt;)
}

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;fun&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;generateOutgoingNotes&lt;/span&gt;(): Flow&amp;lt;RouteNote&amp;gt; = flow {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;val&lt;/span&gt; notes = listOf(&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* ... */&lt;/span&gt;)
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (note &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;in&lt;/span&gt; notes) {
    println(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Sending message &lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${note.message}&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt; at &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;${note.location.toStr()}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
    emit(note)
    delay(&lt;span style=&#34;color:#f60&#34;&gt;500&lt;/span&gt;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The syntax for reading and writing here is very similar to the client-side and
server-side streaming methods. Although each side will always get the other&amp;rsquo;s
messages in the order they were written, both the client and server can read and
write in any order —- the streams operate completely independently.&lt;/p&gt;
&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Run the following commands from the &lt;code&gt;grpc-kotlin/examples&lt;/code&gt; directory:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Compile the client and server&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./gradlew installDist
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./server/build/install/server/bin/route-guide-server
Server started, listening on &lt;span style=&#34;color:#f60&#34;&gt;8980&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;From another terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./client/build/install/client/bin/route-guide-client
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;You&amp;rsquo;ll see client output like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-nocode&#34; data-lang=&#34;nocode&#34;&gt;*** GetFeature: lat=409146138 lon=-746188906
Found feature called &amp;quot;Berkshire Valley Management Area Trail, Jefferson, NJ, USA&amp;quot; at 40.9146138, -74.6188906
*** GetFeature: lat=0 lon=0
Found no feature at 0.0, 0.0
*** ListFeatures: lowLat=400000000 lowLon=-750000000 hiLat=420000000 liLon=-730000000
Result #1: name: &amp;quot;Patriots Path, Mendham, NJ 07945, USA&amp;quot;
location {
  latitude: 407838351
  longitude: -746143763
}
...
Result #64: name: &amp;quot;3 Hasta Way, Newton, NJ 07860, USA&amp;quot;
location {
  latitude: 410248224
  longitude: -747127767
}

*** RecordRoute
Visiting point 40.0066188, -74.6793294
...
Visiting point 40.4318328, -74.0835638
Finished trip with 10 points.
Passed 3 features.
Travelled 93238790 meters.
It took 9 seconds.
*** RouteChat
Sending message &amp;quot;First message&amp;quot; at 0.0, 0.0
Sending message &amp;quot;Second message&amp;quot; at 0.0, 0.0
Got message &amp;quot;First message&amp;quot; at 0.0, 0.0
Sending message &amp;quot;Third message&amp;quot; at 1.0, 0.0
Sending message &amp;quot;Fourth message&amp;quot; at 1.0, 1.0
Sending message &amp;quot;Last message&amp;quot; at 0.0, 0.0
Got message &amp;quot;First message&amp;quot; at 0.0, 0.0
Got message &amp;quot;Second message&amp;quot; at 0.0, 0.0
Finished RouteChat
&lt;/code&gt;&lt;/pre&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/node/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/node/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic Node.js programmer&amp;rsquo;s introduction
to working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Use the Node.js gRPC API to write a simple client and server for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes that you have read the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and are familiar
with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. Note
that the example in this tutorial uses the
&lt;a href=&#34;https://github.com/google/protobuf/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; version of the protocol
buffers language. You can find out more in the
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;example-code-and-setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code for our tutorial is in
&lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/node/dynamic_codegen/route_guide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc/grpc/examples/node/dynamic_codegen/route_guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
As you&amp;rsquo;ll see if you look at the repository, there&amp;rsquo;s also a very similar-looking
example in
&lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/node/static_codegen/route_guide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc/grpc/examples/node/static_codegen/route_guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
We have two versions of our route guide example because there are two ways to
generate the code needed to work with protocol buffers in Node.js - one approach
uses &lt;code&gt;Protobuf.js&lt;/code&gt; to dynamically generate the code at runtime, the other uses
code statically generated using the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt;. The
examples behave identically, and either server can be used with either client.
As suggested by the directory name, we&amp;rsquo;ll be using the version with dynamically
generated code in this document, but feel free to look at the static code
example too.&lt;/p&gt;
&lt;p&gt;To download the example, clone the &lt;code&gt;grpc&lt;/code&gt; repository by running the following
command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.37.1 https://github.com/grpc/grpc
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then change your current directory to &lt;code&gt;examples/node&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; examples/node
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You also should have the relevant tools installed to generate the server and
client interface code - if you don&amp;rsquo;t already, follow the setup instructions in
&lt;a href=&#34;../quickstart/&#34;&gt;Quick start&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Our first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to
define the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. You can
see the complete .proto file in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/protos/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;examples/protos/route_guide.proto&lt;/code&gt;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in your .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;server-side streaming RPC&lt;/em&gt; where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;client-side streaming RPC&lt;/em&gt; where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;loading-service-descriptors-from-proto-files&#34;&gt;Loading service descriptors from proto files&lt;/h3&gt;
&lt;p&gt;The Node.js library dynamically generates service descriptors and client stub
definitions from &lt;code&gt;.proto&lt;/code&gt; files loaded at runtime.&lt;/p&gt;
&lt;p&gt;To load a &lt;code&gt;.proto&lt;/code&gt; file, simply &lt;code&gt;require&lt;/code&gt; the gRPC proto loader library and use its
&lt;code&gt;loadSync()&lt;/code&gt; method, then pass the output to the gRPC library&amp;rsquo;s &lt;code&gt;loadPackageDefinition&lt;/code&gt; method:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; PROTO_PATH &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; __dirname &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;/../../../protos/route_guide.proto&amp;#39;&lt;/span&gt;;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; grpc &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; require(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;@grpc/grpc-js&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; protoLoader &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; require(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;@grpc/proto-loader&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Suggested options for similarity to existing grpc.load behavior
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; packageDefinition &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; protoLoader.loadSync(
    PROTO_PATH,
    {keepCase&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;true&lt;/span&gt;,
     longs&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;String&lt;/span&gt;,
     enums&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;String&lt;/span&gt;,
     defaults&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;true&lt;/span&gt;,
     oneofs&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;true&lt;/span&gt;
    });
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; protoDescriptor &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; grpc.loadPackageDefinition(packageDefinition);
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The protoDescriptor object has the full package hierarchy
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; routeguide &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; protoDescriptor.routeguide;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once you&amp;rsquo;ve done this, the stub constructor is in the &lt;code&gt;routeguide&lt;/code&gt; namespace
(&lt;code&gt;protoDescriptor.routeguide.RouteGuide&lt;/code&gt;) and the service descriptor (which is
used to create a server) is a property of the stub
(&lt;code&gt;protoDescriptor.routeguide.RouteGuide.service&lt;/code&gt;);&lt;/p&gt;
&lt;h3 id=&#34;server&#34;&gt;Creating the server&lt;/h3&gt;
&lt;p&gt;First let&amp;rsquo;s look at how we create a &lt;code&gt;RouteGuide&lt;/code&gt; server. If you&amp;rsquo;re only
interested in creating gRPC clients, you can skip this section and go straight
to &lt;a href=&#34;#client&#34;&gt;Creating the client&lt;/a&gt; (though you might find it interesting
anyway!).&lt;/p&gt;
&lt;p&gt;There are two parts to making our &lt;code&gt;RouteGuide&lt;/code&gt; service do its job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the service interface generated from our service definition:
doing the actual &amp;ldquo;work&amp;rdquo; of our service.&lt;/li&gt;
&lt;li&gt;Running a gRPC server to listen for requests from clients and return the
service responses.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find our example &lt;code&gt;RouteGuide&lt;/code&gt; server in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/node/dynamic_codegen/route_guide/route_guide_server.js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/node/dynamic_codegen/route_guide/route_guide_server.js&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
Let&amp;rsquo;s take a closer look at how it works.&lt;/p&gt;
&lt;h4 id=&#34;implementing-routeguide&#34;&gt;Implementing RouteGuide&lt;/h4&gt;
&lt;p&gt;As you can see, our server has a &lt;code&gt;Server&lt;/code&gt; constructor generated from the
&lt;code&gt;RouteGuide.service&lt;/code&gt; descriptor object&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; Server &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; grpc.Server();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In this case we&amp;rsquo;re implementing the &lt;em&gt;asynchronous&lt;/em&gt; version of &lt;code&gt;RouteGuide&lt;/code&gt;,
which provides our default gRPC server behavior.&lt;/p&gt;
&lt;p&gt;The functions in &lt;code&gt;route_guide_server.js&lt;/code&gt; implement all our service methods.
Let&amp;rsquo;s look at the simplest type first, &lt;code&gt;getFeature&lt;/code&gt;, which just gets a &lt;code&gt;Point&lt;/code&gt;
from the client and returns the corresponding feature information from its
database in a &lt;code&gt;Feature&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; checkFeature(point) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; feature;
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Check if there is already a feature object for the given point
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; i &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt; feature_list.length; i&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;) {
    feature &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; feature_list[i];
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (feature.location.latitude &lt;span style=&#34;color:#555&#34;&gt;===&lt;/span&gt; point.latitude &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        feature.location.longitude &lt;span style=&#34;color:#555&#34;&gt;===&lt;/span&gt; point.longitude) {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; feature;
    }
  }
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; name &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;;
  feature &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; {
    name&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; name,
    location&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; point
  };
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; feature;
}
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; getFeature(call, callback) {
  callback(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;, checkFeature(call.request));
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method is passed a call object for the RPC, which has the &lt;code&gt;Point&lt;/code&gt; parameter
as a property, and a callback to which we can pass our returned &lt;code&gt;Feature&lt;/code&gt;. In
the method body we populate a &lt;code&gt;Feature&lt;/code&gt; corresponding to the given point and
pass it to the callback, with a null first parameter to indicate that there is
no error.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s look at something a bit more complicated - a streaming RPC.
&lt;code&gt;listFeatures&lt;/code&gt; is a server-side streaming RPC, so we need to send back multiple
&lt;code&gt;Feature&lt;/code&gt;s to our client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; listFeatures(call) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; lo &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; call.request.lo;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; hi &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; call.request.hi;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; left &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; _.min([lo.longitude, hi.longitude]);
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; right &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; _.max([lo.longitude, hi.longitude]);
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; top &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; _.max([lo.latitude, hi.latitude]);
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; bottom &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; _.min([lo.latitude, hi.latitude]);
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// For each feature, check if it is in the given bounding box
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  _.each(feature_list, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(feature) {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (feature.name &lt;span style=&#34;color:#555&#34;&gt;===&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;) {
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt;;
    }
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (feature.location.longitude &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;=&lt;/span&gt; left &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        feature.location.longitude &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;=&lt;/span&gt; right &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        feature.location.latitude &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;=&lt;/span&gt; bottom &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        feature.location.latitude &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;=&lt;/span&gt; top) {
      call.write(feature);
    }
  });
  call.end();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, instead of getting the call object and callback in our method
parameters, this time we get a &lt;code&gt;call&lt;/code&gt; object that implements the &lt;code&gt;Writable&lt;/code&gt;
interface. In the method, we create as many &lt;code&gt;Feature&lt;/code&gt; objects as we need to
return, writing them to the &lt;code&gt;call&lt;/code&gt; using its &lt;code&gt;write()&lt;/code&gt; method. Finally, we call
&lt;code&gt;call.end()&lt;/code&gt; to indicate that we have sent all messages.&lt;/p&gt;
&lt;p&gt;If you look at the client-side streaming method &lt;code&gt;RecordRoute&lt;/code&gt; you&amp;rsquo;ll see it&amp;rsquo;s
quite similar to the unary call, except this time the &lt;code&gt;call&lt;/code&gt; parameter
implements the &lt;code&gt;Reader&lt;/code&gt; interface. The &lt;code&gt;call&lt;/code&gt;&amp;rsquo;s &lt;code&gt;&#39;data&#39;&lt;/code&gt; event fires every time
there is new data, and the &lt;code&gt;&#39;end&#39;&lt;/code&gt; event fires when all data has been read. Like
the unary case, we respond by calling the callback&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;call.on(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(point) {
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Process user data
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;});
call.on(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
  callback(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;, result);
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; routeChat(call) {
  call.on(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(note) {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; key &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; pointKey(note.location);
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;/* For each note sent, respond with all previous notes that correspond to
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;     * the same point */&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (route_notes.hasOwnProperty(key)) {
      _.each(route_notes[key], &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(note) {
        call.write(note);
      });
    } &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;else&lt;/span&gt; {
      route_notes[key] &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [];
    }
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Then add the new note to the list
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    route_notes[key].push(JSON.parse(JSON.stringify(note)));
  });
  call.on(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
    call.end();
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This time we get a &lt;code&gt;call&lt;/code&gt; implementing &lt;code&gt;Duplex&lt;/code&gt; that can be used to read &lt;em&gt;and&lt;/em&gt;
write messages. The syntax for reading and writing here is exactly the same as
for our client-streaming and server-streaming methods. Although each side will
always get the other&amp;rsquo;s messages in the order they were written, both the client
and server can read and write in any order — the streams operate completely
independently.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-server&#34;&gt;Starting the server&lt;/h4&gt;
&lt;p&gt;Once we&amp;rsquo;ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for our &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; getServer() {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; server &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; grpc.Server();
  server.addService(routeguide.RouteGuide.service, {
    getFeature&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; getFeature,
    listFeatures&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; listFeatures,
    recordRoute&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; recordRoute,
    routeChat&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; routeChat
  });
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; server;
}
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; routeServer &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; getServer();
routeServer.bindAsync(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;0.0.0.0:50051&amp;#39;&lt;/span&gt;, grpc.ServerCredentials.createInsecure(), () =&amp;gt; {
  routeServer.start();
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we build and start our server with the following steps:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create a &lt;code&gt;Server&lt;/code&gt; constructor from the &lt;code&gt;RouteGuide&lt;/code&gt; service descriptor.&lt;/li&gt;
&lt;li&gt;Implement the service methods.&lt;/li&gt;
&lt;li&gt;Create an instance of the server by calling the &lt;code&gt;Server&lt;/code&gt; constructor with
the method implementations.&lt;/li&gt;
&lt;li&gt;Specify the address and port we want to use to listen for client requests
using the instance&amp;rsquo;s &lt;code&gt;bind()&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;start()&lt;/code&gt; on the instance to start the RPC server.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, we&amp;rsquo;ll look at creating a Node.js client for our &lt;code&gt;RouteGuide&lt;/code&gt;
service. You can see our complete example client code in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/node/dynamic_codegen/route_guide/route_guide_client.js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/node/dynamic_codegen/route_guide/route_guide_client.js&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;creating-a-stub&#34;&gt;Creating a stub&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a &lt;em&gt;stub&lt;/em&gt;. To do this, we just
need to call the RouteGuide stub constructor, specifying the server address and
port.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; routeguide.RouteGuide(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;localhost:50051&amp;#39;&lt;/span&gt;, grpc.credentials.createInsecure());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how we call our service methods. Note that all of these
methods are asynchronous: they use either events or callbacks to retrieve
results.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; is nearly as straightforward as calling a
local asynchronous method.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; point &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; {latitude&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;409146138&lt;/span&gt;, longitude&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;746188906&lt;/span&gt;};
stub.getFeature(point, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(err, feature) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (err) {
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// process error
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  } &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;else&lt;/span&gt; {
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// process feature
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we create and populate a request object. Finally, we call the
method on the stub, passing it the request and callback. If there is no error,
then we can read the response information from the server from our response
object.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;console.log(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Found feature called &amp;#34;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; feature.name &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&amp;#34; at &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt;
    feature.location.latitude&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;COORD_FACTOR &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt;
    feature.location.longitude&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;COORD_FACTOR);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;streaming-rpcs&#34;&gt;Streaming RPCs&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at our streaming methods. If you&amp;rsquo;ve already read &lt;a href=&#34;#server&#34;&gt;Creating the
server&lt;/a&gt; some of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides. Here&amp;rsquo;s where we call the server-side
streaming method &lt;code&gt;ListFeatures&lt;/code&gt;, which returns a stream of geographical
&lt;code&gt;Feature&lt;/code&gt;s:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; call &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; client.listFeatures(rectangle);
  call.on(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;data&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(feature) {
      console.log(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Found feature called &amp;#34;&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; feature.name &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&amp;#34; at &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt;
          feature.location.latitude&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;COORD_FACTOR &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt;
          feature.location.longitude&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;COORD_FACTOR);
  });
  call.on(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;end&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The server has finished sending
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  });
  call.on(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;error&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(e) {
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// An error has occurred and the stream has been closed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  });
  call.on(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;status&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(status) {
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// process status
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Instead of passing the method a request and callback, we pass it a request and
get a &lt;code&gt;Readable&lt;/code&gt; stream object back. The client can use the &lt;code&gt;Readable&lt;/code&gt;&amp;rsquo;s
&lt;code&gt;&#39;data&#39;&lt;/code&gt; event to read the server&amp;rsquo;s responses. This event fires with each
&lt;code&gt;Feature&lt;/code&gt; message object until there are no more messages. Errors in the &lt;code&gt;&#39;data&#39;&lt;/code&gt;
callback will not cause the stream to be closed. The &lt;code&gt;&#39;error&#39;&lt;/code&gt; event
indicates that an error has occurred and the stream has been closed. The
&lt;code&gt;&#39;end&#39;&lt;/code&gt; event indicates that the server has finished sending and no errors
occurred. Only one of &lt;code&gt;&#39;error&#39;&lt;/code&gt; or &lt;code&gt;&#39;end&#39;&lt;/code&gt; will be emitted. Finally, the
&lt;code&gt;&#39;status&#39;&lt;/code&gt; event fires when the server sends the status.&lt;/p&gt;
&lt;p&gt;The client-side streaming method &lt;code&gt;RecordRoute&lt;/code&gt; is similar, except there we pass
the method a callback and get back a &lt;code&gt;Writable&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; call &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; client.recordRoute(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(error, stats) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (error) {
    callback(error);
  }
  console.log(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Finished trip with&amp;#39;&lt;/span&gt;, stats.point_count, &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;points&amp;#39;&lt;/span&gt;);
  console.log(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Passed&amp;#39;&lt;/span&gt;, stats.feature_count, &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;features&amp;#39;&lt;/span&gt;);
  console.log(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Travelled&amp;#39;&lt;/span&gt;, stats.distance, &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;meters&amp;#39;&lt;/span&gt;);
  console.log(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;It took&amp;#39;&lt;/span&gt;, stats.elapsed_time, &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;seconds&amp;#39;&lt;/span&gt;);
});
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; pointSender(lat, lng) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(callback) {
    console.log(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Visiting point &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; lat&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;COORD_FACTOR &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;, &amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt;
        lng&lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt;COORD_FACTOR);
    call.write({
      latitude&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; lat,
      longitude&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; lng
    });
    _.delay(callback, _.random(&lt;span style=&#34;color:#f60&#34;&gt;500&lt;/span&gt;, &lt;span style=&#34;color:#f60&#34;&gt;1500&lt;/span&gt;));
  };
}
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; point_senders &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [];
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; i &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt; num_points; i&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;) {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; rand_point &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; feature_list[_.random(&lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;, feature_list.length &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;)];
  point_senders[i] &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; pointSender(rand_point.location.latitude,
                                 rand_point.location.longitude);
}
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;async&lt;/span&gt;.series(point_senders, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;() {
  call.end();
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Once we&amp;rsquo;ve finished writing our client&amp;rsquo;s requests to the stream using &lt;code&gt;write()&lt;/code&gt;,
we need to call &lt;code&gt;end()&lt;/code&gt; on the stream to let gRPC know that we&amp;rsquo;ve finished
writing. If the status is &lt;code&gt;OK&lt;/code&gt;, the &lt;code&gt;stats&lt;/code&gt; object will be populated with the
server&amp;rsquo;s response.&lt;/p&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;routeChat()&lt;/code&gt;. In this
case, we just pass a context to the method and get back a &lt;code&gt;Duplex&lt;/code&gt; stream
object, which we can use to both write and read messages.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; call &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; client.routeChat();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The syntax for reading and writing here is exactly the same as for our
client-streaming and server-streaming methods. Although each side will always
get the other&amp;rsquo;s messages in the order they were written, both the client and
server can read and write in any order — the streams operate completely
independently.&lt;/p&gt;
&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Build the client and server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ npm install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ node ./dynamic_codegen/route_guide/route_guide_server.js --db_path&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;./dynamic_codegen/route_guide/route_guide_db.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;From a different terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ node ./dynamic_codegen/route_guide/route_guide_client.js --db_path&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;./dynamic_codegen/route_guide/route_guide_db.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/objective-c/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/objective-c/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic Objective-C programmer&amp;rsquo;s
introduction to working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Generate client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the Objective-C gRPC API to write a simple client for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes a passing familiarity with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. Note
that the example in this tutorial uses the proto3 version of the protocol
buffers language: you can find out more in
the &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and the
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/objective-c-generated&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Objective-C generated code
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code for our tutorial is in
&lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/objective-c/route_guide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc/grpc/examples/objective-c/route_guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
To download the example, clone the &lt;code&gt;grpc&lt;/code&gt; repository by running the following
commands:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.37.1 https://github.com/grpc/grpc
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc
$ git submodule update --init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then change your current directory to &lt;code&gt;examples/objective-c/route_guide&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; examples/objective-c/route_guide
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;You also should have &lt;a href=&#34;https://cocoapods.org/#install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Cocoapods&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; installed, as
well as the relevant tools to generate the client library code (and a server in
another language, for testing). You can obtain the latter by following &lt;a href=&#34;https://github.com/grpc/homebrew-grpc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;these
setup instructions&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&#34;try&#34;&gt;Try it out!&lt;/h2&gt;
&lt;p&gt;To try the sample app, we need a gRPC server running locally. Let&amp;rsquo;s compile and
run, for example, the C++ server in this repository:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;pushd&lt;/span&gt; ../../cpp/route_guide
$ make
$ ./route_guide_server &amp;amp;
$ &lt;span style=&#34;color:#366&#34;&gt;popd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now have Cocoapods generate and install the client library for our .proto files:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ pod install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(This might have to compile OpenSSL, which takes around 15 minutes if Cocoapods
doesn&amp;rsquo;t have it yet on your computer&amp;rsquo;s cache).&lt;/p&gt;
&lt;p&gt;Finally, open the XCode workspace created by Cocoapods, and run the app. You can
check the calling code in &lt;code&gt;ViewControllers.m&lt;/code&gt; and see the results in XCode&amp;rsquo;s log
console.&lt;/p&gt;
&lt;p&gt;The next sections guide you step-by-step through how this proto service is
defined, how to generate a client library from it, and how to create an app that
uses that library.&lt;/p&gt;
&lt;h3 id=&#34;proto&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;First let&amp;rsquo;s look at how the service we&amp;rsquo;re using is defined. A gRPC &lt;em&gt;service&lt;/em&gt; and
its method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. You can
see the complete .proto file for our example in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/protos/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;examples/protos/route_guide.proto&lt;/code&gt;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in your .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. Protocol buffers let you define four kinds of
service method, all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server and receives a
response later, just like a normal remote procedure call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;response-streaming RPC&lt;/em&gt; where the client sends a request to the server and
gets back a stream of response messages. You specify a response-streaming
method by placing the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;request-streaming RPC&lt;/em&gt; where the client sends a sequence of messages to the
server. Once the client has finished writing the messages, it waits for the
server to read them all and return its response. You specify a
request-streaming method by placing the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt;
type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
to the other. The two streams operate independently, so clients and servers
can read and write in whatever order they like: for example, the server could
wait to receive all the client messages before writing its responses, or it
could alternately read a message then write a message, or some other
combination of reads and writes. The order of messages in each stream is
preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt; keyword
before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can specify a prefix to be used for your generated classes by adding the
&lt;code&gt;objc_class_prefix&lt;/code&gt; option at the top of the file. For example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;option&lt;/span&gt; objc_class_prefix &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;RTG&amp;#34;&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;protoc&#34;&gt;Generating client code&lt;/h3&gt;
&lt;p&gt;Next we need to generate the gRPC client interfaces from our .proto service
definition. We do this using the protocol buffer compiler (&lt;code&gt;protoc&lt;/code&gt;) with a
special gRPC Objective-C plugin.&lt;/p&gt;
&lt;p&gt;For simplicity, we&amp;rsquo;ve provided a &lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/objective-c/route_guide/RouteGuide.podspec&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Podspec
file&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
that runs &lt;code&gt;protoc&lt;/code&gt; for you with the appropriate plugin, input, and output, and
describes how to compile the generated files. You just need to run in this
directory (&lt;code&gt;examples/objective-c/route_guide&lt;/code&gt;):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ pod install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;which, before installing the generated library in the XCode project of this sample, runs:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ protoc -I ../../protos --objc_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;Pods/RouteGuide --objcgrpc_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;Pods/RouteGuide ../../protos/route_guide.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Running this command generates the following files under &lt;code&gt;Pods/RouteGuide/&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RouteGuide.pbobjc.h&lt;/code&gt;, the header which declares your generated message
classes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteGuide.pbobjc.m&lt;/code&gt;, which contains the implementation of your message
classes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteGuide.pbrpc.h&lt;/code&gt;, the header which declares your generated service
classes.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteGuide.pbrpc.m&lt;/code&gt;, which contains the implementation of your service
classes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;These contain:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All the protocol buffer code to populate, serialize, and retrieve our request
and response message types.&lt;/li&gt;
&lt;li&gt;A class called &lt;code&gt;RTGRouteGuide&lt;/code&gt; that lets clients call the methods defined in
the &lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can also use the provided Podspec file to generate client code from any
other proto service definition; just replace the name (matching the file name),
version, and other metadata.&lt;/p&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client application&lt;/h3&gt;
&lt;p&gt;In this section, we&amp;rsquo;ll look at creating an Objective-C client for our
&lt;code&gt;RouteGuide&lt;/code&gt; service. You can see our complete example client code in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/objective-c/route_guide/ViewControllers.m&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/objective-c/route_guide/ViewControllers.m&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    In your apps, for maintainability and readability reasons, you shouldn&amp;rsquo;t
put all of your view controllers in a single file; it&amp;rsquo;s done here only to
simplify the learning process).

&lt;/div&gt;

&lt;h4 id=&#34;constructing-a-service-object&#34;&gt;Constructing a service object&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a service object, an instance
of the generated &lt;code&gt;RTGRouteGuide&lt;/code&gt; class. The designated initializer of the class
expects a &lt;code&gt;NSString *&lt;/code&gt; with the server address and port we want to connect to:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;&lt;span style=&#34;color:#099&#34;&gt;#import &amp;lt;GRPCClient/GRPCCall+Tests.h&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;#import &amp;lt;RouteGuide/RouteGuide.pbrpc.h&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;#import &amp;lt;GRPCClient/GRPCTransport.h&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;static&lt;/span&gt; NSString &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; kHostAddress &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;localhost:50051&amp;#34;&lt;/span&gt;;
...
GRPCMutableCallOptions &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;options &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [[GRPCMutableCallOptions alloc] init];
options.transport &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; GRPCDefaultTransportImplList.core_insecure;

RTGRouteGuide &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;service &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [[RTGRouteGuide alloc] &lt;span style=&#34;color:#99f&#34;&gt;initWithHost&lt;/span&gt;:kHostAddress &lt;span style=&#34;color:#99f&#34;&gt;callOptions&lt;/span&gt;:options];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice that we our service is constructed with an insecure transport. This is
because the server we will be using to test our client doesn&amp;rsquo;t use
&lt;a href=&#34;https://en.wikipedia.org/wiki/Transport_Layer_Security&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;TLS&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. This is fine
because it will be running locally on our development machine. The most common
case, though, is connecting with a gRPC server on the internet, running gRPC
over TLS. For that case, the setting the option &lt;code&gt;options.transport&lt;/code&gt; isn&amp;rsquo;t
needed because gRPC will use a secure TLS transport by default.&lt;/p&gt;
&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how we call our service methods. As you will see, all these
methods are asynchronous, so you can call them from the main thread of your app
without worrying about freezing your UI or the OS killing your app.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; is as straightforward as calling any other
asynchronous method on Cocoa.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;
RTGPoint &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;point &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [RTGPoint message];
point.latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;40E7&lt;/span&gt;;
point.longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;74E7&lt;/span&gt;;

GRPCUnaryResponseHandler &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;handler &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
    [[GRPCUnaryResponseHandler alloc] &lt;span style=&#34;color:#99f&#34;&gt;initWithResponseHandler&lt;/span&gt;:
        &lt;span style=&#34;color:#555&#34;&gt;^&lt;/span&gt;(RTGFeature &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;response, NSError &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;error) {
          &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (response) {
            &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Successful response received
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;          } &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;else&lt;/span&gt; {
            &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RPC error
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;          }
        }
                                        &lt;span style=&#34;color:#99f&#34;&gt;responseDispatchQueue&lt;/span&gt;:&lt;span style=&#34;color:#366&#34;&gt;nil&lt;/span&gt;];

[[service &lt;span style=&#34;color:#99f&#34;&gt;getFeatureWithMessage&lt;/span&gt;:point &lt;span style=&#34;color:#99f&#34;&gt;responseHandler&lt;/span&gt;:handler &lt;span style=&#34;color:#99f&#34;&gt;callOptions&lt;/span&gt;:&lt;span style=&#34;color:#366&#34;&gt;nil&lt;/span&gt;] start];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we create and populate a request protocol buffer object (in our
case &lt;code&gt;RTGPoint&lt;/code&gt;). Then, we call the method on the service object, passing it the
request, and a block to handle the response (or any RPC error). If the RPC
finishes successfully, the handler block is called with a &lt;code&gt;nil&lt;/code&gt; error argument,
and we can read the response information from the server from the response
argument. If, instead, some RPC error happens, the handler block is called with
a &lt;code&gt;nil&lt;/code&gt; response argument, and we can read the details of the problem from the
error argument.&lt;/p&gt;
&lt;h5 id=&#34;streaming-rpcs&#34;&gt;Streaming RPCs&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at our streaming methods. Here&amp;rsquo;s where we call the
response-streaming method &lt;code&gt;ListFeatures&lt;/code&gt;, which results in our client app
receiving a stream of geographical &lt;code&gt;RTGFeature&lt;/code&gt;s:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;
- (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#c0f&#34;&gt;didReceiveProtoMessage&lt;/span&gt;(GPBMessage &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#033&#34;&gt;message&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (message) {
    NSLog(&lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;Found feature at %@ called %@.&amp;#34;&lt;/span&gt;, response.location, response.name);
  }
}

- (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#c0f&#34;&gt;didCloseWithTrailingMetadata:&lt;/span&gt;(NSDictionary &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#033&#34;&gt;trailingMetadata&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;error:&lt;/span&gt;(NSError &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#033&#34;&gt;error&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (error) {
    NSLog(&lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;RPC error: %@&amp;#34;&lt;/span&gt;, error);
  }
}

- (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#c0f&#34;&gt;execRequest&lt;/span&gt; {
  ...
  [[service &lt;span style=&#34;color:#99f&#34;&gt;listFeaturesWithMessage&lt;/span&gt;:rectangle &lt;span style=&#34;color:#99f&#34;&gt;responseHandler&lt;/span&gt;:&lt;span style=&#34;color:#366&#34;&gt;self&lt;/span&gt; &lt;span style=&#34;color:#99f&#34;&gt;callOptions&lt;/span&gt;:&lt;span style=&#34;color:#366&#34;&gt;nil&lt;/span&gt;] start];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Notice that instead of providing a response handler object, the view controller
object itself handles the responses. The method &lt;code&gt;didReceiveProtoMessage:&lt;/code&gt; is
called when there&amp;rsquo;s a message received; it can be called any number of times.
The method &lt;code&gt;didCloseWithTrailingMetadata:&lt;/code&gt; is called when the call is complete
and the gRPC status is received from the server (or when there&amp;rsquo;s any error
happens during the call).&lt;/p&gt;
&lt;p&gt;The request-streaming method &lt;code&gt;RecordRoute&lt;/code&gt; expects a stream of &lt;code&gt;RTGPoint&lt;/code&gt;s from
the cient. This stream can be written to the gRPC call object after the call
starts.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;RTGPoint &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;point1 &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [RTGPoint message];
point.latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;40E7&lt;/span&gt;;
point.longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;74E7&lt;/span&gt;;

RTGPoint &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;point2 &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [RTGPoint message];
point.latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;40E7&lt;/span&gt;;
point.longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;74E7&lt;/span&gt;;

GRPCUnaryResponseHandler &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;handler &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
    [[GRPCUnaryResponseHandler alloc] &lt;span style=&#34;color:#99f&#34;&gt;initWithResponseHandler&lt;/span&gt;:
        &lt;span style=&#34;color:#555&#34;&gt;^&lt;/span&gt;(RTGRouteSummary &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;response, NSError &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;error) {
            &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (response) {
              NSLog(&lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;Finished trip with %i points&amp;#34;&lt;/span&gt;, response.pointCount);
              NSLog(&lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;Passed %i features&amp;#34;&lt;/span&gt;, response.featureCount);
              NSLog(&lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;Travelled %i meters&amp;#34;&lt;/span&gt;, response.distance);
              NSLog(&lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;It took %i seconds&amp;#34;&lt;/span&gt;, response.elapsedTime);
            } &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;else&lt;/span&gt; {
              NSLog(&lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;RPC error: %@&amp;#34;&lt;/span&gt;, error);
            }
        }
                                        &lt;span style=&#34;color:#99f&#34;&gt;responseDispatchQueue&lt;/span&gt;:&lt;span style=&#34;color:#366&#34;&gt;nil&lt;/span&gt;];
GRPCStreamingProtoCall &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;call &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
    [service &lt;span style=&#34;color:#99f&#34;&gt;recordRouteWithResponseHandler&lt;/span&gt;:handler &lt;span style=&#34;color:#99f&#34;&gt;callOptions&lt;/span&gt;:&lt;span style=&#34;color:#366&#34;&gt;nil&lt;/span&gt;];
[call start];
[call &lt;span style=&#34;color:#99f&#34;&gt;writeMessage&lt;/span&gt;:point1];
[call &lt;span style=&#34;color:#99f&#34;&gt;writeMessage&lt;/span&gt;:point2];
[call finish];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that since the gRPC call object does not know the end of the request
stream, users must invoke &lt;code&gt;finish:&lt;/code&gt; method when the request stream is complete.&lt;/p&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;. The way to
call a bidirectional streaming RPC is just a combination of how to call
request-streaming RPCs and response-streaming RPCs.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;
- (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#c0f&#34;&gt;didReceiveProtoMessage&lt;/span&gt;(GPBMessage &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#033&#34;&gt;message&lt;/span&gt; {
  RTGRouteNote &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;note &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; (RTGRouteNote &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)message;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (note) {
    NSLog(&lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;Got message %@ at %@&amp;#34;&lt;/span&gt;, note.message, note.location);
  }
}

- (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#c0f&#34;&gt;didCloseWithTrailingMetadata:&lt;/span&gt;(NSDictionary &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#033&#34;&gt;trailingMetadata&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;error:&lt;/span&gt;(NSError &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#033&#34;&gt;error&lt;/span&gt; {
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (error) {
    NSLog(&lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;RPC error: %@&amp;#34;&lt;/span&gt;, error);
  } &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;else&lt;/span&gt; {
    NSLog(&lt;span style=&#34;color:#c30&#34;&gt;@&amp;#34;Chat ended.&amp;#34;&lt;/span&gt;);
  }
}

- (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#c0f&#34;&gt;execRequest&lt;/span&gt; {
  ...
  GRPCStreamingProtoCall &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;call &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
      [service &lt;span style=&#34;color:#99f&#34;&gt;routeChatWithResponseHandler&lt;/span&gt;:&lt;span style=&#34;color:#366&#34;&gt;self&lt;/span&gt; &lt;span style=&#34;color:#99f&#34;&gt;callOptions&lt;/span&gt;:&lt;span style=&#34;color:#366&#34;&gt;nil&lt;/span&gt;];
  [call start];
  [call &lt;span style=&#34;color:#99f&#34;&gt;writeMessage&lt;/span&gt;:note1];
  ...
  [call &lt;span style=&#34;color:#99f&#34;&gt;writeMessage&lt;/span&gt;:noteN];
  [call finish];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/php/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/php/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic PHP programmer&amp;rsquo;s introduction to
working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Generate client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the PHP gRPC API to write a simple client for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes a passing familiarity with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. Note
that the example in this tutorial uses the proto2 version of the protocol
buffers language.&lt;/p&gt;
&lt;p&gt;Also note that currently, you can only create clients in PHP for gRPC services.
Use &lt;a href=&#34;https://Joevaen.github.io/docs/languages/&#34;&gt;another language&lt;/a&gt; to create a gRPC server.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code for our tutorial is in
&lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/php/route_guide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc/grpc/examples/php/route_guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
To download the example, clone the &lt;code&gt;grpc&lt;/code&gt; repository and its submodules by running the following
command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone --recurse-submodules -b v1.37.1 https://github.com/grpc/grpc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You need the &lt;code&gt;grpc-php-plugin&lt;/code&gt; to help you compile &lt;code&gt;.proto&lt;/code&gt; files. Build it from source as follows:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc
$ mkdir -p cmake/build
$ &lt;span style=&#34;color:#366&#34;&gt;pushd&lt;/span&gt; cmake/build
$ cmake ../..
$ make protoc grpc_php_plugin
$ &lt;span style=&#34;color:#366&#34;&gt;popd&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then change to route guide directory and compile the example&amp;rsquo;s &lt;code&gt;.proto&lt;/code&gt; files:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; examples/php/route_guide
$ ./route_guide_proto_gen.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;You also should have the relevant tools installed to generate the client
interface code (and a server in another language, for testing). You can obtain
the latter by following &lt;a href=&#34;https://Joevaen.github.io/docs/languages/node/basics/&#34;&gt;these setup
instructions&lt;/a&gt;, for example.&lt;/p&gt;
&lt;h3 id=&#34;try&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;To try the sample app, we need a gRPC server running locally. Let&amp;rsquo;s compile and
run, for example, the Node.js server in this repository:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; ../../node
$ npm install
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; dynamic_codegen/route_guide
$ nodejs ./route_guide_server.js --db_path&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;route_guide_db.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Run the PHP client (in a different terminal):&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./run_route_guide_client.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The next sections guide you step-by-step through how this proto service is
defined, how to generate a client library from it, and how to create a client
stub that uses that library.&lt;/p&gt;
&lt;h3 id=&#34;proto&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;First let&amp;rsquo;s look at how the service we&amp;rsquo;re using is defined. A gRPC &lt;em&gt;service&lt;/em&gt; and
its method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. You can
see the complete .proto file for our example in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/protos/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;examples/protos/route_guide.proto&lt;/code&gt;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in your .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. Protocol buffers let you define four kinds of
service method, all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server and receives a
response later, just like a normal remote procedure call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;response-streaming RPC&lt;/em&gt; where the client sends a request to the server and
gets back a stream of response messages. You specify a response-streaming
method by placing the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;request-streaming RPC&lt;/em&gt; where the client sends a sequence of messages to the
server. Once the client has finished writing the messages, it waits for the
server to read them all and return its response. You specify a
request-streaming method by placing the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt;
type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
to the other. The two streams operate independently, so clients and servers
can read and write in whatever order they like: for example, the server could
wait to receive all the client messages before writing its responses, or it
could alternately read a message then write a message, or some other
combination of reads and writes. The order of messages in each stream is
preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt; keyword
before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;protoc&#34;&gt;Generating client code&lt;/h3&gt;
&lt;p&gt;The PHP client stub implementation of the proto files can be generated by the
gRPC PHP Protoc Plugin. To compile the plugin:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ make grpc_php_plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To generate the client stub implementation .php file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc
$ protoc --proto_path&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;examples/protos &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;  --php_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;examples/php/route_guide &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;  --grpc_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;examples/php/route_guide &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;  --plugin&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;protoc-gen-grpc&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;bins/opt/grpc_php_plugin &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;  ./examples/protos/route_guide.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;or running the helper script under the &lt;code&gt;grpc/example/php/route_guide&lt;/code&gt; directory if you build
grpc-php-plugin by source:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ ./route_guide_proto_gen.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A number of files will be generated in the &lt;code&gt;examples/php/route_guide&lt;/code&gt; directory.
You do not need to modify those files.&lt;/p&gt;
&lt;p&gt;To load these generated files, add this section to your &lt;code&gt;composer.json&lt;/code&gt; file under
&lt;code&gt;examples/php&lt;/code&gt; directory&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;  &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;autoload&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;:&lt;/span&gt; {
    &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;&amp;#34;psr-4&amp;#34;&lt;/span&gt;: {
      &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;route_guide/&amp;#34;&lt;/span&gt;
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The file contains:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;All the protocol buffer code to populate, serialize, and retrieve our request
and response message types.&lt;/li&gt;
&lt;li&gt;A class called &lt;code&gt;Routeguide\RouteGuideClient&lt;/code&gt; that lets clients call the methods
defined in the &lt;code&gt;RouteGuide&lt;/code&gt; service.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, we&amp;rsquo;ll look at creating a PHP client for our &lt;code&gt;RouteGuide&lt;/code&gt;
service. You can see our complete example client code in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/php/route_guide/route_guide_client.php&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/php/route_guide/route_guide_client.php&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;constructing-a-client-object&#34;&gt;Constructing a client object&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a client object, an instance of
the generated &lt;code&gt;RouteGuideClient&lt;/code&gt; class. The constructor of the class expects the
server address and port we want to connect to:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#033&#34;&gt;$client&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Routeguide\RouteGuideClient(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;localhost:50051&amp;#39;&lt;/span&gt;, [
    &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;credentials&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&amp;gt;&lt;/span&gt; Grpc\ChannelCredentials&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;createInsecure&lt;/span&gt;(),
]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how we call our service methods.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; is nearly as straightforward as calling a
local asynchronous method.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#033&#34;&gt;$point&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Routeguide\Point();
&lt;span style=&#34;color:#033&#34;&gt;$point&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLatitude&lt;/span&gt;(&lt;span style=&#34;color:#f60&#34;&gt;409146138&lt;/span&gt;);
&lt;span style=&#34;color:#033&#34;&gt;$point&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLongitude&lt;/span&gt;(&lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;746188906&lt;/span&gt;);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;list&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$feature&lt;/span&gt;, &lt;span style=&#34;color:#033&#34;&gt;$status&lt;/span&gt;) &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$client&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;GetFeature&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$point&lt;/span&gt;)&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;wait&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we create and populate a request object, i.e. an
&lt;code&gt;Routeguide\Point&lt;/code&gt; object. Then, we call the method on the stub, passing it the
request object. If there is no error, then we can read the response information
from the server from our response object, i.e. an &lt;code&gt;Routeguide\Feature&lt;/code&gt; object.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;print&lt;/span&gt; sprintf(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Found %s &lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;  at %f, %f&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\n&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#033&#34;&gt;$feature&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getName&lt;/span&gt;(),
              &lt;span style=&#34;color:#033&#34;&gt;$feature&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;()&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;() &lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt; COORD_FACTOR,
              &lt;span style=&#34;color:#033&#34;&gt;$feature&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;()&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;() &lt;span style=&#34;color:#555&#34;&gt;/&lt;/span&gt; COORD_FACTOR);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;streaming-rpcs&#34;&gt;Streaming RPCs&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at our streaming methods. Here&amp;rsquo;s where we call the server-side
streaming method &lt;code&gt;ListFeatures&lt;/code&gt;, which returns a stream of geographical
&lt;code&gt;Feature&lt;/code&gt;s:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#033&#34;&gt;$lo_point&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Routeguide\Point();
&lt;span style=&#34;color:#033&#34;&gt;$hi_point&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Routeguide\Point();

&lt;span style=&#34;color:#033&#34;&gt;$lo_point&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLatitude&lt;/span&gt;(&lt;span style=&#34;color:#f60&#34;&gt;400000000&lt;/span&gt;);
&lt;span style=&#34;color:#033&#34;&gt;$lo_point&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLongitude&lt;/span&gt;(&lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;750000000&lt;/span&gt;);
&lt;span style=&#34;color:#033&#34;&gt;$hi_point&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLatitude&lt;/span&gt;(&lt;span style=&#34;color:#f60&#34;&gt;420000000&lt;/span&gt;);
&lt;span style=&#34;color:#033&#34;&gt;$hi_point&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLongitude&lt;/span&gt;(&lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;730000000&lt;/span&gt;);

&lt;span style=&#34;color:#033&#34;&gt;$rectangle&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Routeguide\Rectangle();
&lt;span style=&#34;color:#033&#34;&gt;$rectangle&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLo&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$lo_point&lt;/span&gt;);
&lt;span style=&#34;color:#033&#34;&gt;$rectangle&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setHi&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$hi_point&lt;/span&gt;);

&lt;span style=&#34;color:#033&#34;&gt;$call&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$client&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;ListFeatures&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$rectangle&lt;/span&gt;);
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// an iterator over the server streaming responses
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$features&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$call&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;responses&lt;/span&gt;();
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#033&#34;&gt;$features&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$feature&lt;/span&gt;) {
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// process each feature
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;} &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the loop will end when the server indicates there is no more responses to be sent.
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;$call-&amp;gt;responses()&lt;/code&gt; method call returns an iterator. When the server sends
a response, a &lt;code&gt;$feature&lt;/code&gt; object will be returned in the &lt;code&gt;foreach&lt;/code&gt; loop, until
the server indiciates that there will be no more responses to be sent.&lt;/p&gt;
&lt;p&gt;The client-side streaming method &lt;code&gt;RecordRoute&lt;/code&gt; is similar, except that we call
&lt;code&gt;$call-&amp;gt;write($point)&lt;/code&gt; for each point we want to write from the client side and
get back a &lt;code&gt;Routeguide\RouteSummary&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#033&#34;&gt;$call&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$client&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;RecordRoute&lt;/span&gt;();

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#033&#34;&gt;$i&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;; &lt;span style=&#34;color:#033&#34;&gt;$i&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$num_points&lt;/span&gt;; &lt;span style=&#34;color:#033&#34;&gt;$i&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;) {
  &lt;span style=&#34;color:#033&#34;&gt;$point&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Routeguide\Point();
  &lt;span style=&#34;color:#033&#34;&gt;$point&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLatitude&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$lat&lt;/span&gt;);
  &lt;span style=&#34;color:#033&#34;&gt;$point&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLongitude&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$long&lt;/span&gt;);
  &lt;span style=&#34;color:#033&#34;&gt;$call&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;write&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$point&lt;/span&gt;);
}

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;list&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$route_summary&lt;/span&gt;, &lt;span style=&#34;color:#033&#34;&gt;$status&lt;/span&gt;) &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$call&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;wait&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;routeChat()&lt;/code&gt;. In this
case, we just pass a context to the method and get back a &lt;code&gt;BidiStreamingCall&lt;/code&gt;
stream object, which we can use to both write and read messages.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#033&#34;&gt;$call&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$client&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;RouteChat&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To write messages from the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;foreach&lt;/span&gt; (&lt;span style=&#34;color:#033&#34;&gt;$notes&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$n&lt;/span&gt;) {
  &lt;span style=&#34;color:#033&#34;&gt;$route_note&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Routeguide\RouteNote();
  &lt;span style=&#34;color:#033&#34;&gt;$call&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;write&lt;/span&gt;(&lt;span style=&#34;color:#033&#34;&gt;$route_note&lt;/span&gt;);
}
&lt;span style=&#34;color:#033&#34;&gt;$call&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;writesDone&lt;/span&gt;();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To read messages from the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-php&#34; data-lang=&#34;php&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#033&#34;&gt;$route_note_reply&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#033&#34;&gt;$call&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;read&lt;/span&gt;()) {
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// process $route_note_reply
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Each side will always get the other&amp;rsquo;s messages in the order they were written,
both the client and server can read and write in any order — the streams operate
completely independently.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/python/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/python/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic Python programmer&amp;rsquo;s introduction
to working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Generate server and client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the Python gRPC API to write a simple client and server for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes that you have read the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and are familiar
with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. You can
find out more in the &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/reference/python-generated&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Python
generated code
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;example-code-and-setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code for this tutorial is in
&lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/python/route_guide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc/grpc/examples/python/route_guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
To download the example, clone the &lt;code&gt;grpc&lt;/code&gt; repository by running the following
command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.37.1 https://github.com/grpc/grpc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then change your current directory to &lt;code&gt;examples/python/route_guide&lt;/code&gt; in the repository:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc/examples/python/route_guide
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You also should have the relevant tools installed to generate the server and
client interface code - if you don&amp;rsquo;t already, follow the setup instructions in
&lt;a href=&#34;../quickstart/&#34;&gt;Quick start&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Your first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to
define the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. You can
see the complete .proto file in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/protos/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;examples/protos/route_guide.proto&lt;/code&gt;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in your .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (Method definitions not shown)
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;response-streaming RPC&lt;/em&gt; where the client sends a request to the server and
gets a stream to read a sequence of messages back. The client reads from the
returned stream until there are no more messages. As you can see in the
example, you specify a response-streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;request-streaming RPC&lt;/em&gt; where the client writes a sequence of messages and
sends them to the server, again using a provided stream. Once the client has
finished writing the messages, it waits for the server to read them all and
return its response. You specify a request-streaming method by placing the
&lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectionally-streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Your &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;generating-client-and-server-code&#34;&gt;Generating client and server code&lt;/h3&gt;
&lt;p&gt;Next you need to generate the gRPC client and server interfaces from your .proto
service definition.&lt;/p&gt;
&lt;p&gt;First, install the grpcio-tools package:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ pip install grpcio-tools
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Use the following command to generate the Python code:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python -m grpc_tools.protoc -I../../protos --python_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;. --grpc_python_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;. ../../protos/route_guide.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Note that as we&amp;rsquo;ve already provided a version of the generated code in the
example directory, running this command regenerates the appropriate file rather
than creates a new one. The generated code files are called
&lt;code&gt;route_guide_pb2.py&lt;/code&gt; and &lt;code&gt;route_guide_pb2_grpc.py&lt;/code&gt; and contain:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;classes for the messages defined in route_guide.proto&lt;/li&gt;
&lt;li&gt;classes for the service defined in route_guide.proto
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RouteGuideStub&lt;/code&gt;, which can be used by clients to invoke RouteGuide RPCs&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteGuideServicer&lt;/code&gt;, which defines the interface for implementations
of the RouteGuide service&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;a function for the service defined in route_guide.proto
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add_RouteGuideServicer_to_server&lt;/code&gt;, which adds a RouteGuideServicer to
a &lt;code&gt;grpc.Server&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    The &lt;code&gt;2&lt;/code&gt; in pb2 indicates that the generated code is following Protocol Buffers Python API version 2. Version 1 is obsolete. It has no relation to the Protocol Buffers Language version, which is the one indicated by &lt;code&gt;syntax = &amp;quot;proto3&amp;quot;&lt;/code&gt; or &lt;code&gt;syntax = &amp;quot;proto2&amp;quot;&lt;/code&gt; in a .proto file.

&lt;/div&gt;

&lt;h3 id=&#34;server&#34;&gt;Creating the server&lt;/h3&gt;
&lt;p&gt;First let&amp;rsquo;s look at how you create a &lt;code&gt;RouteGuide&lt;/code&gt; server. If you&amp;rsquo;re only
interested in creating gRPC clients, you can skip this section and go straight
to &lt;a href=&#34;#client&#34;&gt;Creating the client&lt;/a&gt; (though you might find it interesting
anyway!).&lt;/p&gt;
&lt;p&gt;Creating and running a &lt;code&gt;RouteGuide&lt;/code&gt; server breaks down into two work items:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the servicer interface generated from our service definition with
functions that perform the actual &amp;ldquo;work&amp;rdquo; of the service.&lt;/li&gt;
&lt;li&gt;Running a gRPC server to listen for requests from clients and transmit
responses.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find the example &lt;code&gt;RouteGuide&lt;/code&gt; server in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/python/route_guide/route_guide_server.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/python/route_guide/route_guide_server.py&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;implementing-routeguide&#34;&gt;Implementing RouteGuide&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;route_guide_server.py&lt;/code&gt; has a &lt;code&gt;RouteGuideServicer&lt;/code&gt; class that subclasses the
generated class &lt;code&gt;route_guide_pb2_grpc.RouteGuideServicer&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# RouteGuideServicer provides an implementation of the methods of the RouteGuide service.&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;RouteGuideServicer&lt;/span&gt;(route_guide_pb2_grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;RouteGuideServicer):
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;RouteGuideServicer&lt;/code&gt; implements all the &lt;code&gt;RouteGuide&lt;/code&gt; service methods.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Let&amp;rsquo;s look at the simplest type first, &lt;code&gt;GetFeature&lt;/code&gt;, which just gets a &lt;code&gt;Point&lt;/code&gt;
from the client and returns the corresponding feature information from its
database in a &lt;code&gt;Feature&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;GetFeature&lt;/span&gt;(self, request, context):
  feature &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; get_feature(self&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;db, request)
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; feature &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;is&lt;/span&gt; None:
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; route_guide_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;Feature(name&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;, location&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;request)
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;else&lt;/span&gt;:
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; feature
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method is passed a &lt;code&gt;route_guide_pb2.Point&lt;/code&gt; request for the RPC, and a
&lt;code&gt;grpc.ServicerContext&lt;/code&gt; object that provides RPC-specific information such as
timeout limits. It returns a &lt;code&gt;route_guide_pb2.Feature&lt;/code&gt; response.&lt;/p&gt;
&lt;h5 id=&#34;response-streaming-rpc&#34;&gt;Response-streaming RPC&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at the next method. &lt;code&gt;ListFeatures&lt;/code&gt; is a response-streaming RPC
that sends multiple &lt;code&gt;Feature&lt;/code&gt;s to the client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;ListFeatures&lt;/span&gt;(self, request, context):
  left &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;min&lt;/span&gt;(request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;lo&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;longitude, request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;hi&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;longitude)
  right &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;max&lt;/span&gt;(request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;lo&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;longitude, request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;hi&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;longitude)
  top &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;max&lt;/span&gt;(request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;lo&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;latitude, request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;hi&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;latitude)
  bottom &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;min&lt;/span&gt;(request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;lo&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;latitude, request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;hi&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;latitude)
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; feature &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; self&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;db:
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (feature&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;location&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;longitude &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;=&lt;/span&gt; left &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;and&lt;/span&gt;
        feature&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;location&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;longitude &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;=&lt;/span&gt; right &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;and&lt;/span&gt;
        feature&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;location&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;latitude &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;=&lt;/span&gt; bottom &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;and&lt;/span&gt;
        feature&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;location&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;latitude &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;=&lt;/span&gt; top):
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;yield&lt;/span&gt; feature
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here the request message is a &lt;code&gt;route_guide_pb2.Rectangle&lt;/code&gt; within which the
client wants to find &lt;code&gt;Feature&lt;/code&gt;s. Instead of returning a single response the
method yields zero or more responses.&lt;/p&gt;
&lt;h5 id=&#34;request-streaming-rpc&#34;&gt;Request-streaming RPC&lt;/h5&gt;
&lt;p&gt;The request-streaming method &lt;code&gt;RecordRoute&lt;/code&gt; uses an
&lt;a href=&#34;https://docs.python.org/2/library/stdtypes.html#iterator-types&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;iterator&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; of
request values and returns a single response value.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;RecordRoute&lt;/span&gt;(self, request_iterator, context):
  point_count &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
  feature_count &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;
  distance &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;0.0&lt;/span&gt;
  prev_point &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; None

  start_time &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; time&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;time()
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; point &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; request_iterator:
    point_count &lt;span style=&#34;color:#555&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; get_feature(self&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;db, point):
      feature_count &lt;span style=&#34;color:#555&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; prev_point:
      distance &lt;span style=&#34;color:#555&#34;&gt;+=&lt;/span&gt; get_distance(prev_point, point)
    prev_point &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; point

  elapsed_time &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; time&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;time() &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt; start_time
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; route_guide_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;RouteSummary(point_count&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;point_count,
                                      feature_count&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;feature_count,
                                      distance&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#366&#34;&gt;int&lt;/span&gt;(distance),
                                      elapsed_time&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#366&#34;&gt;int&lt;/span&gt;(elapsed_time))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;bidirectional-streaming-rpc&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Lastly let&amp;rsquo;s look at the bidirectionally-streaming method &lt;code&gt;RouteChat&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;RouteChat&lt;/span&gt;(self, request_iterator, context):
  prev_notes &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; []
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; new_note &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; request_iterator:
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; prev_note &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; prev_notes:
      &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; prev_note&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;location &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; new_note&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;location:
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;yield&lt;/span&gt; prev_note
    prev_notes&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;append(new_note)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This method&amp;rsquo;s semantics are a combination of those of the request-streaming
method and the response-streaming method. It is passed an iterator of request
values and is itself an iterator of response values.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-server&#34;&gt;Starting the server&lt;/h4&gt;
&lt;p&gt;Once you have implemented all the &lt;code&gt;RouteGuide&lt;/code&gt; methods, the next step is to
start up a gRPC server so that clients can actually use your service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;serve&lt;/span&gt;():
  server &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;server(futures&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;ThreadPoolExecutor(max_workers&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;10&lt;/span&gt;))
  route_guide_pb2_grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;add_RouteGuideServicer_to_server(
      RouteGuideServicer(), server)
  server&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;add_insecure_port(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;[::]:50051&amp;#39;&lt;/span&gt;)
  server&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;start()
  server&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;wait_for_termination()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The server &lt;code&gt;start()&lt;/code&gt; method is non-blocking. A new thread will be instantiated
to handle requests. The thread calling &lt;code&gt;server.start()&lt;/code&gt; will often
not have any other work to do in the meantime. In this case, you can call
&lt;code&gt;server.wait_for_termination()&lt;/code&gt; to cleanly block the calling thread until the
server terminates.&lt;/p&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;You can see the complete example client code in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/python/route_guide/route_guide_client.py&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/python/route_guide/route_guide_client.py&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;creating-a-stub&#34;&gt;Creating a stub&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a &lt;em&gt;stub&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We instantiate the &lt;code&gt;RouteGuideStub&lt;/code&gt; class of the &lt;code&gt;route_guide_pb2_grpc&lt;/code&gt;
module, generated from our .proto.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;channel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;insecure_channel(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;localhost:50051&amp;#39;&lt;/span&gt;)
stub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; route_guide_pb2_grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;RouteGuideStub(channel)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;For RPC methods that return a single response (&amp;ldquo;response-unary&amp;rdquo; methods), gRPC
Python supports both synchronous (blocking) and asynchronous (non-blocking)
control flow semantics. For response-streaming RPC methods, calls immediately
return an iterator of response values. Calls to that iterator&amp;rsquo;s &lt;code&gt;next()&lt;/code&gt; method
block until the response to be yielded from the iterator becomes available.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc-1&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;A synchronous call to the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; is nearly as straightforward
as calling a local method. The RPC call waits for the server to respond, and
will either return a response or raise an exception:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;feature &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;GetFeature(point)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;An asynchronous call to &lt;code&gt;GetFeature&lt;/code&gt; is similar, but like calling a local method
asynchronously in a thread pool:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;feature_future &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;GetFeature&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;future(point)
feature &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; feature_future&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;result()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;response-streaming-rpc-1&#34;&gt;Response-streaming RPC&lt;/h5&gt;
&lt;p&gt;Calling the response-streaming &lt;code&gt;ListFeatures&lt;/code&gt; is similar to working with
sequence types:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; feature &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;ListFeatures(rectangle):
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;request-streaming-rpc-1&#34;&gt;Request-streaming RPC&lt;/h5&gt;
&lt;p&gt;Calling the request-streaming &lt;code&gt;RecordRoute&lt;/code&gt; is similar to passing an iterator
to a local method. Like the simple RPC above that also returns a single
response, it can be called synchronously or asynchronously:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;route_summary &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;RecordRoute(point_iterator)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;route_summary_future &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;RecordRoute&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;future(point_iterator)
route_summary &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; route_summary_future&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;result()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h5 id=&#34;bidirectional-streaming-rpc-1&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Calling the bidirectionally-streaming &lt;code&gt;RouteChat&lt;/code&gt; has (as is the case on the
service-side) a combination of the request-streaming and response-streaming
semantics:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; received_route_note &lt;span style=&#34;color:#000;font-weight:bold&#34;&gt;in&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;RouteChat(sent_route_note_iterator):
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python route_guide_server.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;From a different terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ python route_guide_client.py
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/ruby/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/ruby/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic Ruby programmer&amp;rsquo;s introduction to working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Generate server and client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the Ruby gRPC API to write a simple client and server for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes that you have read the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and are familiar
with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. Note
that the example in this tutorial uses the proto3 version of the protocol
buffers language: you can find out more in
the &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/proto3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3 language
guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;example-code-and-setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code for our tutorial is in
&lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/ruby/route_guide&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc/grpc/examples/ruby/route_guide&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
To download the example, clone the &lt;code&gt;grpc&lt;/code&gt; repository by running the following
command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.37.1 https://github.com/grpc/grpc
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then change your current directory to &lt;code&gt;examples/ruby/route_guide&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; examples/ruby/route_guide
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You also should have the relevant tools installed to generate the server and
client interface code - if you don&amp;rsquo;t already, follow the setup instructions in
&lt;a href=&#34;../quickstart/&#34;&gt;Quick start&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Our first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to
define the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using
&lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. You can
see the complete .proto file in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/protos/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;examples/protos/route_guide.proto&lt;/code&gt;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To define a service, you specify a named &lt;code&gt;service&lt;/code&gt; in your .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you define &lt;code&gt;rpc&lt;/code&gt; methods inside your service definition, specifying their
request and response types. gRPC lets you define four kinds of service method,
all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;server-side streaming RPC&lt;/em&gt; where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;client-side streaming RPC&lt;/em&gt; where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;generating-client-and-server-code&#34;&gt;Generating client and server code&lt;/h3&gt;
&lt;p&gt;Next we need to generate the gRPC client and server interfaces from our .proto
service definition. We do this using the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; with
a special gRPC Ruby plugin.&lt;/p&gt;
&lt;p&gt;If you want to run this yourself, make sure you&amp;rsquo;ve installed protoc and followed
the gRPC Ruby plugin &lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/src/ruby/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;installation
instructions&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; first):&lt;/p&gt;
&lt;p&gt;Once that&amp;rsquo;s done, the following command can be used to generate the ruby code.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ grpc_tools_ruby_protoc -I ../../protos --ruby_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;../lib --grpc_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;../lib ../../protos/route_guide.proto
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Running this command regenerates the following files in the lib directory:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lib/route_guide.pb&lt;/code&gt; defines a module &lt;code&gt;Examples::RouteGuide&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;This contain all the protocol buffer code to populate, serialize, and
retrieve our request and response message types&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lib/route_guide_services.pb&lt;/code&gt;, extends &lt;code&gt;Examples::RouteGuide&lt;/code&gt; with stub and
service classes
&lt;ul&gt;
&lt;li&gt;a class &lt;code&gt;Service&lt;/code&gt; for use as a base class when defining RouteGuide service
implementations&lt;/li&gt;
&lt;li&gt;a class &lt;code&gt;Stub&lt;/code&gt; that can be used to access remote RouteGuide instances&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;server&#34;&gt;Creating the server&lt;/h3&gt;
&lt;p&gt;First let&amp;rsquo;s look at how we create a &lt;code&gt;RouteGuide&lt;/code&gt; server. If you&amp;rsquo;re only
interested in creating gRPC clients, you can skip this section and go straight
to &lt;a href=&#34;#client&#34;&gt;Creating the client&lt;/a&gt; (though you might find it interesting
anyway!).&lt;/p&gt;
&lt;p&gt;There are two parts to making our &lt;code&gt;RouteGuide&lt;/code&gt; service do its job:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Implementing the service interface generated from our service definition:
doing the actual &amp;ldquo;work&amp;rdquo; of our service.&lt;/li&gt;
&lt;li&gt;Running a gRPC server to listen for requests from clients and return the
service responses.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find our example &lt;code&gt;RouteGuide&lt;/code&gt; server in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/ruby/route_guide/route_guide_server.rb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/ruby/route_guide/route_guide_server.rb&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
Let&amp;rsquo;s take a closer look at how it works.&lt;/p&gt;
&lt;h4 id=&#34;implementing-routeguide&#34;&gt;Implementing RouteGuide&lt;/h4&gt;
&lt;p&gt;As you can see, our server has a &lt;code&gt;ServerImpl&lt;/code&gt; class that extends the generated
&lt;code&gt;RouteGuide::Service&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# ServerImpl provides an implementation of the RouteGuide service.&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;ServerImpl&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#360&#34;&gt;RouteGuide&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;Service&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;ServerImpl&lt;/code&gt; implements all our service methods. Let&amp;rsquo;s look at the simplest type
first, &lt;code&gt;GetFeature&lt;/code&gt;, which just gets a &lt;code&gt;Point&lt;/code&gt; from the client and returns the
corresponding feature information from its database in a &lt;code&gt;Feature&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;get_feature&lt;/span&gt;(point, _call)
  &lt;span style=&#34;color:#366&#34;&gt;name&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; @feature_db&lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;{
    &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;longitude&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&amp;gt;&lt;/span&gt; point&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;longitude,
    &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;latitude&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&amp;gt;&lt;/span&gt; point&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;latitude }&lt;span style=&#34;color:#555&#34;&gt;]&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;||&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;&amp;#39;&lt;/span&gt;
  &lt;span style=&#34;color:#360&#34;&gt;Feature&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(&lt;span style=&#34;color:#fc3&#34;&gt;location&lt;/span&gt;: point, &lt;span style=&#34;color:#366&#34;&gt;name&lt;/span&gt;: &lt;span style=&#34;color:#366&#34;&gt;name&lt;/span&gt;)
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The method is passed a _call for the RPC, the client&amp;rsquo;s &lt;code&gt;Point&lt;/code&gt; protocol buffer
request, and returns a &lt;code&gt;Feature&lt;/code&gt; protocol buffer. In the method we create the
&lt;code&gt;Feature&lt;/code&gt; with the appropriate information, and then &lt;code&gt;return&lt;/code&gt; it.&lt;/p&gt;
&lt;p&gt;Now let&amp;rsquo;s look at something a bit more complicated - a streaming RPC.
&lt;code&gt;ListFeatures&lt;/code&gt; is a server-side streaming RPC, so we need to send back multiple
&lt;code&gt;Feature&lt;/code&gt;s to our client.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# in ServerImpl&lt;/span&gt;

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;list_features&lt;/span&gt;(rectangle, _call)
    &lt;span style=&#34;color:#360&#34;&gt;RectangleEnum&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(@feature_db, rectangle)&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;each
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, here the request object is a &lt;code&gt;Rectangle&lt;/code&gt; in which our client
wants to find &lt;code&gt;Feature&lt;/code&gt;s, but instead of returning a simple response we need to
return an &lt;a href=&#34;https://ruby-doc.org//core-2.2.0/Enumerator.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Enumerator&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; that
yields the responses. In the method, we use a helper class &lt;code&gt;RectangleEnum&lt;/code&gt;, to
act as an Enumerator implementation.&lt;/p&gt;
&lt;p&gt;Similarly, the client-side streaming method &lt;code&gt;record_route&lt;/code&gt; uses an
&lt;a href=&#34;https://ruby-doc.org//core-2.2.0/Enumerable.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Enumerable&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, but here it&amp;rsquo;s
obtained from the call object, which we&amp;rsquo;ve ignored in the earlier examples.
&lt;code&gt;call.each_remote_read&lt;/code&gt; yields each message sent by the client in turn.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;call&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;each_remote_read &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;do&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;|&lt;/span&gt;point&lt;span style=&#34;color:#555&#34;&gt;|&lt;/span&gt;
  &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;route_chat&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;route_chat&lt;/span&gt;(notes)
  &lt;span style=&#34;color:#360&#34;&gt;RouteChatEnumerator&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(notes, @received_notes)&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;each_item
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Here the method receives an
&lt;a href=&#34;https://ruby-doc.org//core-2.2.0/Enumerable.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Enumerable&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;, but also returns
an &lt;a href=&#34;https://ruby-doc.org//core-2.2.0/Enumerator.html&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Enumerator&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; that yields the
responses. Although each side will always get the other&amp;rsquo;s messages in the order they were written,
both the client and server can read and write in any order — the streams operate completely
independently.&lt;/p&gt;
&lt;h4 id=&#34;starting-the-server&#34;&gt;Starting the server&lt;/h4&gt;
&lt;p&gt;Once we&amp;rsquo;ve implemented all our methods, we also need to start up a gRPC server
so that clients can actually use our service. The following snippet shows how we
do this for our &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;port &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;0.0.0.0:50051&amp;#39;&lt;/span&gt;
s &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#360&#34;&gt;GRPC&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;RpcServer&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new
s&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;add_http2_port(port, &lt;span style=&#34;color:#fc3&#34;&gt;:this_port_is_insecure&lt;/span&gt;)
&lt;span style=&#34;color:#360&#34;&gt;GRPC&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;logger&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;info(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;... running insecurely on &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;#{&lt;/span&gt;port&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;)
s&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;handle(&lt;span style=&#34;color:#360&#34;&gt;ServerImpl&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(feature_db))
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# Runs the server with SIGHUP, SIGINT and SIGQUIT signal handlers to&lt;/span&gt;
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;#   gracefully shutdown.&lt;/span&gt;
&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;# User could also choose to run server via call to run_till_terminated&lt;/span&gt;
s&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;run_till_terminated_or_interrupted(&lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;int&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;SIGQUIT&amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;]&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we build and start our server using a &lt;code&gt;GRPC::RpcServer&lt;/code&gt;. To do
this, we:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Create an instance of our service implementation class &lt;code&gt;ServerImpl&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Specify the address and port we want to use to listen for client requests
using the builder&amp;rsquo;s &lt;code&gt;add_http2_port&lt;/code&gt; method.&lt;/li&gt;
&lt;li&gt;Register our service implementation with the &lt;code&gt;GRPC::RpcServer&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Call &lt;code&gt;run&lt;/code&gt; on the&lt;code&gt;GRPC::RpcServer&lt;/code&gt; to create and start an RPC server for our
service.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, we&amp;rsquo;ll look at creating a Ruby client for our &lt;code&gt;RouteGuide&lt;/code&gt;
service. You can see our complete example client code in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/ruby/route_guide/route_guide_client.rb&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples/ruby/route_guide/route_guide_client.rb&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;creating-a-stub&#34;&gt;Creating a stub&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a &lt;em&gt;stub&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;We use the &lt;code&gt;Stub&lt;/code&gt; class of the &lt;code&gt;RouteGuide&lt;/code&gt; module generated from our .proto.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;stub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#360&#34;&gt;RouteGuide&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;&lt;span style=&#34;color:#360&#34;&gt;Stub&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;localhost:50051&amp;#39;&lt;/span&gt;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how we call our service methods. Note that the gRPC Ruby only
provides  &lt;em&gt;blocking/synchronous&lt;/em&gt; versions of each method: this means that the
RPC call waits for the server to respond, and will either return a response or
raise an exception.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; is nearly as straightforward as calling a
local method.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;color:#360&#34;&gt;GET_FEATURE_POINTS&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;[&lt;/span&gt;
  &lt;span style=&#34;color:#360&#34;&gt;Point&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(&lt;span style=&#34;color:#fc3&#34;&gt;latitude&lt;/span&gt;:  &lt;span style=&#34;color:#f60&#34;&gt;409_146_138&lt;/span&gt;, &lt;span style=&#34;color:#fc3&#34;&gt;longitude&lt;/span&gt;: &lt;span style=&#34;color:#555&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;746_188_906&lt;/span&gt;),
  &lt;span style=&#34;color:#360&#34;&gt;Point&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(&lt;span style=&#34;color:#fc3&#34;&gt;latitude&lt;/span&gt;:  &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#fc3&#34;&gt;longitude&lt;/span&gt;: &lt;span style=&#34;color:#f60&#34;&gt;0&lt;/span&gt;)
&lt;span style=&#34;color:#555&#34;&gt;]&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;..&lt;/span&gt;
  &lt;span style=&#34;color:#360&#34;&gt;GET_FEATURE_POINTS&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;each &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;do&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;|&lt;/span&gt;pt&lt;span style=&#34;color:#555&#34;&gt;|&lt;/span&gt;
    resp &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;get_feature(pt)
	&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
    &lt;span style=&#34;color:#366&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;- found &amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;#{&lt;/span&gt;resp&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;name&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39; at &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;#{&lt;/span&gt;pt&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;inspect&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, we create and populate a request protocol buffer object (in our
case &lt;code&gt;Point&lt;/code&gt;), and create a response protocol buffer object for the server to
fill in.  Finally, we call the method on the stub, passing it the context,
request, and response. If the method returns &lt;code&gt;OK&lt;/code&gt;, then we can read the response
information from the server from our response object.&lt;/p&gt;
&lt;h5 id=&#34;streaming-rpcs&#34;&gt;Streaming RPCs&lt;/h5&gt;
&lt;p&gt;Now let&amp;rsquo;s look at our streaming methods. If you&amp;rsquo;ve already read &lt;a href=&#34;#server&#34;&gt;Creating the
server&lt;/a&gt; some of this may look very familiar - streaming RPCs are
implemented in a similar way on both sides. Here&amp;rsquo;s where we call the server-side
streaming method &lt;code&gt;list_features&lt;/code&gt;, which returns an &lt;code&gt;Enumerable&lt;/code&gt; of &lt;code&gt;Features&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;resps &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;list_features(&lt;span style=&#34;color:#360&#34;&gt;LIST_FEATURES_RECT&lt;/span&gt;)
resps&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;each &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;do&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;|&lt;/span&gt;r&lt;span style=&#34;color:#555&#34;&gt;|&lt;/span&gt;
  &lt;span style=&#34;color:#366&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;- found &amp;#39;&lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;#{&lt;/span&gt;r&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;name&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39; at &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;#{&lt;/span&gt;r&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;location&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;inspect&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The client-side streaming method &lt;code&gt;record_route&lt;/code&gt; is similar, except there we pass
the server an &lt;code&gt;Enumerable&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
reqs &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#360&#34;&gt;RandomRoute&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(features, points_on_route)
resp &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;record_route(reqs&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;each)
&lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;route_chat&lt;/code&gt;. In this
case, we pass &lt;code&gt;Enumerable&lt;/code&gt; to the method and get back an &lt;code&gt;Enumerable&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-ruby&#34; data-lang=&#34;ruby&#34;&gt;sleeping_enumerator &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#360&#34;&gt;SleepingEnumerator&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;new(&lt;span style=&#34;color:#360&#34;&gt;ROUTE_CHAT_NOTES&lt;/span&gt;, &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;)
stub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;route_chat(sleeping_enumerator&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;each_item) { &lt;span style=&#34;color:#555&#34;&gt;|&lt;/span&gt;r&lt;span style=&#34;color:#555&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;p&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;received &lt;/span&gt;&lt;span style=&#34;color:#a00&#34;&gt;#{&lt;/span&gt;r&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;inspect&lt;span style=&#34;color:#a00&#34;&gt;}&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&lt;/span&gt; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Although it&amp;rsquo;s not shown well by this example, each enumerable is independent of
the other - both the client and server can read and write in any order — the
streams operate completely independently.&lt;/p&gt;
&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Work from the example directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; examples/ruby
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Build the client and server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ gem install bundler &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; bundle install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Run the server:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ bundle &lt;span style=&#34;color:#366&#34;&gt;exec&lt;/span&gt; route_guide/route_guide_server.rb ../python/route_guide/route_guide_db.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    The &lt;code&gt;route_guide_db.json&lt;/code&gt; file is actually language-agnostic, it happens to be located in the &lt;code&gt;python&lt;/code&gt; folder.

&lt;/div&gt;

&lt;p&gt;From a different terminal, run the client:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ bundle &lt;span style=&#34;color:#366&#34;&gt;exec&lt;/span&gt; route_guide/route_guide_client.rb ../python/route_guide/route_guide_db.json
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/platforms/android/java/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/platforms/android/java/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic Android Java programmer&amp;rsquo;s introduction to working with gRPC.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Generate client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the Java gRPC API to write a simple mobile client for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes that you have read the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt; and are familiar with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
This guide also does not cover anything on the server side. You can check the &lt;a href=&#34;https://Joevaen.github.io/docs/languages/java/&#34;&gt;Java pages&lt;/a&gt; for more information.&lt;/p&gt;
&lt;h3 id=&#34;why-use-grpc&#34;&gt;Why use gRPC?&lt;/h3&gt;
&lt;p&gt;Our example is a simple route mapping application that lets clients get
information about features on their route, create a summary of their route, and
exchange route information such as traffic updates with the server and other
clients.&lt;/p&gt;
&lt;p&gt;With gRPC we can define our service once in a &lt;code&gt;.proto&lt;/code&gt; file and generate clients
and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be run in
environments ranging from servers inside a large data center to your own tablet —
all the complexity of communication between different languages and environments is
handled for you by gRPC. We also get all the advantages of working with protocol
buffers, including efficient serialization, a simple IDL, and easy interface
updating.&lt;/p&gt;

&lt;h3 id=&#34;example-code-and-setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code for our tutorial is in &lt;a href=&#34;https://github.com/grpc/grpc-java/tree/v1.38.0/examples/android&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-java&amp;rsquo;s examples/android&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. To download the example, clone the &lt;code&gt;grpc-java&lt;/code&gt; repository by running the following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.38.0 https://github.com/grpc/grpc-java.git
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then change your current directory to &lt;code&gt;grpc-java/examples/android&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-java/examples/android
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You also should have the relevant tools installed to generate the client
interface code - if you don&amp;rsquo;t already, follow the setup instructions in the
&lt;a href=&#34;https://github.com/grpc/grpc-java/blob/v1.38.0/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-java README&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;defining-the-service&#34;&gt;Defining the service&lt;/h3&gt;
&lt;p&gt;Our first step (as you&amp;rsquo;ll know from the &lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;) is to define the gRPC &lt;em&gt;service&lt;/em&gt; and the method &lt;em&gt;request&lt;/em&gt; and &lt;em&gt;response&lt;/em&gt; types using &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. You can see the complete .proto file in &lt;a href=&#34;https://github.com/grpc/grpc-java/blob/v1.38.0/examples/android/routeguide/app/src/main/proto/route_guide.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;routeguide/app/src/main/proto/route_guide.proto&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;As we&amp;rsquo;re generating Java code in this example, we&amp;rsquo;ve specified a &lt;code&gt;java_package&lt;/code&gt; file option in our .proto:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;option&lt;/span&gt; java_package &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;io.grpc.examples&amp;#34;&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;This specifies the package we want to use for our generated Java classes. If no explicit &lt;code&gt;java_package&lt;/code&gt; option is given in the .proto file, then by default the proto package (specified using the &amp;ldquo;package&amp;rdquo; keyword) will be used. However, proto packages generally do not make good Java packages since proto packages are not expected to start with reverse domain names. If we generate code in another language from this .proto, the &lt;code&gt;java_package&lt;/code&gt; option has no effect.&lt;/p&gt;
&lt;p&gt;To define a service, we specify a named &lt;code&gt;service&lt;/code&gt; in the .proto file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; RouteGuide {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;   &lt;span style=&#34;color:#555&#34;&gt;...&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then we define &lt;code&gt;rpc&lt;/code&gt; methods inside our service definition, specifying their request and response types. gRPC lets you define four kinds of service method, all of which are used in the &lt;code&gt;RouteGuide&lt;/code&gt; service:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;simple RPC&lt;/em&gt; where the client sends a request to the server using the stub
and waits for a response to come back, just like a normal function call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the feature at a given position.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; GetFeature(Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;server-side streaming RPC&lt;/em&gt; where the client sends a request to the server
and gets a stream to read a sequence of messages back. The client reads from
the returned stream until there are no more messages. As you can see in our
example, you specify a server-side streaming method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before the &lt;em&gt;response&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Obtains the Features available within the given Rectangle.  Results are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// streamed rather than returned at once (e.g. in a response message with a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// repeated field), as the rectangle may cover a large area and contain a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// huge number of features.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; ListFeatures(Rectangle) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream Feature) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;client-side streaming RPC&lt;/em&gt; where the client writes a sequence of messages
and sends them to the server, again using a provided stream. Once the client
has finished writing the messages, it waits for the server to read them all
and return its response. You specify a client-side streaming method by placing
the &lt;code&gt;stream&lt;/code&gt; keyword before the &lt;em&gt;request&lt;/em&gt; type.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of Points on a route being traversed, returning a
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RouteSummary when traversal is completed.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RecordRoute(stream Point) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (RouteSummary) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A &lt;em&gt;bidirectional streaming RPC&lt;/em&gt; where both sides send a sequence of messages
using a read-write stream. The two streams operate independently, so clients
and servers can read and write in whatever order they like: for example, the
server could wait to receive all the client messages before writing its
responses, or it could alternately read a message then write a message, or
some other combination of reads and writes. The order of messages in each
stream is preserved. You specify this type of method by placing the &lt;code&gt;stream&lt;/code&gt;
keyword before both the request and the response.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Accepts a stream of RouteNotes sent while a route is being traversed,
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// while receiving other RouteNotes (e.g. from other users).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; RouteChat(stream RouteNote) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (stream RouteNote) {}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our &lt;code&gt;.proto&lt;/code&gt; file also contains protocol buffer message type definitions for all
the request and response types used in our service methods - for example, here&amp;rsquo;s
the &lt;code&gt;Point&lt;/code&gt; message type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Points are represented as latitude-longitude pairs in the E7 representation
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// (degrees multiplied by 10**7 and rounded to the nearest integer).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Latitudes should be in the range +/- 90 degrees and longitude should be in
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the range +/- 180 degrees (inclusive).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;Point&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; latitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int32&lt;/span&gt; longitude &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;generating-client-code&#34;&gt;Generating client code&lt;/h3&gt;
&lt;p&gt;Next we need to generate the gRPC client interfaces from our .proto
service definition. We do this using the protocol buffer compiler &lt;code&gt;protoc&lt;/code&gt; with
a special gRPC Java plugin. You need to use the
&lt;a href=&#34;https://github.com/google/protobuf/releases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;proto3&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; compiler (which supports
both proto2 and proto3 syntax) in order to generate gRPC services.&lt;/p&gt;
&lt;p&gt;The build system for this example is also part of the Java-gRPC build. Refer to
the &lt;a href=&#34;https://github.com/grpc/grpc-java/blob/v1.38.0/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-java README&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; and &lt;a href=&#34;https://github.com/grpc/grpc-java/blob/v1.38.0/examples/android/routeguide/app/build.gradle#L26&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;build.gradle&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; for how to generate code from your
own &lt;code&gt;.proto&lt;/code&gt; files. Note that for Android, we will use protobuf lite which is
optimized for mobile usecase.&lt;/p&gt;
&lt;p&gt;The following classes are generated from our service definition:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Feature.java&lt;/code&gt;, &lt;code&gt;Point.java&lt;/code&gt;, &lt;code&gt;Rectangle.java&lt;/code&gt;, and others which contain
all the protocol buffer code to populate, serialize, and retrieve our request
and response message types.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RouteGuideGrpc.java&lt;/code&gt; which contains (along with some other useful code):
&lt;ul&gt;
&lt;li&gt;a base class for &lt;code&gt;RouteGuide&lt;/code&gt; servers to implement,
&lt;code&gt;RouteGuideGrpc.RouteGuideImplBase&lt;/code&gt;, with all the methods defined in the &lt;code&gt;RouteGuide&lt;/code&gt;
service.&lt;/li&gt;
&lt;li&gt;&lt;em&gt;stub&lt;/em&gt; classes that clients can use to talk to a &lt;code&gt;RouteGuide&lt;/code&gt; server.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;creating-the-client&#34;&gt;Creating the client&lt;/h3&gt;
&lt;p&gt;In this section, we&amp;rsquo;ll look at creating a Java client for our &lt;code&gt;RouteGuide&lt;/code&gt; service. You can see our complete example client code in &lt;a href=&#34;https://github.com/grpc/grpc-java/blob/v1.38.0/examples/android/routeguide/app/src/main/java/io/grpc/routeguideexample/RouteGuideActivity.java&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;routeguide/app/src/main/java/io/grpc/routeguideexample/RouteGuideActivity.java&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h4 id=&#34;creating-a-stub&#34;&gt;Creating a stub&lt;/h4&gt;
&lt;p&gt;To call service methods, we first need to create a &lt;em&gt;stub&lt;/em&gt;, or rather, two stubs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;a &lt;em&gt;blocking/synchronous&lt;/em&gt; stub: this means that the RPC call waits for the server to respond, and will either return a response or raise an exception.&lt;/li&gt;
&lt;li&gt;a &lt;em&gt;non-blocking/asynchronous&lt;/em&gt; stub that makes non-blocking calls to the server, where the response is returned asynchronously. You can make certain types of streaming call only using the asynchronous stub.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;First we need to create a gRPC &lt;em&gt;channel&lt;/em&gt; for our stub, specifying the server address and port we want to connect to:
We use a &lt;code&gt;ManagedChannelBuilder&lt;/code&gt; to create the channel.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;mChannel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; ManagedChannelBuilder&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;forAddress&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;host&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; port&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;usePlaintext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;true&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now we can use the channel to create our stubs using the &lt;code&gt;newStub&lt;/code&gt; and &lt;code&gt;newBlockingStub&lt;/code&gt; methods provided in the &lt;code&gt;RouteGuideGrpc&lt;/code&gt; class we generated from our .proto.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;blockingStub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; RouteGuideGrpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBlockingStub&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;mChannel&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
asyncStub &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; RouteGuideGrpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newStub&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;mChannel&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;calling-service-methods&#34;&gt;Calling service methods&lt;/h4&gt;
&lt;p&gt;Now let&amp;rsquo;s look at how we call our service methods.&lt;/p&gt;
&lt;h5 id=&#34;simple-rpc&#34;&gt;Simple RPC&lt;/h5&gt;
&lt;p&gt;Calling the simple RPC &lt;code&gt;GetFeature&lt;/code&gt; on the blocking stub is as straightforward as calling a local method.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Point request &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; Point&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;lat&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;lon&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
Feature feature &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; blockingStub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getFeature&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;We create and populate a request protocol buffer object (in our case &lt;code&gt;Point&lt;/code&gt;), pass it to the &lt;code&gt;getFeature()&lt;/code&gt; method on our blocking stub, and get back a &lt;code&gt;Feature&lt;/code&gt;.&lt;/p&gt;
&lt;h5 id=&#34;server-side-streaming-rpc&#34;&gt;Server-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Next, let&amp;rsquo;s look at a server-side streaming call to &lt;code&gt;ListFeatures&lt;/code&gt;, which returns a stream of geographical &lt;code&gt;Feature&lt;/code&gt;s:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;Rectangle request &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
    Rectangle&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLo&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;lowLat&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;lowLon&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;())&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setHi&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;hiLat&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;setLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;hiLon&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
Iterator&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Feature&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; features &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; blockingStub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;listFeatures&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, it&amp;rsquo;s very similar to the simple RPC we just looked at, except instead of returning a single &lt;code&gt;Feature&lt;/code&gt;, the method returns an &lt;code&gt;Iterator&lt;/code&gt; that the client can use to read all the returned &lt;code&gt;Feature&lt;/code&gt;s.&lt;/p&gt;
&lt;h5 id=&#34;client-side-streaming-rpc&#34;&gt;Client-side streaming RPC&lt;/h5&gt;
&lt;p&gt;Now for something a little more complicated: the client-side streaming method &lt;code&gt;RecordRoute&lt;/code&gt;, where we send a stream of &lt;code&gt;Point&lt;/code&gt;s to the server and get back a single &lt;code&gt;RouteSummary&lt;/code&gt;. For this method we need to use the asynchronous stub. If you&amp;rsquo;ve already read &lt;a href=&#34;https://Joevaen.github.io/docs/languages/java/basics/#server&#34;&gt;Creating the server&lt;/a&gt; some of this may look very familiar - asynchronous streaming RPCs are implemented in a similar way on both sides.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; String &lt;span style=&#34;color:#c0f&#34;&gt;recordRoute&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;List&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; points&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; numPoints&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; RouteGuideStub asyncStub&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throws&lt;/span&gt; InterruptedException&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; RuntimeException &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; StringBuffer logs &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; StringBuffer&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    appendLogs&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;logs&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;*** RecordRoute&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; CountDownLatch finishLatch &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; CountDownLatch&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteSummary&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; responseObserver &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteSummary&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteSummary summary&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
            appendLogs&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;logs&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished trip with {0} points. Passed {1} features. &amp;#34;&lt;/span&gt;
                    &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Travelled {2} meters. It took {3} seconds.&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; summary&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getPointCount&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt;
                    summary&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getFeatureCount&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt; summary&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getDistance&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt;
                    summary&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getElapsedTime&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

        &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onError&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Throwable t&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
            failed &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; t&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
            finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;countDown&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

        &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
            appendLogs&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;logs&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished RecordRoute&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
            finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;countDown&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;};&lt;/span&gt;

    StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Point&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; requestObserver &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; asyncStub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;recordRoute&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;responseObserver&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Send numPoints points randomly selected from the points list.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;        Random rand &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; Random&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt; i &lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt; numPoints&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;++&lt;/span&gt;i&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
            &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;int&lt;/span&gt; index &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; rand&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;nextInt&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;points&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;size&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
            Point point &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; points&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;get&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;index&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
            appendLogs&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;logs&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Visiting point {0}, {1}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; RouteGuideUtil&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;point&lt;span style=&#34;color:#555&#34;&gt;),&lt;/span&gt;
                    RouteGuideUtil&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;point&lt;span style=&#34;color:#555&#34;&gt;));&lt;/span&gt;
            requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;point&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sleep for a bit before sending the next one.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;            Thread&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;sleep&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;rand&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;nextInt&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;1000&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; 500&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
            &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getCount&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// RPC completed or errored before we finished sending.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Sending further requests won&amp;#39;t error, but they will just be thrown away.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;                &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;break&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RuntimeException e&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Cancel RPC
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;        requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onError&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;e&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throw&lt;/span&gt; e&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Mark the end of requests
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Receiving happens asynchronously
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(!&lt;/span&gt;finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; TimeUnit&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;MINUTES&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; RuntimeException&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;
               &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Could not finish rpc within 1 minute, the server is likely down&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;failed &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; RuntimeException&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;failed&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; logs&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;toString&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As you can see, to call this method we need to create a &lt;code&gt;StreamObserver&lt;/code&gt;, which implements a special interface for the server to call with its &lt;code&gt;RouteSummary&lt;/code&gt; response. In our &lt;code&gt;StreamObserver&lt;/code&gt; we:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Override the &lt;code&gt;onNext()&lt;/code&gt; method to print out the returned information when the server writes a &lt;code&gt;RouteSummary&lt;/code&gt; to the message stream.&lt;/li&gt;
&lt;li&gt;Override the &lt;code&gt;onCompleted()&lt;/code&gt; method (called when the &lt;em&gt;server&lt;/em&gt; has completed the call on its side) to set a &lt;code&gt;SettableFuture&lt;/code&gt; that we can check to see if the server has finished writing.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We then pass the &lt;code&gt;StreamObserver&lt;/code&gt; to the asynchronous stub&amp;rsquo;s &lt;code&gt;recordRoute()&lt;/code&gt; method and get back our own &lt;code&gt;StreamObserver&lt;/code&gt; request observer to write our &lt;code&gt;Point&lt;/code&gt;s to send to the server.  Once we&amp;rsquo;ve finished writing points, we use the request observer&amp;rsquo;s &lt;code&gt;onCompleted()&lt;/code&gt; method to tell gRPC that we&amp;rsquo;ve finished writing on the client side. Once we&amp;rsquo;re done, we check our &lt;code&gt;SettableFuture&lt;/code&gt; to check that the server has completed on its side.&lt;/p&gt;
&lt;h5 id=&#34;bidirectional-streaming-rpc&#34;&gt;Bidirectional streaming RPC&lt;/h5&gt;
&lt;p&gt;Finally, let&amp;rsquo;s look at our bidirectional streaming RPC &lt;code&gt;RouteChat()&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;private&lt;/span&gt; String &lt;span style=&#34;color:#c0f&#34;&gt;routeChat&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteGuideStub asyncStub&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throws&lt;/span&gt; InterruptedException&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt;
        RuntimeException &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; StringBuffer logs &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; StringBuffer&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
    appendLogs&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;logs&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;*** RouteChat&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;final&lt;/span&gt; CountDownLatch finishLatch &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; CountDownLatch&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; requestObserver &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
            asyncStub&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;routeChat&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; StreamObserver&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;RouteNote&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
                &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
                &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteNote note&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
                    appendLogs&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;logs&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Got message \&amp;#34;{0}\&amp;#34; at {1}, {2}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; note&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt;
                            note&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt;
                            note&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
                &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

                &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
                &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onError&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;Throwable t&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
                    failed &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; t&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
                    finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;countDown&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

                &lt;span style=&#34;color:#99f&#34;&gt;@Override&lt;/span&gt;
                &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;public&lt;/span&gt; &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;()&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
                    appendLogs&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;logs&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Finished RouteChat&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
                    finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;countDown&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
                &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
            &lt;span style=&#34;color:#555&#34;&gt;});&lt;/span&gt;

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;try&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        RouteNote&lt;span style=&#34;color:#555&#34;&gt;[]&lt;/span&gt; requests &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
                &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;newNote&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;First message&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;),&lt;/span&gt; newNote&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Second message&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#555&#34;&gt;),&lt;/span&gt;
                        newNote&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Third message&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 0&lt;span style=&#34;color:#555&#34;&gt;),&lt;/span&gt; newNote&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Fourth message&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; 1&lt;span style=&#34;color:#555&#34;&gt;)};&lt;/span&gt;

        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;for&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RouteNote request &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; requests&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
            appendLogs&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;logs&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Sending message \&amp;#34;{0}\&amp;#34; at {1}, {2}&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getMessage&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt;
                    request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLatitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(),&lt;/span&gt;
                    request&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLocation&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;getLongitude&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;());&lt;/span&gt;
            requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onNext&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;request&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;catch&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;RuntimeException e&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Cancel RPC
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;        requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onError&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;e&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throw&lt;/span&gt; e&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Mark the end of requests
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    requestObserver&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;onCompleted&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;

    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Receiving happens asynchronously
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(!&lt;/span&gt;finishLatch&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;await&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;1&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; TimeUnit&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;MINUTES&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;))&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; RuntimeException&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;
                &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Could not finish rpc within 1 minute, the server is likely down&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;failed &lt;span style=&#34;color:#555&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;{&lt;/span&gt;
        &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;throw&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; RuntimeException&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;failed&lt;span style=&#34;color:#555&#34;&gt;);&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;

    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;return&lt;/span&gt; logs&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;toString&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;span style=&#34;color:#555&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;As with our client-side streaming example, we both get and return a &lt;code&gt;StreamObserver&lt;/code&gt; response observer, except this time we send values via our method&amp;rsquo;s response observer while the server is still writing messages to &lt;em&gt;their&lt;/em&gt; message stream. The syntax for reading and writing here is exactly the same as for our client-streaming method. Although each side will always get the other&amp;rsquo;s messages in the order they were written, both the client and server can read and write in any order — the streams operate completely independently.&lt;/p&gt;
&lt;h3 id=&#34;try-it-out&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;Follow the instructions in the &lt;a href=&#34;https://github.com/grpc/grpc-java/blob/v1.38.0/examples/android/README.md&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;example directory README&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; to build and run the
client and server.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Basics tutorial</title>
      <link>https://Joevaen.github.io/docs/platforms/web/basics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/platforms/web/basics/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial provides a basic introduction on how to use
gRPC-Web from browsers.&lt;/p&gt;
&lt;p&gt;By walking through this example you&amp;rsquo;ll learn how to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Define a service in a .proto file.&lt;/li&gt;
&lt;li&gt;Generate client code using the protocol buffer compiler.&lt;/li&gt;
&lt;li&gt;Use the gRPC-Web API to write a simple client for your service.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes a passing familiarity with &lt;a href=&#34;https://developers.google.com/protocol-buffers/docs/overview&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protocol
buffers&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;why-grpc&#34;&gt;Why use gRPC and gRPC-Web?&lt;/h3&gt;
&lt;p&gt;With gRPC you can define your service once in a .proto file and implement
clients and servers in any of gRPC&amp;rsquo;s supported languages, which in turn can be
run in environments ranging from servers inside a large data center to your own
tablet - all the complexity of communication between different languages and
environments is handled for you by gRPC. You also get all the advantages of
working with protocol buffers, including efficient serialization, a simple IDL,
and easy interface updating. gRPC-Web lets you access gRPC services built in this
manner from browsers using an idiomatic API.&lt;/p&gt;
&lt;h3 id=&#34;setup&#34;&gt;Define the Service&lt;/h3&gt;
&lt;p&gt;The first step when creating a gRPC service is to define the service methods
and their request and response message types using protocol buffers. In this
example, we define our &lt;code&gt;EchoService&lt;/code&gt; in a file called
&lt;a href=&#34;https://github.com/grpc/grpc-web/blob/0.4.0/net/grpc/gateway/examples/echo/echo.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;echo.proto&lt;/code&gt;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.
For more information about protocol buffers and proto3 syntax, please see the
&lt;a href=&#34;https://developers.google.com/protocol-buffers/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;protobuf documentation&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;EchoRequest&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;EchoResponse&lt;/span&gt; {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;message&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; EchoService {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; Echo(EchoRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (EchoResponse);&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;implement-grpc-backend-server&#34;&gt;Implement gRPC Backend Server&lt;/h3&gt;
&lt;p&gt;Next, we implement our EchoService interface using Node in the backend gRPC
&lt;code&gt;EchoServer&lt;/code&gt;. This will handle requests from clients. See the file
&lt;a href=&#34;https://github.com/grpc/grpc-web/blob/master/net/grpc/gateway/examples/echo/node-server/server.js&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;&lt;code&gt;node-server/server.js&lt;/code&gt;&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
for details.&lt;/p&gt;
&lt;p&gt;You can implement the server in any language supported by gRPC. Please see
the &lt;a href=&#34;https://Joevaen.github.io/docs/&#34;&gt;main page&lt;/a&gt; for more details.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt; doEcho(call, callback) {
  callback(&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;null&lt;/span&gt;, {message&lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; call.request.message});
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;configure-the-envoy-proxy&#34;&gt;Configure the Envoy Proxy&lt;/h3&gt;
&lt;p&gt;In this example, we will use the &lt;a href=&#34;https://www.envoyproxy.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Envoy&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;
proxy to forward the gRPC browser request to the backend server. You can see
the complete config file in
&lt;a href=&#34;https://github.com/grpc/grpc-web/blob/master/net/grpc/gateway/examples/echo/envoy.yaml&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;envoy.yaml&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;To forward the gRPC requests to the backend server, we need a block like
this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span style=&#34;color:#bbb&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;listeners&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;  &lt;/span&gt;- &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;name&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;listener_0&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;address&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;      &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;socket_address&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;address: 0.0.0.0, port_value&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;8080&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;filter_chains&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;- &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;filters&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;      &lt;/span&gt;- &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;name&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;envoy.http_connection_manager&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;        &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;config&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;codec_type&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;auto&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;stat_prefix&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;ingress_http&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;route_config&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;            &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;name&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;local_route&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;            &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;virtual_hosts&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;            &lt;/span&gt;- &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;name&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;local_service&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;              &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;domains&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;[&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;]&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;              &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;routes&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;              &lt;/span&gt;- &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;match&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;prefix&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;}&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;                &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;route&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;cluster&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;echo_service }&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;          &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;http_filters&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;          &lt;/span&gt;- &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;name&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;envoy.grpc_web&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;          &lt;/span&gt;- &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;name&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;envoy.router&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;  &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;clusters&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;  &lt;/span&gt;- &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;name&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;echo_service&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;connect_timeout&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;0.&lt;/span&gt;25s&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;type&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;logical_dns&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;http2_protocol_options&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{}&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;lb_policy&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;round_robin&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt;    &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;hosts&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;[{&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;socket_address&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;{&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;address: node-server, port_value&lt;/span&gt;:&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;&lt;span style=&#34;color:#f60&#34;&gt;9090&lt;/span&gt;&lt;span style=&#34;color:#bbb&#34;&gt; &lt;/span&gt;}}]&lt;span style=&#34;color:#bbb&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You may also need to add some CORS setup to make sure the browser can request
cross-origin content.&lt;/p&gt;
&lt;p&gt;In this simple example, the browser makes gRPC requests to port &lt;code&gt;:8080&lt;/code&gt;. Envoy
forwards the request to the backend gRPC server listening on port &lt;code&gt;:9090&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;generate-protobuf-messages-and-service-client-stub&#34;&gt;Generate Protobuf Messages and Service Client Stub&lt;/h3&gt;
&lt;p&gt;To generate the protobuf message classes from our &lt;code&gt;echo.proto&lt;/code&gt;, run the
following command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ protoc -I&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$DIR&lt;/span&gt; echo.proto &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;  --js_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;import_style&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;commonjs:&lt;span style=&#34;color:#033&#34;&gt;$OUT_DIR&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;The &lt;code&gt;import_style&lt;/code&gt; option passed to the &lt;code&gt;--js_out&lt;/code&gt; flag makes sure the
generated files will have CommonJS style &lt;code&gt;require()&lt;/code&gt; statements.&lt;/p&gt;
&lt;p&gt;To generate the gRPC-Web service client stub, first you need the gRPC-Web
protoc plugin. To compile the plugin &lt;code&gt;protoc-gen-grpc-web&lt;/code&gt;, you need to run
this from the repo&amp;rsquo;s root directory:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc-web
$ sudo make install-plugin
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;To generate the service client stub file, run this command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ protoc -I&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;$DIR&lt;/span&gt; echo.proto &lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;\
&lt;/span&gt;&lt;span style=&#34;color:#c30;font-weight:bold&#34;&gt;&lt;/span&gt;  --grpc-web_out&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#033&#34;&gt;import_style&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;commonjs,mode&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;grpcwebtext:&lt;span style=&#34;color:#033&#34;&gt;$OUT_DIR&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;In the &lt;code&gt;--grpc-web_out&lt;/code&gt; param above:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mode&lt;/code&gt; can be &lt;code&gt;grpcwebtext&lt;/code&gt; (default) or &lt;code&gt;grpcweb&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;import_style&lt;/code&gt; can be &lt;code&gt;closure&lt;/code&gt; (default) or &lt;code&gt;commonjs&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our command generates the client stub, by default, to the file
&lt;code&gt;echo_grpc_web_pb.js&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;write-js-client-code&#34;&gt;Write JS Client Code&lt;/h3&gt;
&lt;p&gt;Now you are ready to write some JS client code. Put this in a &lt;code&gt;client.js&lt;/code&gt; file.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; {EchoRequest, EchoResponse} &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; require(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;./echo_pb.js&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;const&lt;/span&gt; {EchoServiceClient} &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; require(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;./echo_grpc_web_pb.js&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; echoService &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; EchoServiceClient(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;http://localhost:8080&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;var&lt;/span&gt; request &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; EchoRequest();
request.setMessage(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Hello World!&amp;#39;&lt;/span&gt;);

echoService.echo(request, {}, &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;function&lt;/span&gt;(err, response) {
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// ...
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You will need a &lt;code&gt;package.json&lt;/code&gt; file&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;{
  &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;grpc-web-commonjs-example&amp;#34;&lt;/span&gt;,
  &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;&amp;#34;dependencies&amp;#34;&lt;/span&gt;: {
    &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;&amp;#34;google-protobuf&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;^3.6.1&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;&amp;#34;grpc-web&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;^0.4.0&amp;#34;&lt;/span&gt;
  },
  &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;&amp;#34;devDependencies&amp;#34;&lt;/span&gt;: {
    &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;&amp;#34;browserify&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;^16.2.2&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;&amp;#34;webpack&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;^4.16.5&amp;#34;&lt;/span&gt;,
    &lt;span style=&#34;color:#309;font-weight:bold&#34;&gt;&amp;#34;webpack-cli&amp;#34;&lt;/span&gt;: &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;^3.1.0&amp;#34;&lt;/span&gt;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;compile-the-js-library&#34;&gt;Compile the JS Library&lt;/h3&gt;
&lt;p&gt;Finally, putting all these together, we can compile all the relevant JS files
into one single JS library that can be used in the browser.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ npm install
$ npx webpack client.js
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Now embed &lt;code&gt;dist/main.js&lt;/code&gt; into your project and see it in action!&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: Asynchronous-API tutorial</title>
      <link>https://Joevaen.github.io/docs/languages/cpp/async/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/cpp/async/</guid>
      <description>
        
        
        &lt;p&gt;This tutorial shows you how to write a simple server and client in C++ using
gRPC&amp;rsquo;s asynchronous/non-blocking APIs. It assumes you are already familiar with
writing simple synchronous gRPC code, as described in &lt;a href=&#34;https://Joevaen.github.io/docs/languages/cpp/basics/&#34;&gt;Basics
tutorial&lt;/a&gt;. The example used in this tutorial follows
from the basic &lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/cpp/helloworld&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Greeter example&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; used in the
&lt;a href=&#34;https://Joevaen.github.io/docs/languages/cpp/quickstart/&#34;&gt;quick start&lt;/a&gt;. You&amp;rsquo;ll find it along with installation
instructions in
&lt;a href=&#34;https://github.com/grpc/grpc/tree/v1.37.1/examples/cpp/helloworld&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc/examples/cpp/helloworld&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;
&lt;p&gt;gRPC uses the
&lt;a href=&#34;https://Joevaen.github.io/grpc/cpp/classgrpc_1_1_completion_queue.html&#34;&gt;CompletionQueue&lt;/a&gt;
API for asynchronous operations. The basic work flow
is as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bind a &lt;code&gt;CompletionQueue&lt;/code&gt; to an RPC call&lt;/li&gt;
&lt;li&gt;do something like a read or write, present with a unique &lt;code&gt;void*&lt;/code&gt; tag&lt;/li&gt;
&lt;li&gt;call &lt;code&gt;CompletionQueue::Next&lt;/code&gt; to wait for operations to complete. If a tag
appears, it indicates that the corresponding operation is complete.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;async-client&#34;&gt;Async client&lt;/h3&gt;
&lt;p&gt;To use an asynchronous client to call a remote method, you first create a
channel and stub, just as you do in a &lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/cpp/helloworld/greeter_client.cc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;synchronous
client&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. Once you have your stub, you do
the following to make an asynchronous call:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Initiate the RPC and create a handle for it. Bind the RPC to a
&lt;code&gt;CompletionQueue&lt;/code&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;CompletionQueue cq;
std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;ClientAsyncResponseReader&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;HelloReply&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; rpc(
    stub_&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;AsyncSayHello(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;context, request, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;cq));
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ask for the reply and final status, with a unique tag&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;Status status;
rpc&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Finish(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;reply, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;status, (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the completion queue to return the next tag. The reply and status are
ready once the tag passed into the corresponding &lt;code&gt;Finish()&lt;/code&gt; call is returned.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; got_tag;
&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;bool&lt;/span&gt; ok &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;false&lt;/span&gt;;
cq.Next(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;got_tag, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;ok);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (ok &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; got_tag &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;) {
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// check reply and status
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can see the complete client example in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/cpp/helloworld/greeter_async_client.cc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;greeter_async_client.cc&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;async-server&#34;&gt;Async server&lt;/h3&gt;
&lt;p&gt;The server implementation requests an RPC call with a tag and then waits for the
completion queue to return the tag. The basic flow for handling an RPC
asynchronously is:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Build a server exporting the async service&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;helloworld&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;Greeter&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;AsyncService service;
ServerBuilder builder;
builder.AddListeningPort(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;0.0.0.0:50051&amp;#34;&lt;/span&gt;, InsecureServerCredentials());
builder.RegisterAsyncService(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;service);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;auto&lt;/span&gt; cq &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; builder.AddCompletionQueue();
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;auto&lt;/span&gt; server &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; builder.BuildAndStart();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Request one RPC, providing a unique tag&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;ServerContext context;
HelloRequest request;
ServerAsyncResponseWriter&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;HelloReply&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; responder;
service.RequestSayHello(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;context, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;request, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;responder, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;cq, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;cq, (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the completion queue to return the tag. The context, request and
responder are ready once the tag is retrieved.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;HelloReply reply;
Status status;
&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; got_tag;
&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;bool&lt;/span&gt; ok &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;false&lt;/span&gt;;
cq.Next(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;got_tag, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;ok);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (ok &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; got_tag &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f60&#34;&gt;1&lt;/span&gt;) {
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// set reply and status
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  responder.Finish(reply, status, (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait for the completion queue to return the tag. The RPC is finished when the
tag is back.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; got_tag;
&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;bool&lt;/span&gt; ok &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#366&#34;&gt;false&lt;/span&gt;;
cq.Next(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;got_tag, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;ok);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (ok &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; got_tag &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#f60&#34;&gt;2&lt;/span&gt;) {
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// clean up
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This basic flow, however, doesn&amp;rsquo;t take into account the server handling multiple
requests concurrently. To deal with this, our complete async server example uses
a &lt;code&gt;CallData&lt;/code&gt; object to maintain the state of each RPC, and uses the address of
this object as the unique tag for the call.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;class CallData {
&lt;span style=&#34;color:#99f&#34;&gt;public&lt;/span&gt;:
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Take in the &amp;#34;service&amp;#34; instance (in this case representing an asynchronous
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// server) and the completion queue &amp;#34;cq&amp;#34; used for asynchronous communication
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// with the gRPC runtime.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  CallData(Greeter&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;AsyncService&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; service, ServerCompletionQueue&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; cq)
      &lt;span style=&#34;color:#555&#34;&gt;:&lt;/span&gt; service_(service), cq_(cq), responder_(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;ctx_), status_(CREATE) {
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Invoke the serving logic right away.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    Proceed();
  }

  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; Proceed() {
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (status_ &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; CREATE) {
      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// As part of the initial CREATE state, we *request* that the system
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// start processing SayHello requests. In this request, &amp;#34;this&amp;#34; acts are
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the tag uniquely identifying the request (so that different CallData
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// instances can serve different requests concurrently), in this case
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the memory address of this CallData instance.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      service_&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;RequestSayHello(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;ctx_, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;request_, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;responder_, cq_, cq_,
                                this);
      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Make this instance progress to the PROCESS state.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      status_ &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; PROCESS;
    } &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;if&lt;/span&gt; (status_ &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; PROCESS) {
      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Spawn a new CallData instance to serve new clients while we process
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the one for this CallData. The instance will deallocate itself as
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// part of its FINISH state.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      new CallData(service_, cq_);

      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// The actual processing.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;string prefix(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;Hello &amp;#34;&lt;/span&gt;);
      reply_.set_message(prefix &lt;span style=&#34;color:#555&#34;&gt;+&lt;/span&gt; request_.name());

      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// And we are done! Let the gRPC runtime know we&amp;#39;ve finished, using the
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// memory address of this instance as the uniquely identifying tag for
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// the event.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      responder_.Finish(reply_, Status&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;OK, this);
      status_ &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; FINISH;
    } &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;else&lt;/span&gt; {
      GPR_ASSERT(status_ &lt;span style=&#34;color:#555&#34;&gt;==&lt;/span&gt; FINISH);
      &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Once in the FINISH state, deallocate ourselves (CallData).
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;      delete this;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;For simplicity the server only uses one completion queue for all events, and
runs a main loop in &lt;code&gt;HandleRpcs&lt;/code&gt; to query the queue:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;HandleRpcs&lt;/span&gt;() {
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Spawn a new CallData instance to serve new clients.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  new CallData(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;service_, cq_.get());
  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; tag;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// uniquely identifies a request.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;bool&lt;/span&gt; ok;
  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;while&lt;/span&gt; (&lt;span style=&#34;color:#366&#34;&gt;true&lt;/span&gt;) {
    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Block waiting to read the next event from the completion queue. The
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// event is uniquely identified by its tag, which in this case is the
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// memory address of a CallData instance.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;    cq_&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Next(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;tag, &lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;ok);
    GPR_ASSERT(ok);
    static_cast&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;CallData&lt;span style=&#34;color:#555&#34;&gt;*&amp;gt;&lt;/span&gt;(tag)&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Proceed();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;shutting-down-the-server&#34;&gt;Shutting Down the Server&lt;/h4&gt;
&lt;p&gt;We&amp;rsquo;ve been using a completion queue to get the async notifications. Care must be
taken to shut it down &lt;em&gt;after&lt;/em&gt; the server has also been shut down.&lt;/p&gt;
&lt;p&gt;Remember we got our completion queue instance &lt;code&gt;cq_&lt;/code&gt; in &lt;code&gt;ServerImpl::Run()&lt;/code&gt; by
running &lt;code&gt;cq_ = builder.AddCompletionQueue()&lt;/code&gt;. Looking at
&lt;code&gt;ServerBuilder::AddCompletionQueue&lt;/code&gt;&amp;rsquo;s documentation we see that&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;hellip; Caller is required to shutdown the server prior to shutting down the
returned completion queue.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Refer to &lt;code&gt;ServerBuilder::AddCompletionQueue&lt;/code&gt;&amp;rsquo;s full docstring for more details.
What this means in our example is that &lt;code&gt;ServerImpl&#39;s&lt;/code&gt; destructor looks like:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span style=&#34;color:#555&#34;&gt;~&lt;/span&gt;ServerImpl() {
  server_&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Shutdown();
  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Always shutdown the completion queue after the server.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  cq_&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;Shutdown();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can see our complete server example in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/cpp/helloworld/greeter_async_server.cc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;greeter_async_server.cc&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: gRPC for .NET</title>
      <link>https://Joevaen.github.io/docs/languages/csharp/dotnet/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/csharp/dotnet/</guid>
      <description>
        
        
        &lt;p&gt;The following pages cover the C# implementation of gRPC for .NET
(&lt;a href=&#34;https://github.com/grpc/grpc-dotnet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-dotnet&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/aspnet/core/grpc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Introduction to gRPC on .NET Core&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.microsoft.com/aspnet/core/tutorials/grpc/grpc-start&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Tutorial: Create a gRPC client and server in ASP.NET Core&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;api&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;API reference&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Several sample applications are available from the &lt;a href=&#34;https://github.com/grpc/grpc-dotnet/tree/master/examples&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;examples&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; folder in the
&lt;a href=&#34;https://github.com/grpc/grpc-dotnet&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;grpc-dotnet&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; repository.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    Looking for gRPC C# core-library documentation?
See the &lt;a href=&#34;..&#34;&gt;gRPC C# main page&lt;/a&gt;.

&lt;/div&gt;


      </description>
    </item>
    
    <item>
      <title>Docs: OAuth2</title>
      <link>https://Joevaen.github.io/docs/languages/objective-c/oauth2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/objective-c/oauth2/</guid>
      <description>
        
        
        &lt;p&gt;This example demonstrates how to use OAuth2 on gRPC to make
authenticated API calls on behalf of a user.&lt;/p&gt;
&lt;p&gt;By walking through it you&amp;rsquo;ll also learn how to use the Objective-C gRPC API to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Initialize and configure a remote call object before the RPC is started.&lt;/li&gt;
&lt;li&gt;Set request metadata elements on a call, which are semantically equivalent to
HTTP request headers.&lt;/li&gt;
&lt;li&gt;Read response metadata from a call, which is equivalent to HTTP response
headers and trailers.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;It assumes you know the basics on how to make gRPC API calls using the
Objective-C client library, as shown in &lt;a href=&#34;../basics/&#34;&gt;Basics tutorial&lt;/a&gt; and the
&lt;a href=&#34;https://Joevaen.github.io/docs/what-is-grpc/introduction/&#34;&gt;Introduction to gRPC&lt;/a&gt;, and are familiar with OAuth2 concepts like &lt;em&gt;access
token&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&#34;setup&#34;&gt;Example code and setup&lt;/h3&gt;
&lt;p&gt;The example code for our tutorial is in
[gprc/examples/objective-c/auth_sample](&lt;a href=&#34;https://github.com/grpc/grpc/tree/&#34;&gt;https://github.com/grpc/grpc/tree/&lt;/a&gt;
v1.37.1/examples/objective-c/auth_sample). To
download the example, clone this repository by running the following commands:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ git clone -b v1.37.1 https://github.com/grpc/grpc
$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; grpc
$ git submodule update --init
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then change your current directory to &lt;code&gt;examples/objective-c/auth_sample&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ &lt;span style=&#34;color:#366&#34;&gt;cd&lt;/span&gt; examples/objective-c/auth_sample
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Our example is a simple application with two views. The first view lets a user
sign in and out using the OAuth2 flow of Google&amp;rsquo;s &lt;a href=&#34;https://developers.google.com/identity/sign-in/ios/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;iOS SignIn
library&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. (Google&amp;rsquo;s library
is used in this example because the test gRPC service we are going to call
expects Google account credentials, but neither gRPC nor the Objective-C client
library is tied to any specific OAuth2 provider). The second view makes a gRPC
request to the test server, using the access token obtained by the first view.&lt;/p&gt;


&lt;div class=&#34;alert alert-info&#34; role=&#34;alert&#34;&gt;
&lt;h4 class=&#34;alert-heading&#34;&gt;Note&lt;/h4&gt;

    OAuth2 libraries need the application to register and obtain an ID from
the identity provider (in the case of this example app, Google). The app&amp;rsquo;s XCode
project is configured using that ID, so you shouldn&amp;rsquo;t copy this project &amp;ldquo;as is&amp;rdquo;
for your own app: it would result in your app being identified in the consent
screen as &amp;ldquo;gRPC-AuthSample&amp;rdquo;, and not having access to real Google services.
Instead, configure your own XCode project following the &lt;a href=&#34;https://developers.google.com/identity/sign-in/ios/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;instructions
here&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.

&lt;/div&gt;

&lt;p&gt;As with the other Objective-C examples, you also should have
&lt;a href=&#34;https://cocoapods.org/#install&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CocoaPods&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt; installed, as well as the relevant
tools to generate the client library code. You can obtain the latter by
following &lt;a href=&#34;https://github.com/grpc/homebrew-grpc&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;these setup instructions&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;try&#34;&gt;Try it out!&lt;/h3&gt;
&lt;p&gt;To try the sample app, first have CocoaPods generate and install the client library for our .proto
files:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-sh&#34; data-lang=&#34;sh&#34;&gt;$ pod install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;(This might have to compile OpenSSL, which takes around 15 minutes if CocoaPods
doesn&amp;rsquo;t have it yet on your computer&amp;rsquo;s cache).&lt;/p&gt;
&lt;p&gt;Finally, open the XCode workspace created by CocoaPods, and run the app.&lt;/p&gt;
&lt;p&gt;The first view, &lt;code&gt;SelectUserViewController.h/m&lt;/code&gt;, asks you to sign in with your
Google account, and to give the &amp;ldquo;gRPC-AuthSample&amp;rdquo; app the following permissions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;View your email address.&lt;/li&gt;
&lt;li&gt;View your basic profile info.&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Test scope for access to the Zoo service&amp;rdquo;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This last permission, corresponding to the scope
&lt;code&gt;https://www.googleapis.com/auth/xapi.zoo&lt;/code&gt; doesn&amp;rsquo;t grant any real capability:
it&amp;rsquo;s only used for testing. You can log out at any time.&lt;/p&gt;
&lt;p&gt;The second view, &lt;code&gt;MakeRPCViewController.h/m&lt;/code&gt;, makes a gRPC request to a test
server at &lt;a href=&#34;https://grpc-test.sandbox.google.com&#34;&gt;https://grpc-test.sandbox.google.com&lt;/a&gt;, sending the access token along
with the request. The test service simply validates the token and writes in its
response which user it belongs to, and which scopes it gives access to. (The
client application already knows those two values; it&amp;rsquo;s a way to verify that
everything went as expected).&lt;/p&gt;
&lt;p&gt;The next sections guide you step-by-step through how the gRPC call in
&lt;code&gt;MakeRPCViewController&lt;/code&gt; is performed. You can see the complete code in
&lt;a href=&#34;https://github.com/grpc/grpc/blob/v1.37.1/examples/objective-c/auth_sample/MakeRPCViewController.m&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;MakeRPCViewController.m&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;rpc-call&#34;&gt;Create a call with access token&lt;/h3&gt;
&lt;p&gt;To make an authenticated call, first you need to initialize a &lt;code&gt;GRPCCallOptions&lt;/code&gt; object and configure
it with the access token.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;GRPCMutableCallOptions &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;options &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [[GRPCMutableCallOptions alloc] init];
options.oauth2AccessToken &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; myAccessToken;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Then you need to create and start your call with this call options object. Assume you have a proto
service definition like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-protobuf&#34; data-lang=&#34;protobuf&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;option&lt;/span&gt; objc_class_prefix &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;AUTH&amp;#34;&lt;/span&gt;;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; TestService {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; UnaryCall(Request) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (Response);&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;A &lt;code&gt;unaryCallWithMessage:responseHandler:callOptions:&lt;/code&gt; method, with which you&amp;rsquo;re already familiar, is
generated for the &lt;code&gt;AUTHTestService&lt;/code&gt; class:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;- (GRPCUnaryProtoRPC &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#c0f&#34;&gt;unaryCallWithMessage:&lt;/span&gt;(AUTHRequest &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#033&#34;&gt;message&lt;/span&gt;
                            &lt;span style=&#34;color:#c0f&#34;&gt;responseHandler:&lt;/span&gt;(&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;id&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;GRPCProtoResponseHandler&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt;)&lt;span style=&#34;color:#033&#34;&gt;responseHandler&lt;/span&gt;
                                &lt;span style=&#34;color:#c0f&#34;&gt;callOptions:&lt;/span&gt;(GRPCCallOptions &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;)&lt;span style=&#34;color:#033&#34;&gt;callOptions&lt;/span&gt;;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Use this method to generated the RPC object with your request options object:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;GRPCUnaryProtoRPC &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;rpc &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [client &lt;span style=&#34;color:#99f&#34;&gt;unaryCallWithMessage&lt;/span&gt;:myRequestMessage
                                      &lt;span style=&#34;color:#99f&#34;&gt;responseHandler&lt;/span&gt;:myResponseHandler
                                          &lt;span style=&#34;color:#99f&#34;&gt;callOptions&lt;/span&gt;:options];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;You can then start the RPC represented by this object at any later time like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;[rpc start];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;authorization-protocol&#34;&gt;An alternative way to provide access token&lt;/h3&gt;
&lt;p&gt;Rather than setting &lt;code&gt;oauth2AccessToken&lt;/code&gt; option in &lt;code&gt;GRPCCallOptions&lt;/code&gt; before the RPC object is
created, an alternative approach allows users providing access token at call start time.&lt;/p&gt;
&lt;p&gt;To use this approach, first create a class in your project that conforms to
&lt;code&gt;GRPCAuthorizationProtocol&lt;/code&gt; protocol.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;@interface&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;TokenProvider&lt;/span&gt; : &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;NSObject&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;GRPCAuthorizationProtocol&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt;
...
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;@end&lt;/span&gt;

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;@implementation&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;TokenProvider&lt;/span&gt;

- (&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt;)&lt;span style=&#34;color:#c0f&#34;&gt;getTokenWithHandler:&lt;/span&gt;(&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;void&lt;/span&gt; (&lt;span style=&#34;color:#555&#34;&gt;^&lt;/span&gt;)(NSString&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; token))&lt;span style=&#34;color:#033&#34;&gt;handler&lt;/span&gt; {
  ...
}

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When creating an RPC object, pass an instance of this class to call option &lt;code&gt;authTokenProvider&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-objective-c&#34; data-lang=&#34;objective-c&#34;&gt;GRPCMutableCallOptions &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;options &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [[GRPCMutableCallOptions alloc] init];
options.authTokenProvider &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [[TokenProvider alloc] init];
GRPCUnaryProtoCall &lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt;rpc &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; [client &lt;span style=&#34;color:#99f&#34;&gt;unaryCallWithMessage&lt;/span&gt;:myRequestMessage
                                       &lt;span style=&#34;color:#99f&#34;&gt;responseHandler&lt;/span&gt;:myResponseHandler
                                           &lt;span style=&#34;color:#99f&#34;&gt;callOptions&lt;/span&gt;:options] start];
[rpc start];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When the call starts, it will call the &lt;code&gt;TokenProvider&lt;/code&gt; instance&amp;rsquo;s &lt;code&gt;getTokenWithHandler:&lt;/code&gt; method with
a callback &lt;code&gt;handler&lt;/code&gt; and waits for the callback. The &lt;code&gt;TokenProvider&lt;/code&gt; instance may call the handler
at any time to provide the token for this call and resume the call process.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: ALTS authentication</title>
      <link>https://Joevaen.github.io/docs/languages/cpp/alts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/cpp/alts/</guid>
      <description>
        
        
        &lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;
&lt;p&gt;Application Layer Transport Security (ALTS) is a mutual authentication and
transport encryption system developed by Google. It is used for securing RPC
communications within Google&amp;rsquo;s infrastructure. ALTS is similar to mutual TLS
but has been designed and optimized to meet the needs of Google&amp;rsquo;s production
environments. For more information, take a look at the
&lt;a href=&#34;https://cloud.google.com/security/encryption-in-transit/application-layer-transport-security&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ALTS whitepaper&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ALTS in gRPC has the following features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create gRPC servers &amp;amp; clients with ALTS as the transport security protocol.&lt;/li&gt;
&lt;li&gt;ALTS connections are end-to-end protected with privacy and integrity.&lt;/li&gt;
&lt;li&gt;Applications can access peer information such as the peer service account.&lt;/li&gt;
&lt;li&gt;Client authorization and server authorization support.&lt;/li&gt;
&lt;li&gt;Minimal code changes to enable ALTS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;gRPC users can configure their applications to use ALTS as a transport security
protocol with few lines of code.&lt;/p&gt;
&lt;p&gt;Note that ALTS is fully functional if the application runs on
&lt;a href=&#34;https://cloud.google.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Platform&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. ALTS could be run on any
platforms with a pluggable
&lt;a href=&#34;https://github.com/grpc/grpc/blob/7e367da22a137e2e7caeae8342c239a91434ba50/src/proto/grpc/gcp/handshaker.proto#L224-L234&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ALTS handshaker service&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;grpc-client-with-alts-transport-security-protocol&#34;&gt;gRPC Client with ALTS Transport Security Protocol&lt;/h3&gt;
&lt;p&gt;gRPC clients can use ALTS credentials to connect to servers, as illustrated in
the following code excerpt:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#099&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;&amp;lt;grpcpp/grpcpp.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;&amp;lt;grpcpp/security/credentials.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;using&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;experimental&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;AltsCredentials;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;using&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;experimental&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;AltsCredentialsOptions;

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;auto&lt;/span&gt; creds &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; AltsCredentials(AltsCredentialsOptions());
std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;Channel&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; channel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; CreateChannel(server_address, creds);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;grpc-server-with-alts-transport-security-protocol&#34;&gt;gRPC Server with ALTS Transport Security Protocol&lt;/h3&gt;
&lt;p&gt;gRPC servers can use ALTS credentials to allow clients to connect to them, as
illustrated next:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#099&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;&amp;lt;grpcpp/security/server_credentials.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;&amp;lt;grpcpp/server.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;&amp;lt;grpcpp/server_builder.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;using&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;experimental&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;AltsServerCredentials;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;using&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;experimental&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;AltsServerCredentialsOptions;

grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;ServerBuilder builder;
builder.RegisterService(&lt;span style=&#34;color:#555&#34;&gt;&amp;amp;&lt;/span&gt;service);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;auto&lt;/span&gt; creds &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; AltsServerCredentials(AltsServerCredentialsOptions());
builder.AddListeningPort(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;[::]:&amp;lt;port&amp;gt;&amp;#34;&lt;/span&gt;, creds);
std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;unique_ptr&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;Server&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; server(builder.BuildAndStart());
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;server-authorization&#34;&gt;Server Authorization&lt;/h3&gt;
&lt;p&gt;gRPC has built-in server authorization support using ALTS. A gRPC client using
ALTS can set the expected server service accounts prior to establishing a
connection. Then, at the end of the handshake, server authorization guarantees
that the server identity matches one of the service accounts specified
by the client. Otherwise, the connection fails.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#099&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;&amp;lt;grpcpp/grpcpp.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;&amp;lt;grpcpp/security/credentials.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;using&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;experimental&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;AltsCredentials;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;using&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;experimental&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;AltsCredentialsOptions;

AltsCredentialsOptions opts;
opts.target_service_accounts.push_back(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;expected_server_service_account1&amp;#34;&lt;/span&gt;);
opts.target_service_accounts.push_back(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;expected_server_service_account2&amp;#34;&lt;/span&gt;);
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;auto&lt;/span&gt; creds &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; AltsCredentials(opts);
std&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;shared_ptr&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;&lt;/span&gt;grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;Channel&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;&lt;/span&gt; channel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; CreateChannel(server_address, creds);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;client-authorization&#34;&gt;Client Authorization&lt;/h3&gt;
&lt;p&gt;On a successful connection, the peer information (e.g., client’s service
account) is stored in the &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/src/proto/grpc/gcp/altscontext.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AltsContext&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. gRPC provides a utility library for
client authorization check. Assuming that the server knows the expected client
identity (e.g., &lt;code&gt;foo@iam.gserviceaccount.com&lt;/code&gt;), it can run the following example
codes to authorize the incoming RPC.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;color:#099&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;&amp;lt;grpcpp/server_context.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;#include&lt;/span&gt; &lt;span style=&#34;color:#099&#34;&gt;&amp;lt;grpcpp/security/alts_util.h&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#099&#34;&gt;&lt;/span&gt;
grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;ServerContext&lt;span style=&#34;color:#555&#34;&gt;*&lt;/span&gt; context;
grpc&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;Status status &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; experimental&lt;span style=&#34;color:#555&#34;&gt;::&lt;/span&gt;AltsClientAuthzCheck(
    context&lt;span style=&#34;color:#555&#34;&gt;-&amp;gt;&lt;/span&gt;auth_context(), {&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;foo@iam.gserviceaccount.com&amp;#34;&lt;/span&gt;});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: ALTS authentication</title>
      <link>https://Joevaen.github.io/docs/languages/go/alts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/go/alts/</guid>
      <description>
        
        
        &lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;
&lt;p&gt;Application Layer Transport Security (ALTS) is a mutual authentication and
transport encryption system developed by Google. It is used for securing RPC
communications within Google&amp;rsquo;s infrastructure. ALTS is similar to mutual TLS
but has been designed and optimized to meet the needs of Google&amp;rsquo;s production
environments. For more information, take a look at the
&lt;a href=&#34;https://cloud.google.com/security/encryption-in-transit/application-layer-transport-security&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ALTS whitepaper&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ALTS in gRPC has the following features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create gRPC servers &amp;amp; clients with ALTS as the transport security protocol.&lt;/li&gt;
&lt;li&gt;ALTS connections are end-to-end protected with privacy and integrity.&lt;/li&gt;
&lt;li&gt;Applications can access peer information such as the peer service account.&lt;/li&gt;
&lt;li&gt;Client authorization and server authorization support.&lt;/li&gt;
&lt;li&gt;Minimal code changes to enable ALTS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;gRPC users can configure their applications to use ALTS as a transport security
protocol with few lines of code.&lt;/p&gt;
&lt;p&gt;Note that ALTS is fully functional if the application runs on
&lt;a href=&#34;https://cloud.google.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Platform&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. ALTS could be run on any
platforms with a pluggable
&lt;a href=&#34;https://github.com/grpc/grpc/blob/7e367da22a137e2e7caeae8342c239a91434ba50/src/proto/grpc/gcp/handshaker.proto#L224-L234&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ALTS handshaker service&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;grpc-client-with-alts-transport-security-protocol&#34;&gt;gRPC Client with ALTS Transport Security Protocol&lt;/h3&gt;
&lt;p&gt;gRPC clients can use ALTS credentials to connect to servers, as illustrated in
the following code excerpt:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; (
  &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;google.golang.org/grpc&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;google.golang.org/grpc/credentials/alts&amp;#34;&lt;/span&gt;
)

altsTC &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; alts.&lt;span style=&#34;color:#c0f&#34;&gt;NewClientCreds&lt;/span&gt;(alts.&lt;span style=&#34;color:#c0f&#34;&gt;DefaultClientOptions&lt;/span&gt;())
conn, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; grpc.&lt;span style=&#34;color:#c0f&#34;&gt;Dial&lt;/span&gt;(serverAddr, grpc.&lt;span style=&#34;color:#c0f&#34;&gt;WithTransportCredentials&lt;/span&gt;(altsTC))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;grpc-server-with-alts-transport-security-protocol&#34;&gt;gRPC Server with ALTS Transport Security Protocol&lt;/h3&gt;
&lt;p&gt;gRPC servers can use ALTS credentials to allow clients to connect to them, as
illustrated next:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; (
  &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;google.golang.org/grpc&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;google.golang.org/grpc/credentials/alts&amp;#34;&lt;/span&gt;
)

altsTC &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; alts.&lt;span style=&#34;color:#c0f&#34;&gt;NewServerCreds&lt;/span&gt;(alts.&lt;span style=&#34;color:#c0f&#34;&gt;DefaultServerOptions&lt;/span&gt;())
server &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; grpc.&lt;span style=&#34;color:#c0f&#34;&gt;NewServer&lt;/span&gt;(grpc.&lt;span style=&#34;color:#c0f&#34;&gt;Creds&lt;/span&gt;(altsTC))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;server-authorization&#34;&gt;Server Authorization&lt;/h3&gt;
&lt;p&gt;gRPC has built-in server authorization support using ALTS. A gRPC client using
ALTS can set the expected server service accounts prior to establishing a
connection. Then, at the end of the handshake, server authorization guarantees
that the server identity matches one of the service accounts specified
by the client. Otherwise, the connection fails.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; (
  &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;google.golang.org/grpc&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;google.golang.org/grpc/credentials/alts&amp;#34;&lt;/span&gt;
)

clientOpts &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; alts.&lt;span style=&#34;color:#c0f&#34;&gt;DefaultClientOptions&lt;/span&gt;()
clientOpts.TargetServiceAccounts = []&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt;{expectedServerSA}
altsTC &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; alts.&lt;span style=&#34;color:#c0f&#34;&gt;NewClientCreds&lt;/span&gt;(clientOpts)
conn, err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; grpc.&lt;span style=&#34;color:#c0f&#34;&gt;Dial&lt;/span&gt;(serverAddr, grpc.&lt;span style=&#34;color:#c0f&#34;&gt;WithTransportCredentials&lt;/span&gt;(altsTC))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;client-authorization&#34;&gt;Client Authorization&lt;/h3&gt;
&lt;p&gt;On a successful connection, the peer information (e.g., client’s service
account) is stored in the &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/src/proto/grpc/gcp/altscontext.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AltsContext&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. gRPC provides a utility library for
client authorization check. Assuming that the server knows the expected client
identity (e.g., &lt;code&gt;foo@iam.gserviceaccount.com&lt;/code&gt;), it can run the following example
codes to authorize the incoming RPC.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; (
  &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;google.golang.org/grpc&amp;#34;&lt;/span&gt;
  &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;google.golang.org/grpc/credentials/alts&amp;#34;&lt;/span&gt;
)

err &lt;span style=&#34;color:#555&#34;&gt;:=&lt;/span&gt; alts.&lt;span style=&#34;color:#c0f&#34;&gt;ClientAuthorizationCheck&lt;/span&gt;(ctx, []&lt;span style=&#34;color:#078;font-weight:bold&#34;&gt;string&lt;/span&gt;{&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;foo@iam.gserviceaccount.com&amp;#34;&lt;/span&gt;})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: ALTS authentication</title>
      <link>https://Joevaen.github.io/docs/languages/java/alts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/java/alts/</guid>
      <description>
        
        
        &lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;
&lt;p&gt;Application Layer Transport Security (ALTS) is a mutual authentication and
transport encryption system developed by Google. It is used for securing RPC
communications within Google&amp;rsquo;s infrastructure. ALTS is similar to mutual TLS
but has been designed and optimized to meet the needs of Google&amp;rsquo;s production
environments. For more information, take a look at the
&lt;a href=&#34;https://cloud.google.com/security/encryption-in-transit/application-layer-transport-security&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ALTS whitepaper&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ALTS in gRPC has the following features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create gRPC servers &amp;amp; clients with ALTS as the transport security protocol.&lt;/li&gt;
&lt;li&gt;ALTS connections are end-to-end protected with privacy and integrity.&lt;/li&gt;
&lt;li&gt;Applications can access peer information such as the peer service account.&lt;/li&gt;
&lt;li&gt;Client authorization and server authorization support.&lt;/li&gt;
&lt;li&gt;Minimal code changes to enable ALTS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;gRPC users can configure their applications to use ALTS as a transport security
protocol with few lines of code.&lt;/p&gt;
&lt;p&gt;Note that ALTS is fully functional if the application runs on
&lt;a href=&#34;https://cloud.google.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Platform&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. ALTS could be run on any
platforms with a pluggable
&lt;a href=&#34;https://github.com/grpc/grpc/blob/7e367da22a137e2e7caeae8342c239a91434ba50/src/proto/grpc/gcp/handshaker.proto#L224-L234&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ALTS handshaker service&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;grpc-client-with-alts-transport-security-protocol&#34;&gt;gRPC Client with ALTS Transport Security Protocol&lt;/h3&gt;
&lt;p&gt;gRPC clients can use ALTS credentials to connect to servers, as illustrated in
the following code excerpt:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;io.grpc.alts.AltsChannelBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;io.grpc.ManagedChannel&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;

ManagedChannel managedChannel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
    AltsChannelBuilder&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;forTarget&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;serverAddress&lt;span style=&#34;color:#555&#34;&gt;).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;grpc-server-with-alts-transport-security-protocol&#34;&gt;gRPC Server with ALTS Transport Security Protocol&lt;/h3&gt;
&lt;p&gt;gRPC servers can use ALTS credentials to allow clients to connect to them, as
illustrated next:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;io.grpc.alts.AltsServerBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;io.grpc.Server&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;

Server server &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; AltsServerBuilder&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;forPort&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&amp;lt;&lt;/span&gt;port&lt;span style=&#34;color:#555&#34;&gt;&amp;gt;)&lt;/span&gt;
    &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;addService&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;new&lt;/span&gt; MyServiceImpl&lt;span style=&#34;color:#555&#34;&gt;()).&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;().&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;start&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;server-authorization&#34;&gt;Server Authorization&lt;/h3&gt;
&lt;p&gt;gRPC has built-in server authorization support using ALTS. A gRPC client using
ALTS can set the expected server service accounts prior to establishing a
connection. Then, at the end of the handshake, server authorization guarantees
that the server identity matches one of the service accounts specified
by the client. Otherwise, the connection fails.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;io.grpc.alts.AltsChannelBuilder&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;io.grpc.ManagedChannel&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;

ManagedChannel channel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;
    AltsChannelBuilder&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;forTarget&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;serverAddress&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;addTargetServiceAccount&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;expected_server_service_account1&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;addTargetServiceAccount&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;expected_server_service_account2&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;)&lt;/span&gt;
        &lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;build&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;client-authorization&#34;&gt;Client Authorization&lt;/h3&gt;
&lt;p&gt;On a successful connection, the peer information (e.g., client’s service
account) is stored in the &lt;a href=&#34;https://github.com/grpc/grpc/blob/master/src/proto/grpc/gcp/altscontext.proto&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AltsContext&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. gRPC provides a utility library for
client authorization check. Assuming that the server knows the expected client
identity (e.g., &lt;code&gt;foo@iam.gserviceaccount.com&lt;/code&gt;), it can run the following example
codes to authorize the incoming RPC.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;io.grpc.alts.AuthorizationUtil&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;io.grpc.ServerCall&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;io.grpc.Status&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;

ServerCall&lt;span style=&#34;color:#555&#34;&gt;&amp;lt;?,&lt;/span&gt; &lt;span style=&#34;color:#555&#34;&gt;?&amp;gt;&lt;/span&gt; call&lt;span style=&#34;color:#555&#34;&gt;;&lt;/span&gt;
Status status &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; AuthorizationUtil&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;clientAuthorizationCheck&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;
    call&lt;span style=&#34;color:#555&#34;&gt;,&lt;/span&gt; Lists&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;&lt;span style=&#34;color:#309&#34;&gt;newArrayList&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;(&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;foo@iam.gserviceaccount.com&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#555&#34;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: ALTS authentication</title>
      <link>https://Joevaen.github.io/docs/languages/python/alts/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/python/alts/</guid>
      <description>
        
        
        &lt;h3 id=&#34;overview&#34;&gt;Overview&lt;/h3&gt;
&lt;p&gt;Application Layer Transport Security (ALTS) is a mutual authentication and
transport encryption system developed by Google. It is used for securing RPC
communications within Google&amp;rsquo;s infrastructure. ALTS is similar to mutual TLS
but has been designed and optimized to meet the needs of Google&amp;rsquo;s production
environments. For more information, take a look at the
&lt;a href=&#34;https://cloud.google.com/security/encryption-in-transit/application-layer-transport-security&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ALTS whitepaper&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;ALTS in gRPC has the following features:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create gRPC servers &amp;amp; clients with ALTS as the transport security protocol.&lt;/li&gt;
&lt;li&gt;ALTS connections are end-to-end protected with privacy and integrity.&lt;/li&gt;
&lt;li&gt;Applications can access peer information such as the peer service account.&lt;/li&gt;
&lt;li&gt;Client authorization and server authorization support.&lt;/li&gt;
&lt;li&gt;Minimal code changes to enable ALTS.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;gRPC users can configure their applications to use ALTS as a transport security
protocol with few lines of code.&lt;/p&gt;
&lt;p&gt;Note that ALTS is fully functional if the application runs on
&lt;a href=&#34;https://cloud.google.com&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Google Cloud Platform&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;. ALTS could be run on any
platforms with a pluggable
&lt;a href=&#34;https://github.com/grpc/grpc/blob/7e367da22a137e2e7caeae8342c239a91434ba50/src/proto/grpc/gcp/handshaker.proto#L224-L234&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ALTS handshaker service&lt;i class=&#34;fas fa-external-link-alt&#34;&gt;&lt;/i&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;grpc-client-with-alts-transport-security-protocol&#34;&gt;gRPC Client with ALTS Transport Security Protocol&lt;/h3&gt;
&lt;p&gt;gRPC clients can use ALTS credentials to connect to servers, as illustrated in
the following code excerpt:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;grpc&lt;/span&gt;

channel_creds &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;alts_channel_credentials()
channel &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;secure_channel(address, channel_creds)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;grpc-server-with-alts-transport-security-protocol&#34;&gt;gRPC Server with ALTS Transport Security Protocol&lt;/h3&gt;
&lt;p&gt;gRPC servers can use ALTS credentials to allow clients to connect to them, as
illustrated next:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;grpc&lt;/span&gt;

server &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;server(futures&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;ThreadPoolExecutor())
server_creds &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;alts_server_credentials()
server&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;add_secure_port(server_address, server_creds)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
      </description>
    </item>
    
    <item>
      <title>Docs: Generated-code reference</title>
      <link>https://Joevaen.github.io/docs/languages/python/generated-code/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/python/generated-code/</guid>
      <description>
        
        
        &lt;p&gt;gRPC Python relies on the protocol buffers compiler (&lt;code&gt;protoc&lt;/code&gt;) to generate
code.  It uses a plugin to supplement the generated code by plain &lt;code&gt;protoc&lt;/code&gt;
with gRPC-specific code.  For a &lt;code&gt;.proto&lt;/code&gt; service description containing
gRPC services, the plain &lt;code&gt;protoc&lt;/code&gt; generated code is synthesized in
a &lt;code&gt;_pb2.py&lt;/code&gt; file, and the gRPC-specific code lands in a &lt;code&gt;_pb2_grpc.py&lt;/code&gt; file.
The latter python module imports the former.  The focus of this page is
on the gRPC-specific subset of the generated code.&lt;/p&gt;
&lt;h2 id=&#34;example&#34;&gt;Example&lt;/h2&gt;
&lt;p&gt;Consider the following &lt;code&gt;FortuneTeller&lt;/code&gt; proto service:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-proto&#34; data-lang=&#34;proto&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;service&lt;/span&gt; FortuneTeller {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Returns the horoscope and zodiac sign for the given month and day.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; TellFortune(HoroscopeRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (HoroscopeResponse) {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// errors: invalid month or day, fortune unavailable
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  }&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// Replaces the fortune for the given zodiac sign with the provided one.
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;rpc&lt;/span&gt; SuggestFortune(SuggestionRequest) &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;returns&lt;/span&gt; (SuggestionResponse) {&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;// errors: invalid zodiac sign
&lt;/span&gt;&lt;span style=&#34;color:#09f;font-style:italic&#34;&gt;&lt;/span&gt;  }&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;&lt;/span&gt;}&lt;span style=&#34;color:#a00;background-color:#faa&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;When the service is compiled, the gRPC &lt;code&gt;protoc&lt;/code&gt; plugin generates code similar to
the following &lt;code&gt;_pb2_grpc.py&lt;/code&gt; file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;grpc&lt;/span&gt;

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#0cf;font-weight:bold&#34;&gt;fortune_pb2&lt;/span&gt;

&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;FortuneTellerStub&lt;/span&gt;(&lt;span style=&#34;color:#366&#34;&gt;object&lt;/span&gt;):

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; __init__(self, channel):
    &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Constructor.
&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;
&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;    Args:
&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;      channel: A grpc.Channel.
&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    self&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;TellFortune &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; channel&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;unary_unary(
        &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;/example.FortuneTeller/TellFortune&amp;#39;&lt;/span&gt;,
        request_serializer&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;fortune_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;HoroscopeRequest&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SerializeToString,
        response_deserializer&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;fortune_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;HoroscopeResponse&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;FromString,
        )
    self&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SuggestFortune &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; channel&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;unary_unary(
        &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;/example.FortuneTeller/SuggestFortune&amp;#39;&lt;/span&gt;,
        request_serializer&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;fortune_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SuggestionRequest&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SerializeToString,
        response_deserializer&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;fortune_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SuggestionResponse&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;FromString,
        )


&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#0a8;font-weight:bold&#34;&gt;FortuneTellerServicer&lt;/span&gt;(&lt;span style=&#34;color:#366&#34;&gt;object&lt;/span&gt;):

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;TellFortune&lt;/span&gt;(self, request, context):
    &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Returns the horoscope and zodiac sign for the given month and day.
&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;    errors: invalid month or day, fortune unavailable
&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    context&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;set_code(grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;StatusCode&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;UNIMPLEMENTED)
    context&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;set_details(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Method not implemented!&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;raise&lt;/span&gt; &lt;span style=&#34;color:#c00;font-weight:bold&#34;&gt;NotImplementedError&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Method not implemented!&amp;#39;&lt;/span&gt;)

  &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;SuggestFortune&lt;/span&gt;(self, request, context):
    &lt;span style=&#34;color:#c30&#34;&gt;&amp;#34;&amp;#34;&amp;#34;Replaces the fortune for the given zodiac sign with the provided
&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;one.
&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;    errors: invalid zodiac sign
&lt;/span&gt;&lt;span style=&#34;color:#c30&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    context&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;set_code(grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;StatusCode&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;UNIMPLEMENTED)
    context&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;set_details(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Method not implemented!&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;raise&lt;/span&gt; &lt;span style=&#34;color:#c00;font-weight:bold&#34;&gt;NotImplementedError&lt;/span&gt;(&lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;Method not implemented!&amp;#39;&lt;/span&gt;)


&lt;span style=&#34;color:#069;font-weight:bold&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#c0f&#34;&gt;add_FortuneTellerServicer_to_server&lt;/span&gt;(servicer, server):
  rpc_method_handlers &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; {
      &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;TellFortune&amp;#39;&lt;/span&gt;: grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;unary_unary_rpc_method_handler(
          servicer&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;TellFortune,
          request_deserializer&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;fortune_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;HoroscopeRequest&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;FromString,
          response_serializer&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;fortune_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;HoroscopeResponse&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SerializeToString,
      ),
      &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;SuggestFortune&amp;#39;&lt;/span&gt;: grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;unary_unary_rpc_method_handler(
          servicer&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SuggestFortune,
          request_deserializer&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;fortune_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SuggestionRequest&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;FromString,
          response_serializer&lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt;fortune_pb2&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SuggestionResponse&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;SerializeToString,
      ),
  }
  generic_handler &lt;span style=&#34;color:#555&#34;&gt;=&lt;/span&gt; grpc&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;method_handlers_generic_handler(
      &lt;span style=&#34;color:#c30&#34;&gt;&amp;#39;example.FortuneTeller&amp;#39;&lt;/span&gt;, rpc_method_handlers)
  server&lt;span style=&#34;color:#555&#34;&gt;.&lt;/span&gt;add_generic_rpc_handlers((generic_handler,))
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;code-elements&#34;&gt;Code Elements&lt;/h2&gt;
&lt;p&gt;The gRPC generated code starts by importing the &lt;code&gt;grpc&lt;/code&gt; package and the plain
&lt;code&gt;_pb2&lt;/code&gt; module, synthesized by &lt;code&gt;protoc&lt;/code&gt;, which defines non-gRPC-specific code
elements, like the classes corresponding to protocol buffers messages and
descriptors used by reflection.&lt;/p&gt;
&lt;p&gt;For each service &lt;code&gt;Foo&lt;/code&gt; in the &lt;code&gt;.proto&lt;/code&gt; file, three primary elements are
generated:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#stub&#34;&gt;&lt;strong&gt;Stub&lt;/strong&gt;&lt;/a&gt;: &lt;code&gt;FooStub&lt;/code&gt; used by the client to connect to a gRPC service.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#servicer&#34;&gt;&lt;strong&gt;Servicer&lt;/strong&gt;&lt;/a&gt;: &lt;code&gt;FooServicer&lt;/code&gt; used by the server to implement a
gRPC service.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#registration-function&#34;&gt;&lt;strong&gt;Registration Function&lt;/strong&gt;&lt;/a&gt;:
&lt;code&gt;add_FooServicer_to_server&lt;/code&gt; function used to register a servicer with a
&lt;code&gt;grpc.Server&lt;/code&gt; object.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;stub&#34;&gt;Stub&lt;/h3&gt;
&lt;p&gt;The generated &lt;code&gt;Stub&lt;/code&gt; class is used by the gRPC clients.  It
has a constructor that takes a &lt;code&gt;grpc.Channel&lt;/code&gt; object and initializes the
stub. For each method in the service, the initializer adds a corresponding
attribute to the stub object with the same name.  Depending on the RPC type
(unary or streaming), the value of that attribute will be callable
objects of type
&lt;a href=&#34;https://Joevaen.github.io/grpc/python/grpc.html?#grpc.UnaryUnaryMultiCallable&#34;&gt;UnaryUnaryMultiCallable&lt;/a&gt;,
&lt;a href=&#34;https://Joevaen.github.io/grpc/python/grpc.html?#grpc.UnaryStreamMultiCallable&#34;&gt;UnaryStreamMultiCallable&lt;/a&gt;,
&lt;a href=&#34;https://Joevaen.github.io/grpc/python/grpc.html?#grpc.StreamUnaryMultiCallable&#34;&gt;StreamUnaryMultiCallable&lt;/a&gt;,
or
&lt;a href=&#34;https://Joevaen.github.io/grpc/python/grpc.html?#grpc.StreamStreamMultiCallable&#34;&gt;StreamStreamMultiCallable&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&#34;servicer&#34;&gt;Servicer&lt;/h3&gt;
&lt;p&gt;For each service, a &lt;code&gt;Servicer&lt;/code&gt; class is generated, which
serves as the superclass of a service implementation.  For
each method in the service, a corresponding function in the &lt;code&gt;Servicer&lt;/code&gt; class
is generated. Override this function with the service
implementation.  Comments associated with code elements
in the &lt;code&gt;.proto&lt;/code&gt; file appear as docstrings in
the generated python code.&lt;/p&gt;
&lt;h3 id=&#34;registration-function&#34;&gt;Registration Function&lt;/h3&gt;
&lt;p&gt;For each service, a function is
generated that registers a &lt;code&gt;Servicer&lt;/code&gt; object implementing it on a &lt;code&gt;grpc.Server&lt;/code&gt;
object, so that the server can route queries to
the respective servicer.  This function takes an object that implements the
&lt;code&gt;Servicer&lt;/code&gt;, typically an instance of a subclass of the generated &lt;code&gt;Servicer&lt;/code&gt;
code element described above, and a
&lt;a href=&#34;https://Joevaen.github.io/grpc/python/_modules/grpc.html#Server&#34;&gt;grpc.Server&lt;/a&gt;
object.&lt;/p&gt;

      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/cpp/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/cpp/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/csharp/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/csharp/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/dart/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/dart/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/go/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/go/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/java/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/java/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/kotlin/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/kotlin/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/node/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/node/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/objective-c/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/objective-c/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/php/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/php/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/python/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/python/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/languages/ruby/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/ruby/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/platforms/android/java/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/platforms/android/java/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: API reference</title>
      <link>https://Joevaen.github.io/docs/platforms/android/kotlin/api/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/platforms/android/kotlin/api/</guid>
      <description>
        
        
        
      </description>
    </item>
    
    <item>
      <title>Docs: Daily builds</title>
      <link>https://Joevaen.github.io/docs/languages/csharp/daily-builds/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://Joevaen.github.io/docs/languages/csharp/daily-builds/</guid>
      <description>
        
        
        
      </description>
    </item>
    
  </channel>
</rss>
